{"version":3,"file":"index.js","sources":["../src/tokenizer/types.js","../src/util/scopeflags.js","../src/plugins/estree.js","../node_modules/charcodes/lib/index.mjs","../src/util/whitespace.js","../src/tokenizer/context.js","../src/util/identifier.js","../src/plugins/flow.js","../src/plugins/jsx/xhtml.js","../src/plugins/jsx/index.js","../src/util/scope.js","../src/plugins/typescript/scope.js","../src/plugins/typescript/index.js","../src/plugins/placeholders.js","../src/plugin-utils.js","../src/options.js","../src/arabic.js","../src/util/location.js","../src/parser/base.js","../src/parser/comments.js","../src/parser/location.js","../src/tokenizer/state.js","../src/tokenizer/index.js","../src/parser/util.js","../src/parser/node.js","../src/parser/lval.js","../src/parser/expression.js","../src/parser/statement.js","../src/parser/index.js","../src/index.js"],"sourcesContent":["// @flow\r\n\r\n// ## Token types\r\n\r\n// The assignment of fine-grained, information-carrying type objects\r\n// allows the tokenizer to store the information it has about a\r\n// token in a way that is very cheap for the parser to look up.\r\n\r\n// All token type variables start with an underscore, to make them\r\n// easy to recognize.\r\n\r\n// The `beforeExpr` property is used to disambiguate between regular\r\n// expressions and divisions. It is set on all token types that can\r\n// be followed by an expression (thus, a slash after them would be a\r\n// regular expression).\r\n\r\n// The `startsExpr` property is used to determine whether an expression\r\n// may be the “argument” subexpression of a `yield` expression or\r\n// `yield` statement. It is set on all token types that may be at the\r\n// start of a subexpression.\r\n\r\n// `isLoop` marks a keyword as starting a loop, which is important\r\n// to know when parsing a label, in order to allow or disallow\r\n// continue jumps to that label.\r\n\r\nconst beforeExpr = true;\r\nconst startsExpr = true;\r\nconst isLoop = true;\r\nconst isAssign = true;\r\nconst prefix = true;\r\nconst postfix = true;\r\n\r\ntype TokenOptions = {\r\n  keyword?: string,\r\n  beforeExpr?: boolean,\r\n  startsExpr?: boolean,\r\n  rightAssociative?: boolean,\r\n  isLoop?: boolean,\r\n  isAssign?: boolean,\r\n  prefix?: boolean,\r\n  postfix?: boolean,\r\n  binop?: ?number,\r\n};\r\n\r\nexport class TokenType {\r\n  label: string;\r\n  keyword: ?string;\r\n  beforeExpr: boolean;\r\n  startsExpr: boolean;\r\n  rightAssociative: boolean;\r\n  isLoop: boolean;\r\n  isAssign: boolean;\r\n  prefix: boolean;\r\n  postfix: boolean;\r\n  binop: ?number;\r\n  updateContext: ?(prevType: TokenType) => void;\r\n\r\n  constructor(label: string, conf: TokenOptions = {}) {\r\n    this.label = label;\r\n    this.keyword = conf.keyword;\r\n    this.beforeExpr = !!conf.beforeExpr;\r\n    this.startsExpr = !!conf.startsExpr;\r\n    this.rightAssociative = !!conf.rightAssociative;\r\n    this.isLoop = !!conf.isLoop;\r\n    this.isAssign = !!conf.isAssign;\r\n    this.prefix = !!conf.prefix;\r\n    this.postfix = !!conf.postfix;\r\n    this.binop = conf.binop != null ? conf.binop : null;\r\n    this.updateContext = null;\r\n  }\r\n}\r\n\r\nexport const keywords = new Map<string, TokenType>();\r\n\r\nfunction createKeyword(name: string, options: TokenOptions = {}): TokenType {\r\n  options.keyword = name;\r\n  const token = new TokenType(name, options);\r\n  keywords.set(name, token);\r\n  return token;\r\n}\r\n\r\nfunction createBinop(name: string, binop: number) {\r\n  return new TokenType(name, { beforeExpr, binop });\r\n}\r\n\r\nexport const types: { [name: string]: TokenType } = {\r\n  num: new TokenType(\"num\", { startsExpr }),\r\n  bigint: new TokenType(\"bigint\", { startsExpr }),\r\n  regexp: new TokenType(\"regexp\", { startsExpr }),\r\n  string: new TokenType(\"string\", { startsExpr }),\r\n  name: new TokenType(\"name\", { startsExpr }),\r\n  eof: new TokenType(\"eof\"),\r\n\r\n  // Punctuation token types.\r\n  bracketL: new TokenType(\"[\", { beforeExpr, startsExpr }),\r\n  bracketR: new TokenType(\"]\"),\r\n  braceL: new TokenType(\"{\", { beforeExpr, startsExpr }),\r\n  braceBarL: new TokenType(\"{|\", { beforeExpr, startsExpr }),\r\n  braceR: new TokenType(\"}\"),\r\n  braceBarR: new TokenType(\"|}\"),\r\n  parenL: new TokenType(\"(\", { beforeExpr, startsExpr }),\r\n  parenR: new TokenType(\")\"),\r\n  comma: new TokenType(\",\", { beforeExpr }),\r\n  semi: new TokenType(\";\", { beforeExpr }),\r\n  colon: new TokenType(\":\", { beforeExpr }),\r\n  doubleColon: new TokenType(\"::\", { beforeExpr }),\r\n  dot: new TokenType(\".\"),\r\n  question: new TokenType(\"؟\", { beforeExpr }),\r\n  questionDot: new TokenType(\"؟.\"),\r\n  arrow: new TokenType(\"=>\", { beforeExpr }),\r\n  template: new TokenType(\"template\"),\r\n  ellipsis: new TokenType(\"...\", { beforeExpr }),\r\n  backQuote: new TokenType(\"`\", { startsExpr }),\r\n  dollarBraceL: new TokenType(\"${\", { beforeExpr, startsExpr }),\r\n  at: new TokenType(\"@\"),\r\n  hash: new TokenType(\"#\", { startsExpr }),\r\n\r\n  // Special hashbang token.\r\n  interpreterDirective: new TokenType(\"#!...\"),\r\n\r\n  // Operators. These carry several kinds of properties to help the\r\n  // parser use them properly (the presence of these properties is\r\n  // what categorizes them as operators).\r\n  //\r\n  // `binop`, when present, specifies that this operator is a binary\r\n  // operator, and will refer to its precedence.\r\n  //\r\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\r\n  // unary operator.\r\n  //\r\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\r\n  // binary operators with a very low precedence, that should result\r\n  // in AssignmentExpression nodes.\r\n\r\n  eq: new TokenType(\"=\", { beforeExpr, isAssign }),\r\n  assign: new TokenType(\"_=\", { beforeExpr, isAssign }),\r\n  incDec: new TokenType(\"++/--\", { prefix, postfix, startsExpr }),\r\n  bang: new TokenType(\"!\", { beforeExpr, prefix, startsExpr }),\r\n  tilde: new TokenType(\"~\", { beforeExpr, prefix, startsExpr }),\r\n  pipeline: createBinop(\"|>\", 0),\r\n  nullishCoalescing: createBinop(\"??\", 1),\r\n  logicalOR: createBinop(\"||\", 1),\r\n  logicalAND: createBinop(\"&&\", 2),\r\n  bitwiseOR: createBinop(\"|\", 3),\r\n  bitwiseXOR: createBinop(\"^\", 4),\r\n  bitwiseAND: createBinop(\"&\", 5),\r\n  equality: createBinop(\"==/!=/===/!==\", 6),\r\n  relational: createBinop(\"</>/<=/>=\", 7),\r\n  bitShift: createBinop(\"<</>>/>>>\", 8),\r\n  plusMin: new TokenType(\"+/-\", { beforeExpr, binop: 9, prefix, startsExpr }),\r\n  modulo: createBinop(\"%\", 10),\r\n  star: createBinop(\"*\", 10),\r\n  slash: createBinop(\"/\", 10),\r\n  exponent: new TokenType(\"**\", {\r\n    beforeExpr,\r\n    binop: 11,\r\n    rightAssociative: true,\r\n  }),\r\n\r\n  // Keywords\r\n  _break: createKeyword(\"خروج\"),\r\n  _case: createKeyword(\"حالة\", { beforeExpr }),\r\n  _catch: createKeyword(\"مشكلة\"),\r\n  _continue: createKeyword(\"اكمل\"),\r\n  _debugger: createKeyword(\"debugger\"),\r\n  _default: createKeyword(\"default\", { beforeExpr }),\r\n  _do: createKeyword(\"افعل\", { isLoop, beforeExpr }),\r\n  _else: createKeyword(\"غير\", { beforeExpr }),\r\n  _finally: createKeyword(\"اخيرا\"),\r\n  _for: createKeyword(\"تكرار\", { isLoop }),\r\n  _function: createKeyword(\"مهمة\", { startsExpr }),\r\n  _if: createKeyword(\"اذا\"),\r\n  _return: createKeyword(\"ارجاع\", { beforeExpr }),\r\n  _switch: createKeyword(\"فاصل\"),\r\n  _throw: createKeyword(\"throw\", { beforeExpr, prefix, startsExpr }),\r\n  _try: createKeyword(\"حاول\"),\r\n  _var: createKeyword(\"متغير\"),\r\n  _const: createKeyword(\"ثابت\"),\r\n  _while: createKeyword(\"طالما\", { isLoop }),\r\n  _with: createKeyword(\"with\"),\r\n  _new: createKeyword(\"جديد\", { beforeExpr, startsExpr }),\r\n  _this: createKeyword(\"this\", { startsExpr }),\r\n  _super: createKeyword(\"ابي\", { startsExpr }),\r\n  _class: createKeyword(\"صنف\", { startsExpr }),\r\n  _extends: createKeyword(\"يرث\", { beforeExpr }),\r\n  _export: createKeyword(\"export\"),\r\n  _import: createKeyword(\"استيراد\", { startsExpr }),\r\n  _null: createKeyword(\"فارغ\", { startsExpr }),\r\n  _true: createKeyword(\"صح\", { startsExpr }),\r\n  _false: createKeyword(\"غلط\", { startsExpr }),\r\n  _in: createKeyword(\"in\", { beforeExpr, binop: 7 }),\r\n  _instanceof: createKeyword(\"instanceof\", { beforeExpr, binop: 7 }),\r\n  _typeof: createKeyword(\"نوع\", { beforeExpr, prefix, startsExpr }),\r\n  _void: createKeyword(\"عقيم\", { beforeExpr, prefix, startsExpr }),\r\n  _delete: createKeyword(\"delete\", { beforeExpr, prefix, startsExpr }),\r\n};\r\n","// @flow\r\n\r\n// Each scope gets a bitset that may contain these flags\r\n// prettier-ignore\r\nexport const SCOPE_OTHER        = 0b000000000,\r\n             SCOPE_PROGRAM      = 0b000000001,\r\n             SCOPE_FUNCTION     = 0b000000010,\r\n             SCOPE_ASYNC        = 0b000000100,\r\n             SCOPE_GENERATOR    = 0b000001000,\r\n             SCOPE_ARROW        = 0b000010000,\r\n             SCOPE_SIMPLE_CATCH = 0b000100000,\r\n             SCOPE_SUPER        = 0b001000000,\r\n             SCOPE_DIRECT_SUPER = 0b010000000,\r\n             SCOPE_CLASS        = 0b100000000,\r\n             SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION;\r\n\r\nexport type ScopeFlags =\r\n  | typeof SCOPE_OTHER\r\n  | typeof SCOPE_PROGRAM\r\n  | typeof SCOPE_FUNCTION\r\n  | typeof SCOPE_VAR\r\n  | typeof SCOPE_ASYNC\r\n  | typeof SCOPE_GENERATOR\r\n  | typeof SCOPE_ARROW\r\n  | typeof SCOPE_SIMPLE_CATCH\r\n  | typeof SCOPE_SUPER\r\n  | typeof SCOPE_DIRECT_SUPER\r\n  | typeof SCOPE_CLASS;\r\n\r\nexport function functionFlags(isAsync: boolean, isGenerator: boolean) {\r\n  return (\r\n    SCOPE_FUNCTION |\r\n    (isAsync ? SCOPE_ASYNC : 0) |\r\n    (isGenerator ? SCOPE_GENERATOR : 0)\r\n  );\r\n}\r\n\r\n// These flags are meant to be _only_ used inside the Scope class (or subclasses).\r\n// prettier-ignore\r\nexport const BIND_KIND_VALUE           = 0b00000_0000_01,\r\n             BIND_KIND_TYPE            = 0b00000_0000_10,\r\n             // Used in checkLVal and declareName to determine the type of a binding\r\n             BIND_SCOPE_VAR            = 0b00000_0001_00, // Var-style binding\r\n             BIND_SCOPE_LEXICAL        = 0b00000_0010_00, // Let- or const-style binding\r\n             BIND_SCOPE_FUNCTION       = 0b00000_0100_00, // Function declaration\r\n             BIND_SCOPE_OUTSIDE        = 0b00000_1000_00, // Special case for function names as\r\n                                                   // bound inside the function\r\n             // Misc flags\r\n             BIND_FLAGS_NONE           = 0b00001_0000_00,\r\n             BIND_FLAGS_CLASS          = 0b00010_0000_00,\r\n             BIND_FLAGS_TS_ENUM        = 0b00100_0000_00,\r\n             BIND_FLAGS_TS_CONST_ENUM  = 0b01000_0000_00,\r\n             BIND_FLAGS_TS_EXPORT_ONLY = 0b10000_0000_00;\r\n\r\n// These flags are meant to be _only_ used by Scope consumers\r\n// prettier-ignore\r\n/*                              =    is value?    |    is type?    |      scope          |    misc flags    */\r\nexport const BIND_CLASS         = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL  | BIND_FLAGS_CLASS  ,\r\n             BIND_LEXICAL       = BIND_KIND_VALUE | 0              | BIND_SCOPE_LEXICAL  | 0                 ,\r\n             BIND_VAR           = BIND_KIND_VALUE | 0              | BIND_SCOPE_VAR      | 0                 ,\r\n             BIND_FUNCTION      = BIND_KIND_VALUE | 0              | BIND_SCOPE_FUNCTION | 0                 ,\r\n             BIND_TS_INTERFACE  = 0               | BIND_KIND_TYPE | 0                   | BIND_FLAGS_CLASS  ,\r\n             BIND_TS_TYPE       = 0               | BIND_KIND_TYPE | 0                   | 0                 ,\r\n             BIND_TS_ENUM       = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL  | BIND_FLAGS_TS_ENUM,\r\n             BIND_TS_FN_TYPE    = 0               | 0              | 0            | BIND_FLAGS_TS_EXPORT_ONLY,\r\n             // These bindings don't introduce anything in the scope. They are used for assignments and\r\n             // function expressions IDs.\r\n             BIND_NONE          = 0               | 0              | 0                   | BIND_FLAGS_NONE   ,\r\n             BIND_OUTSIDE       = BIND_KIND_VALUE | 0              | 0                   | BIND_FLAGS_NONE   ,\r\n\r\n             BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\r\n             BIND_TS_NAMESPACE  = BIND_TS_FN_TYPE;\r\n\r\nexport type BindingTypes =\r\n  | typeof BIND_NONE\r\n  | typeof BIND_OUTSIDE\r\n  | typeof BIND_VAR\r\n  | typeof BIND_LEXICAL\r\n  | typeof BIND_CLASS\r\n  | typeof BIND_FUNCTION\r\n  | typeof BIND_TS_INTERFACE\r\n  | typeof BIND_TS_TYPE\r\n  | typeof BIND_TS_ENUM\r\n  | typeof BIND_TS_FN_TYPE\r\n  | typeof BIND_TS_NAMESPACE;\r\n","// @flow\r\n\r\nimport { types as tt, TokenType } from \"../tokenizer/types\";\r\nimport type Parser from \"../parser\";\r\nimport * as N from \"../types\";\r\nimport type { Pos, Position } from \"../util/location\";\r\nimport { type BindingTypes, BIND_NONE } from \"../util/scopeflags\";\r\n\r\nfunction isSimpleProperty(node: N.Node): boolean {\r\n  return (\r\n    node != null &&\r\n    node.type === \"Property\" &&\r\n    node.kind === \"init\" &&\r\n    node.method === false\r\n  );\r\n}\r\n\r\nexport default (superClass: Class<Parser>): Class<Parser> =>\r\n  class extends superClass {\r\n    estreeParseRegExpLiteral({ pattern, flags }: N.RegExpLiteral): N.Node {\r\n      let regex = null;\r\n      try {\r\n        regex = new RegExp(pattern, flags);\r\n      } catch (e) {\r\n        // In environments that don't support these flags value will\r\n        // be null as the regex can't be represented natively.\r\n      }\r\n      const node = this.estreeParseLiteral(regex);\r\n      node.regex = { pattern, flags };\r\n\r\n      return node;\r\n    }\r\n\r\n    estreeParseLiteral(value: any): N.Node {\r\n      return this.parseLiteral(value, \"Literal\");\r\n    }\r\n\r\n    directiveToStmt(directive: N.Directive): N.ExpressionStatement {\r\n      const directiveLiteral = directive.value;\r\n\r\n      const stmt = this.startNodeAt(directive.start, directive.loc.start);\r\n      const expression = this.startNodeAt(\r\n        directiveLiteral.start,\r\n        directiveLiteral.loc.start,\r\n      );\r\n\r\n      expression.value = directiveLiteral.value;\r\n      expression.raw = directiveLiteral.extra.raw;\r\n\r\n      stmt.expression = this.finishNodeAt(\r\n        expression,\r\n        \"Literal\",\r\n        directiveLiteral.end,\r\n        directiveLiteral.loc.end,\r\n      );\r\n      stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\r\n\r\n      return this.finishNodeAt(\r\n        stmt,\r\n        \"ExpressionStatement\",\r\n        directive.end,\r\n        directive.loc.end,\r\n      );\r\n    }\r\n\r\n    // ==================================\r\n    // Overrides\r\n    // ==================================\r\n\r\n    initFunction(\r\n      node: N.BodilessFunctionOrMethodBase,\r\n      isAsync: ?boolean,\r\n    ): void {\r\n      super.initFunction(node, isAsync);\r\n      node.expression = false;\r\n    }\r\n\r\n    checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\r\n      if (isSimpleProperty(node)) {\r\n        this.checkDeclaration(((node: any): N.EstreeProperty).value);\r\n      } else {\r\n        super.checkDeclaration(node);\r\n      }\r\n    }\r\n\r\n    checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\r\n      const prop = ((method: any): N.EstreeProperty | N.EstreeMethodDefinition);\r\n      const paramCount = prop.kind === \"get\" ? 0 : 1;\r\n      const start = prop.start;\r\n      if (prop.value.params.length !== paramCount) {\r\n        if (prop.kind === \"get\") {\r\n          this.raise(start, \"getter must not have any formal parameters\");\r\n        } else {\r\n          this.raise(start, \"setter must have exactly one formal parameter\");\r\n        }\r\n      }\r\n\r\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\r\n        this.raise(\r\n          start,\r\n          \"setter function argument must not be a rest parameter\",\r\n        );\r\n      }\r\n    }\r\n\r\n    checkLVal(\r\n      expr: N.Expression,\r\n      bindingType: BindingTypes = BIND_NONE,\r\n      checkClashes: ?{ [key: string]: boolean },\r\n      contextDescription: string,\r\n    ): void {\r\n      switch (expr.type) {\r\n        case \"ObjectPattern\":\r\n          expr.properties.forEach(prop => {\r\n            this.checkLVal(\r\n              prop.type === \"Property\" ? prop.value : prop,\r\n              bindingType,\r\n              checkClashes,\r\n              \"object destructuring pattern\",\r\n            );\r\n          });\r\n          break;\r\n        default:\r\n          super.checkLVal(expr, bindingType, checkClashes, contextDescription);\r\n      }\r\n    }\r\n\r\n    checkPropClash(\r\n      prop: N.ObjectMember | N.SpreadElement,\r\n      propHash: { [key: string]: boolean },\r\n    ): void {\r\n      if (\r\n        prop.type === \"SpreadElement\" ||\r\n        prop.computed ||\r\n        prop.method ||\r\n        // $FlowIgnore\r\n        prop.shorthand\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      const key = prop.key;\r\n      // It is either an Identifier or a String/NumericLiteral\r\n      const name = key.type === \"Identifier\" ? key.name : String(key.value);\r\n\r\n      if (name === \"__proto__\" && prop.kind === \"init\") {\r\n        if (propHash.proto) {\r\n          this.raise(key.start, \"Redefinition of __proto__ property\");\r\n        }\r\n        propHash.proto = true;\r\n      }\r\n    }\r\n\r\n    isStrictBody(node: { body: N.BlockStatement }): boolean {\r\n      const isBlockStatement = node.body.type === \"BlockStatement\";\r\n\r\n      if (isBlockStatement && node.body.body.length > 0) {\r\n        for (const directive of node.body.body) {\r\n          if (\r\n            directive.type === \"ExpressionStatement\" &&\r\n            directive.expression.type === \"Literal\"\r\n          ) {\r\n            if (directive.expression.value === \"use strict\") return true;\r\n          } else {\r\n            // Break for the first non literal expression\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    isValidDirective(stmt: N.Statement): boolean {\r\n      return (\r\n        stmt.type === \"ExpressionStatement\" &&\r\n        stmt.expression.type === \"Literal\" &&\r\n        typeof stmt.expression.value === \"string\" &&\r\n        (!stmt.expression.extra || !stmt.expression.extra.parenthesized)\r\n      );\r\n    }\r\n\r\n    stmtToDirective(stmt: N.Statement): N.Directive {\r\n      const directive = super.stmtToDirective(stmt);\r\n      const value = stmt.expression.value;\r\n\r\n      // Reset value to the actual value as in estree mode we want\r\n      // the stmt to have the real value and not the raw value\r\n      directive.value.value = value;\r\n\r\n      return directive;\r\n    }\r\n\r\n    parseBlockBody(\r\n      node: N.BlockStatementLike,\r\n      allowDirectives: ?boolean,\r\n      topLevel: boolean,\r\n      end: TokenType,\r\n    ): void {\r\n      super.parseBlockBody(node, allowDirectives, topLevel, end);\r\n\r\n      const directiveStatements = node.directives.map(d =>\r\n        this.directiveToStmt(d),\r\n      );\r\n      node.body = directiveStatements.concat(node.body);\r\n      delete node.directives;\r\n    }\r\n\r\n    pushClassMethod(\r\n      classBody: N.ClassBody,\r\n      method: N.ClassMethod,\r\n      isGenerator: boolean,\r\n      isAsync: boolean,\r\n      isConstructor: boolean,\r\n      allowsDirectSuper: boolean,\r\n    ): void {\r\n      this.parseMethod(\r\n        method,\r\n        isGenerator,\r\n        isAsync,\r\n        isConstructor,\r\n        allowsDirectSuper,\r\n        \"ClassMethod\",\r\n        true,\r\n      );\r\n      if (method.typeParameters) {\r\n        // $FlowIgnore\r\n        method.value.typeParameters = method.typeParameters;\r\n        delete method.typeParameters;\r\n      }\r\n      classBody.body.push(method);\r\n    }\r\n\r\n    parseExprAtom(refShorthandDefaultPos?: ?Pos): N.Expression {\r\n      switch (this.state.type) {\r\n        case tt.regexp:\r\n          return this.estreeParseRegExpLiteral(this.state.value);\r\n\r\n        case tt.num:\r\n        case tt.string:\r\n          return this.estreeParseLiteral(this.state.value);\r\n\r\n        case tt._null:\r\n          return this.estreeParseLiteral(null);\r\n\r\n        case tt._true:\r\n          return this.estreeParseLiteral(true);\r\n\r\n        case tt._false:\r\n          return this.estreeParseLiteral(false);\r\n\r\n        default:\r\n          return super.parseExprAtom(refShorthandDefaultPos);\r\n      }\r\n    }\r\n\r\n    parseLiteral<T: N.Literal>(\r\n      value: any,\r\n      type: /*T[\"kind\"]*/ string,\r\n      startPos?: number,\r\n      startLoc?: Position,\r\n    ): T {\r\n      const node = super.parseLiteral(value, type, startPos, startLoc);\r\n      node.raw = node.extra.raw;\r\n      delete node.extra;\r\n\r\n      return node;\r\n    }\r\n\r\n    parseFunctionBody(\r\n      node: N.Function,\r\n      allowExpression: ?boolean,\r\n      isMethod?: boolean = false,\r\n    ): void {\r\n      super.parseFunctionBody(node, allowExpression, isMethod);\r\n      node.expression = node.body.type !== \"BlockStatement\";\r\n    }\r\n\r\n    parseMethod<T: N.MethodLike>(\r\n      node: T,\r\n      isGenerator: boolean,\r\n      isAsync: boolean,\r\n      isConstructor: boolean,\r\n      allowDirectSuper: boolean,\r\n      type: string,\r\n      inClassScope: boolean = false,\r\n    ): T {\r\n      let funcNode = this.startNode();\r\n      funcNode.kind = node.kind; // provide kind, so super method correctly sets state\r\n      funcNode = super.parseMethod(\r\n        funcNode,\r\n        isGenerator,\r\n        isAsync,\r\n        isConstructor,\r\n        allowDirectSuper,\r\n        type,\r\n        inClassScope,\r\n      );\r\n      funcNode.type = \"FunctionExpression\";\r\n      delete funcNode.kind;\r\n      // $FlowIgnore\r\n      node.value = funcNode;\r\n\r\n      type = type === \"ClassMethod\" ? \"MethodDefinition\" : type;\r\n      return this.finishNode(node, type);\r\n    }\r\n\r\n    parseObjectMethod(\r\n      prop: N.ObjectMethod,\r\n      isGenerator: boolean,\r\n      isAsync: boolean,\r\n      isPattern: boolean,\r\n      containsEsc: boolean,\r\n    ): ?N.ObjectMethod {\r\n      const node: N.EstreeProperty = (super.parseObjectMethod(\r\n        prop,\r\n        isGenerator,\r\n        isAsync,\r\n        isPattern,\r\n        containsEsc,\r\n      ): any);\r\n\r\n      if (node) {\r\n        node.type = \"Property\";\r\n        if (((node: any): N.ClassMethod).kind === \"method\") node.kind = \"init\";\r\n        node.shorthand = false;\r\n      }\r\n\r\n      return (node: any);\r\n    }\r\n\r\n    parseObjectProperty(\r\n      prop: N.ObjectProperty,\r\n      startPos: ?number,\r\n      startLoc: ?Position,\r\n      isPattern: boolean,\r\n      refShorthandDefaultPos: ?Pos,\r\n    ): ?N.ObjectProperty {\r\n      const node: N.EstreeProperty = (super.parseObjectProperty(\r\n        prop,\r\n        startPos,\r\n        startLoc,\r\n        isPattern,\r\n        refShorthandDefaultPos,\r\n      ): any);\r\n\r\n      if (node) {\r\n        node.kind = \"init\";\r\n        node.type = \"Property\";\r\n      }\r\n\r\n      return (node: any);\r\n    }\r\n\r\n    toAssignable(\r\n      node: N.Node,\r\n      isBinding: ?boolean,\r\n      contextDescription: string,\r\n    ): N.Node {\r\n      if (isSimpleProperty(node)) {\r\n        this.toAssignable(node.value, isBinding, contextDescription);\r\n\r\n        return node;\r\n      }\r\n\r\n      return super.toAssignable(node, isBinding, contextDescription);\r\n    }\r\n\r\n    toAssignableObjectExpressionProp(\r\n      prop: N.Node,\r\n      isBinding: ?boolean,\r\n      isLast: boolean,\r\n    ) {\r\n      if (prop.kind === \"get\" || prop.kind === \"set\") {\r\n        this.raise(\r\n          prop.key.start,\r\n          \"Object pattern can't contain getter or setter\",\r\n        );\r\n      } else if (prop.method) {\r\n        this.raise(prop.key.start, \"Object pattern can't contain methods\");\r\n      } else {\r\n        super.toAssignableObjectExpressionProp(prop, isBinding, isLast);\r\n      }\r\n    }\r\n  };\r\n","export var backSpace = 8;\nexport var tab = 9;\nexport var lineFeed = 10;\nexport var carriageReturn = 13;\nexport var shiftOut = 14;\nexport var space = 32;\nexport var exclamationMark = 33;\nexport var quotationMark = 34;\nexport var numberSign = 35;\nexport var dollarSign = 36;\nexport var percentSign = 37;\nexport var ampersand = 38;\nexport var apostrophe = 39;\nexport var leftParenthesis = 40;\nexport var rightParenthesis = 41;\nexport var asterisk = 42;\nexport var plusSign = 43;\nexport var comma = 44;\nexport var dash = 45;\nexport var dot = 46;\nexport var slash = 47;\nexport var digit0 = 48;\nexport var digit1 = 49;\nexport var digit2 = 50;\nexport var digit3 = 51;\nexport var digit4 = 52;\nexport var digit5 = 53;\nexport var digit6 = 54;\nexport var digit7 = 55;\nexport var digit8 = 56;\nexport var digit9 = 57;\nexport var colon = 58;\nexport var semicolon = 59;\nexport var lessThan = 60;\nexport var equalsTo = 61;\nexport var greaterThan = 62;\nexport var questionMark = 63;\nexport var atSign = 64;\nexport var uppercaseA = 65;\nexport var uppercaseB = 66;\nexport var uppercaseC = 67;\nexport var uppercaseD = 68;\nexport var uppercaseE = 69;\nexport var uppercaseF = 70;\nexport var uppercaseG = 71;\nexport var uppercaseH = 72;\nexport var uppercaseI = 73;\nexport var uppercaseJ = 74;\nexport var uppercaseK = 75;\nexport var uppercaseL = 76;\nexport var uppercaseM = 77;\nexport var uppercaseN = 78;\nexport var uppercaseO = 79;\nexport var uppercaseP = 80;\nexport var uppercaseQ = 81;\nexport var uppercaseR = 82;\nexport var uppercaseS = 83;\nexport var uppercaseT = 84;\nexport var uppercaseU = 85;\nexport var uppercaseV = 86;\nexport var uppercaseW = 87;\nexport var uppercaseX = 88;\nexport var uppercaseY = 89;\nexport var uppercaseZ = 90;\nexport var leftSquareBracket = 91;\nexport var backslash = 92;\nexport var rightSquareBracket = 93;\nexport var caret = 94;\nexport var underscore = 95;\nexport var graveAccent = 96;\nexport var lowercaseA = 97;\nexport var lowercaseB = 98;\nexport var lowercaseC = 99;\nexport var lowercaseD = 100;\nexport var lowercaseE = 101;\nexport var lowercaseF = 102;\nexport var lowercaseG = 103;\nexport var lowercaseH = 104;\nexport var lowercaseI = 105;\nexport var lowercaseJ = 106;\nexport var lowercaseK = 107;\nexport var lowercaseL = 108;\nexport var lowercaseM = 109;\nexport var lowercaseN = 110;\nexport var lowercaseO = 111;\nexport var lowercaseP = 112;\nexport var lowercaseQ = 113;\nexport var lowercaseR = 114;\nexport var lowercaseS = 115;\nexport var lowercaseT = 116;\nexport var lowercaseU = 117;\nexport var lowercaseV = 118;\nexport var lowercaseW = 119;\nexport var lowercaseX = 120;\nexport var lowercaseY = 121;\nexport var lowercaseZ = 122;\nexport var leftCurlyBrace = 123;\nexport var verticalBar = 124;\nexport var rightCurlyBrace = 125;\nexport var tilde = 126;\nexport var nonBreakingSpace = 160;\nexport var oghamSpaceMark = 5760;\nexport var lineSeparator = 8232;\nexport var paragraphSeparator = 8233;\nexport function isDigit(code) {\n  return code >= digit0 && code <= digit9;\n}\n","// @flow\r\n\r\nimport * as charCodes from \"charcodes\";\r\n\r\n// Matches a whole line break (where CRLF is considered a single\r\n// line break). Used to count lines.\r\nexport const lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\r\nexport const lineBreakG = new RegExp(lineBreak.source, \"g\");\r\n\r\n// https://tc39.github.io/ecma262/#sec-line-terminators\r\nexport function isNewLine(code: number): boolean {\r\n  switch (code) {\r\n    case charCodes.lineFeed:\r\n    case charCodes.carriageReturn:\r\n    case charCodes.lineSeparator:\r\n    case charCodes.paragraphSeparator:\r\n      return true;\r\n\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\nexport const skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\r\n\r\n// https://tc39.github.io/ecma262/#sec-white-space\r\nexport function isWhitespace(code: number): boolean {\r\n  switch (code) {\r\n    case 0x0009: // CHARACTER TABULATION\r\n    case 0x000b: // LINE TABULATION\r\n    case 0x000c: // FORM FEED\r\n    case charCodes.space:\r\n    case charCodes.nonBreakingSpace:\r\n    case charCodes.oghamSpaceMark:\r\n    case 0x2000: // EN QUAD\r\n    case 0x2001: // EM QUAD\r\n    case 0x2002: // EN SPACE\r\n    case 0x2003: // EM SPACE\r\n    case 0x2004: // THREE-PER-EM SPACE\r\n    case 0x2005: // FOUR-PER-EM SPACE\r\n    case 0x2006: // SIX-PER-EM SPACE\r\n    case 0x2007: // FIGURE SPACE\r\n    case 0x2008: // PUNCTUATION SPACE\r\n    case 0x2009: // THIN SPACE\r\n    case 0x200a: // HAIR SPACE\r\n    case 0x202f: // NARROW NO-BREAK SPACE\r\n    case 0x205f: // MEDIUM MATHEMATICAL SPACE\r\n    case 0x3000: // IDEOGRAPHIC SPACE\r\n    case 0xfeff: // ZERO WIDTH NO-BREAK SPACE\r\n      return true;\r\n\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n","// @flow\r\n\r\n// The algorithm used to determine whether a regexp can appear at a\r\n// given point in the program is loosely based on sweet.js' approach.\r\n// See https://github.com/mozilla/sweet.js/wiki/design\r\n\r\nimport { types as tt } from \"./types\";\r\nimport { lineBreak } from \"../util/whitespace\";\r\n\r\nexport class TokContext {\r\n  constructor(\r\n    token: string,\r\n    isExpr?: boolean,\r\n    preserveSpace?: boolean,\r\n    override?: ?Function, // Takes a Tokenizer as a this-parameter, and returns void.\r\n  ) {\r\n    this.token = token;\r\n    this.isExpr = !!isExpr;\r\n    this.preserveSpace = !!preserveSpace;\r\n    this.override = override;\r\n  }\r\n\r\n  token: string;\r\n  isExpr: boolean;\r\n  preserveSpace: boolean;\r\n  override: ?Function;\r\n}\r\n\r\nexport const types: {\r\n  [key: string]: TokContext,\r\n} = {\r\n  braceStatement: new TokContext(\"{\", false),\r\n  braceExpression: new TokContext(\"{\", true),\r\n  templateQuasi: new TokContext(\"${\", false),\r\n  parenStatement: new TokContext(\"(\", false),\r\n  parenExpression: new TokContext(\"(\", true),\r\n  template: new TokContext(\"`\", true, true, p => p.readTmplToken()),\r\n  functionExpression: new TokContext(\"مهمة\", true),\r\n  functionStatement: new TokContext(\"مهمة\", false),\r\n};\r\n\r\n// Token-specific context update code\r\n\r\ntt.parenR.updateContext = tt.braceR.updateContext = function() {\r\n  if (this.state.context.length === 1) {\r\n    this.state.exprAllowed = true;\r\n    return;\r\n  }\r\n\r\n  let out = this.state.context.pop();\r\n  if (out === types.braceStatement && this.curContext().token === \"مهمة\") {\r\n    out = this.state.context.pop();\r\n  }\r\n\r\n  this.state.exprAllowed = !out.isExpr;\r\n};\r\n\r\ntt.name.updateContext = function(prevType) {\r\n  let allowed = false;\r\n  if (prevType !== tt.dot) {\r\n    if (\r\n      (this.state.value === \"of\" && !this.state.exprAllowed) ||\r\n      (this.state.value === \"yield\" && this.scope.inGenerator)\r\n    ) {\r\n      allowed = true;\r\n    }\r\n  }\r\n  this.state.exprAllowed = allowed;\r\n\r\n  if (this.state.isIterator) {\r\n    this.state.isIterator = false;\r\n  }\r\n};\r\n\r\ntt.braceL.updateContext = function(prevType) {\r\n  this.state.context.push(\r\n    this.braceIsBlock(prevType) ? types.braceStatement : types.braceExpression,\r\n  );\r\n  this.state.exprAllowed = true;\r\n};\r\n\r\ntt.dollarBraceL.updateContext = function() {\r\n  this.state.context.push(types.templateQuasi);\r\n  this.state.exprAllowed = true;\r\n};\r\n\r\ntt.parenL.updateContext = function(prevType) {\r\n  const statementParens =\r\n    prevType === tt._if ||\r\n    prevType === tt._for ||\r\n    prevType === tt._with ||\r\n    prevType === tt._while;\r\n  this.state.context.push(\r\n    statementParens ? types.parenStatement : types.parenExpression,\r\n  );\r\n  this.state.exprAllowed = true;\r\n};\r\n\r\ntt.incDec.updateContext = function() {\r\n  // tokExprAllowed stays unchanged\r\n};\r\n\r\ntt._function.updateContext = tt._class.updateContext = function(prevType) {\r\n  if (\r\n    prevType.beforeExpr &&\r\n    prevType !== tt.semi &&\r\n    prevType !== tt._else &&\r\n    !(\r\n      prevType === tt._return &&\r\n      lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))\r\n    ) &&\r\n    !(\r\n      (prevType === tt.colon || prevType === tt.braceL) &&\r\n      this.curContext() === types.b_stat\r\n    )\r\n  ) {\r\n    this.state.context.push(types.functionExpression);\r\n  } else {\r\n    this.state.context.push(types.functionStatement);\r\n  }\r\n\r\n  this.state.exprAllowed = false;\r\n};\r\n\r\ntt.backQuote.updateContext = function() {\r\n  if (this.curContext() === types.template) {\r\n    this.state.context.pop();\r\n  } else {\r\n    this.state.context.push(types.template);\r\n  }\r\n  this.state.exprAllowed = false;\r\n};\r\n","/* eslint max-len: 0 */\r\n\r\n// @flow\r\n\r\nimport * as charCodes from \"charcodes\";\r\nimport { keywords } from \"../tokenizer/types\";\r\n\r\nconst reservedWords = {\r\n  strict: [\r\n    \"implements\",\r\n    \"interface\",\r\n    \"let\",\r\n    \"package\",\r\n    \"private\",\r\n    \"protected\",\r\n    \"public\",\r\n    \"static\",\r\n    \"yield\",\r\n  ],\r\n  strictBind: [\"eval\", \"arguments\"],\r\n};\r\n\r\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\r\nconst reservedWordsStrictBindSet = new Set(\r\n  reservedWords.strict.concat(reservedWords.strictBind),\r\n);\r\n\r\n/**\r\n * Checks if word is a reserved word in non-strict mode\r\n */\r\nexport const isReservedWord = (word: string, inModule: boolean): boolean => {\r\n  return (inModule && word === \"انتظر\") || word === \"enum\";\r\n};\r\n\r\n/**\r\n * Checks if word is a reserved word in non-binding strict mode\r\n *\r\n * Includes non-strict reserved words\r\n */\r\nexport function isStrictReservedWord(word: string, inModule: boolean): boolean {\r\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\r\n}\r\n\r\n/**\r\n * Checks if word is a reserved word in binding strict mode\r\n *\r\n * Includes non-strict reserved words and non-binding strict reserved words\r\n */\r\nexport function isStrictBindReservedWord(\r\n  word: string,\r\n  inModule: boolean,\r\n): boolean {\r\n  return isReservedWord(word, inModule) || reservedWordsStrictBindSet.has(word);\r\n}\r\n\r\nexport function isKeyword(word: string): boolean {\r\n  return keywords.has(word);\r\n}\r\n\r\nexport const keywordRelationalOperator = /^in(stanceof)?$/;\r\n\r\n// ## Character categories\r\n\r\n// Big ugly regular expressions that match characters in the\r\n// whitespace, identifier, and identifier-start categories. These\r\n// are only applied when a character is found to actually have a\r\n// code point above 0x80.\r\n// Generated by `scripts/generate-identifier-regex.js`.\r\n\r\n/* prettier-ignore */\r\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\r\n/* prettier-ignore */\r\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\r\n\r\nconst nonASCIIidentifierStart = new RegExp(\r\n  \"[\" + nonASCIIidentifierStartChars + \"]\",\r\n);\r\nconst nonASCIIidentifier = new RegExp(\r\n  \"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\",\r\n);\r\n\r\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\r\n\r\n// These are a run-length and offset-encoded representation of the\r\n// >0xffff code points that are a valid part of identifiers. The\r\n// offset starts at 0x10000, and each pair of numbers represents an\r\n// offset to the next range, and then a size of the range. They were\r\n// generated by `scripts/generate-identifier-regex.js`.\r\n/* prettier-ignore */\r\nconst astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\r\n/* prettier-ignore */\r\nconst astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];\r\n\r\n// This has a complexity linear to the value of the code. The\r\n// assumption is that looking up astral identifier characters is\r\n// rare.\r\nfunction isInAstralSet(code: number, set: $ReadOnlyArray<number>): boolean {\r\n  let pos = 0x10000;\r\n  for (let i = 0, length = set.length; i < length; i += 2) {\r\n    pos += set[i];\r\n    if (pos > code) return false;\r\n\r\n    pos += set[i + 1];\r\n    if (pos >= code) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n// Test whether a given character code starts an identifier.\r\n\r\nexport function isIdentifierStart(code: number): boolean {\r\n  if (code < charCodes.uppercaseA) return code === charCodes.dollarSign;\r\n  if (code <= charCodes.uppercaseZ) return true;\r\n  if (code < charCodes.lowercaseA) return code === charCodes.underscore;\r\n  if (code <= charCodes.lowercaseZ) return true;\r\n  if (code <= 0xffff) {\r\n    return (\r\n      code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\r\n    );\r\n  }\r\n  return isInAstralSet(code, astralIdentifierStartCodes);\r\n}\r\n\r\n// Test whether a current state character code and next character code is @\r\n\r\nexport function isIteratorStart(current: number, next: number): boolean {\r\n  return current === charCodes.atSign && next === charCodes.atSign;\r\n}\r\n\r\n// Test whether a given character is part of an identifier.\r\n\r\nexport function isIdentifierChar(code: number): boolean {\r\n  if (code < charCodes.digit0) return code === charCodes.dollarSign;\r\n  if (code < charCodes.colon) return true;\r\n  if (code < charCodes.uppercaseA) return false;\r\n  if (code <= charCodes.uppercaseZ) return true;\r\n  if (code < charCodes.lowercaseA) return code === charCodes.underscore;\r\n  if (code <= charCodes.lowercaseZ) return true;\r\n  if (code <= 0xffff) {\r\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\r\n  }\r\n  return (\r\n    isInAstralSet(code, astralIdentifierStartCodes) ||\r\n    isInAstralSet(code, astralIdentifierCodes)\r\n  );\r\n}\r\n","// @flow\r\n\r\nimport type Parser from \"../parser\";\r\nimport { types as tt, type TokenType } from \"../tokenizer/types\";\r\nimport * as N from \"../types\";\r\nimport type { Options } from \"../options\";\r\nimport type { Pos, Position } from \"../util/location\";\r\nimport type State from \"../tokenizer/state\";\r\nimport { types as tc } from \"../tokenizer/context\";\r\nimport * as charCodes from \"charcodes\";\r\nimport { isIteratorStart } from \"../util/identifier\";\r\nimport {\r\n  functionFlags,\r\n  type BindingTypes,\r\n  BIND_NONE,\r\n  BIND_LEXICAL,\r\n  SCOPE_ARROW,\r\n  SCOPE_OTHER,\r\n} from \"../util/scopeflags\";\r\n\r\nconst reservedTypes = [\r\n  \"any\",\r\n  \"bool\",\r\n  \"boolean\",\r\n  \"empty\",\r\n  \"false\",\r\n  \"mixed\",\r\n  \"null\",\r\n  \"number\",\r\n  \"static\",\r\n  \"string\",\r\n  \"true\",\r\n  \"typeof\",\r\n  \"void\",\r\n  \"interface\",\r\n  \"extends\",\r\n  \"_\",\r\n];\r\n\r\nfunction isEsModuleType(bodyElement: N.Node): boolean {\r\n  return (\r\n    bodyElement.type === \"DeclareExportAllDeclaration\" ||\r\n    (bodyElement.type === \"DeclareExportDeclaration\" &&\r\n      (!bodyElement.declaration ||\r\n        (bodyElement.declaration.type !== \"TypeAlias\" &&\r\n          bodyElement.declaration.type !== \"InterfaceDeclaration\")))\r\n  );\r\n}\r\n\r\nfunction hasTypeImportKind(node: N.Node): boolean {\r\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\r\n}\r\n\r\nfunction isMaybeDefaultImport(state: State): boolean {\r\n  return (\r\n    (state.type === tt.name || !!state.type.keyword) && state.value !== \"from\"\r\n  );\r\n}\r\n\r\nconst exportSuggestions = {\r\n  const: \"declare export var\",\r\n  let: \"declare export var\",\r\n  type: \"export type\",\r\n  interface: \"export interface\",\r\n};\r\n\r\n// Like Array#filter, but returns a tuple [ acceptedElements, discardedElements ]\r\nfunction partition<T>(\r\n  list: T[],\r\n  test: (T, number, T[]) => ?boolean,\r\n): [T[], T[]] {\r\n  const list1 = [];\r\n  const list2 = [];\r\n  for (let i = 0; i < list.length; i++) {\r\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\r\n  }\r\n  return [list1, list2];\r\n}\r\n\r\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\r\n\r\nexport default (superClass: Class<Parser>): Class<Parser> =>\r\n  class extends superClass {\r\n    // The value of the @flow/@noflow pragma. Initially undefined, transitions\r\n    // to \"@flow\" or \"@noflow\" if we see a pragma. Transitions to null if we are\r\n    // past the initial comment.\r\n    flowPragma: void | null | \"flow\" | \"noflow\";\r\n\r\n    constructor(options: ?Options, input: string) {\r\n      super(options, input);\r\n      this.flowPragma = undefined;\r\n    }\r\n\r\n    shouldParseTypes(): boolean {\r\n      return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\r\n    }\r\n\r\n    finishToken(type: TokenType, val: any): void {\r\n      if (\r\n        type !== tt.string &&\r\n        type !== tt.semi &&\r\n        type !== tt.interpreterDirective\r\n      ) {\r\n        if (this.flowPragma === undefined) {\r\n          this.flowPragma = null;\r\n        }\r\n      }\r\n      return super.finishToken(type, val);\r\n    }\r\n\r\n    addComment(comment: N.Comment): void {\r\n      if (this.flowPragma === undefined) {\r\n        // Try to parse a flow pragma.\r\n        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\r\n        if (!matches) {\r\n          // do nothing\r\n        } else if (matches[1] === \"flow\") {\r\n          this.flowPragma = \"flow\";\r\n        } else if (matches[1] === \"noflow\") {\r\n          this.flowPragma = \"noflow\";\r\n        } else {\r\n          throw new Error(\"Unexpected flow pragma\");\r\n        }\r\n      }\r\n      return super.addComment(comment);\r\n    }\r\n\r\n    flowParseTypeInitialiser(tok?: TokenType): N.FlowType {\r\n      const oldInType = this.state.inType;\r\n      this.state.inType = true;\r\n      this.expect(tok || tt.colon);\r\n\r\n      const type = this.flowParseType();\r\n      this.state.inType = oldInType;\r\n      return type;\r\n    }\r\n\r\n    flowParsePredicate(): N.FlowType {\r\n      const node = this.startNode();\r\n      const moduloLoc = this.state.startLoc;\r\n      const moduloPos = this.state.start;\r\n      this.expect(tt.modulo);\r\n      const checksLoc = this.state.startLoc;\r\n      this.expectContextual(\"checks\");\r\n      // Force '%' and 'checks' to be adjacent\r\n      if (\r\n        moduloLoc.line !== checksLoc.line ||\r\n        moduloLoc.column !== checksLoc.column - 1\r\n      ) {\r\n        this.raise(\r\n          moduloPos,\r\n          \"Spaces between ´%´ and ´checks´ are not allowed here.\",\r\n        );\r\n      }\r\n      if (this.eat(tt.parenL)) {\r\n        node.value = this.parseExpression();\r\n        this.expect(tt.parenR);\r\n        return this.finishNode(node, \"DeclaredPredicate\");\r\n      } else {\r\n        return this.finishNode(node, \"InferredPredicate\");\r\n      }\r\n    }\r\n\r\n    flowParseTypeAndPredicateInitialiser(): [?N.FlowType, ?N.FlowPredicate] {\r\n      const oldInType = this.state.inType;\r\n      this.state.inType = true;\r\n      this.expect(tt.colon);\r\n      let type = null;\r\n      let predicate = null;\r\n      if (this.match(tt.modulo)) {\r\n        this.state.inType = oldInType;\r\n        predicate = this.flowParsePredicate();\r\n      } else {\r\n        type = this.flowParseType();\r\n        this.state.inType = oldInType;\r\n        if (this.match(tt.modulo)) {\r\n          predicate = this.flowParsePredicate();\r\n        }\r\n      }\r\n      return [type, predicate];\r\n    }\r\n\r\n    flowParseDeclareClass(node: N.FlowDeclareClass): N.FlowDeclareClass {\r\n      this.next();\r\n      this.flowParseInterfaceish(node, /*isClass*/ true);\r\n      return this.finishNode(node, \"DeclareClass\");\r\n    }\r\n\r\n    flowParseDeclareFunction(\r\n      node: N.FlowDeclareFunction,\r\n    ): N.FlowDeclareFunction {\r\n      this.next();\r\n\r\n      const id = (node.id = this.parseIdentifier());\r\n\r\n      const typeNode = this.startNode();\r\n      const typeContainer = this.startNode();\r\n\r\n      if (this.isRelational(\"<\")) {\r\n        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\r\n      } else {\r\n        typeNode.typeParameters = null;\r\n      }\r\n\r\n      this.expect(tt.parenL);\r\n      const tmp = this.flowParseFunctionTypeParams();\r\n      typeNode.params = tmp.params;\r\n      typeNode.rest = tmp.rest;\r\n      this.expect(tt.parenR);\r\n\r\n      [\r\n        // $FlowFixMe (destructuring not supported yet)\r\n        typeNode.returnType,\r\n        // $FlowFixMe (destructuring not supported yet)\r\n        node.predicate,\r\n      ] = this.flowParseTypeAndPredicateInitialiser();\r\n\r\n      typeContainer.typeAnnotation = this.finishNode(\r\n        typeNode,\r\n        \"FunctionTypeAnnotation\",\r\n      );\r\n\r\n      id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\r\n\r\n      this.resetEndLocation(id);\r\n      this.semicolon();\r\n\r\n      return this.finishNode(node, \"DeclareFunction\");\r\n    }\r\n\r\n    flowParseDeclare(\r\n      node: N.FlowDeclare,\r\n      insideModule?: boolean,\r\n    ): N.FlowDeclare {\r\n      if (this.match(tt._class)) {\r\n        return this.flowParseDeclareClass(node);\r\n      } else if (this.match(tt._function)) {\r\n        return this.flowParseDeclareFunction(node);\r\n      } else if (this.match(tt._var)) {\r\n        return this.flowParseDeclareVariable(node);\r\n      } else if (this.eatContextual(\"module\")) {\r\n        if (this.match(tt.dot)) {\r\n          return this.flowParseDeclareModuleExports(node);\r\n        } else {\r\n          if (insideModule) {\r\n            this.unexpected(\r\n              this.state.lastTokStart,\r\n              \"`declare module` cannot be used inside another `declare module`\",\r\n            );\r\n          }\r\n          return this.flowParseDeclareModule(node);\r\n        }\r\n      } else if (this.isContextual(\"type\")) {\r\n        return this.flowParseDeclareTypeAlias(node);\r\n      } else if (this.isContextual(\"opaque\")) {\r\n        return this.flowParseDeclareOpaqueType(node);\r\n      } else if (this.isContextual(\"interface\")) {\r\n        return this.flowParseDeclareInterface(node);\r\n      } else if (this.match(tt._export)) {\r\n        return this.flowParseDeclareExportDeclaration(node, insideModule);\r\n      } else {\r\n        throw this.unexpected();\r\n      }\r\n    }\r\n\r\n    flowParseDeclareVariable(\r\n      node: N.FlowDeclareVariable,\r\n    ): N.FlowDeclareVariable {\r\n      this.next();\r\n      node.id = this.flowParseTypeAnnotatableIdentifier(\r\n        /*allowPrimitiveOverride*/ true,\r\n      );\r\n      this.semicolon();\r\n      return this.finishNode(node, \"DeclareVariable\");\r\n    }\r\n\r\n    flowParseDeclareModule(node: N.FlowDeclareModule): N.FlowDeclareModule {\r\n      this.scope.enter(SCOPE_OTHER);\r\n\r\n      if (this.match(tt.string)) {\r\n        node.id = this.parseExprAtom();\r\n      } else {\r\n        node.id = this.parseIdentifier();\r\n      }\r\n\r\n      const bodyNode = (node.body = this.startNode());\r\n      const body = (bodyNode.body = []);\r\n      this.expect(tt.braceL);\r\n      while (!this.match(tt.braceR)) {\r\n        let bodyNode = this.startNode();\r\n\r\n        if (this.match(tt._import)) {\r\n          this.next();\r\n          if (!this.isContextual(\"type\") && !this.isContextual(\"typeof\")) {\r\n            this.unexpected(\r\n              this.state.lastTokStart,\r\n              \"Imports within a `declare module` body must always be `import type` or `import typeof`\",\r\n            );\r\n          }\r\n          this.parseImport(bodyNode);\r\n        } else {\r\n          this.expectContextual(\r\n            \"declare\",\r\n            \"Only declares and type imports are allowed inside declare module\",\r\n          );\r\n\r\n          bodyNode = this.flowParseDeclare(bodyNode, true);\r\n        }\r\n\r\n        body.push(bodyNode);\r\n      }\r\n\r\n      this.scope.exit();\r\n\r\n      this.expect(tt.braceR);\r\n\r\n      this.finishNode(bodyNode, \"BlockStatement\");\r\n\r\n      let kind = null;\r\n      let hasModuleExport = false;\r\n      const errorMessage =\r\n        \"Found both `declare module.exports` and `declare export` in the same module. \" +\r\n        \"Modules can only have 1 since they are either an ES module or they are a CommonJS module\";\r\n      body.forEach(bodyElement => {\r\n        if (isEsModuleType(bodyElement)) {\r\n          if (kind === \"CommonJS\") {\r\n            this.unexpected(bodyElement.start, errorMessage);\r\n          }\r\n          kind = \"ES\";\r\n        } else if (bodyElement.type === \"DeclareModuleExports\") {\r\n          if (hasModuleExport) {\r\n            this.unexpected(\r\n              bodyElement.start,\r\n              \"Duplicate `declare module.exports` statement\",\r\n            );\r\n          }\r\n          if (kind === \"ES\") this.unexpected(bodyElement.start, errorMessage);\r\n          kind = \"CommonJS\";\r\n          hasModuleExport = true;\r\n        }\r\n      });\r\n\r\n      node.kind = kind || \"CommonJS\";\r\n      return this.finishNode(node, \"DeclareModule\");\r\n    }\r\n\r\n    flowParseDeclareExportDeclaration(\r\n      node: N.FlowDeclareExportDeclaration,\r\n      insideModule: ?boolean,\r\n    ): N.FlowDeclareExportDeclaration {\r\n      this.expect(tt._export);\r\n\r\n      if (this.eat(tt._default)) {\r\n        if (this.match(tt._function) || this.match(tt._class)) {\r\n          // declare export default class ...\r\n          // declare export default function ...\r\n          node.declaration = this.flowParseDeclare(this.startNode());\r\n        } else {\r\n          // declare export default [type];\r\n          node.declaration = this.flowParseType();\r\n          this.semicolon();\r\n        }\r\n        node.default = true;\r\n\r\n        return this.finishNode(node, \"DeclareExportDeclaration\");\r\n      } else {\r\n        if (\r\n          this.match(tt._const) ||\r\n          this.isLet() ||\r\n          ((this.isContextual(\"type\") || this.isContextual(\"interface\")) &&\r\n            !insideModule)\r\n        ) {\r\n          const label = this.state.value;\r\n          const suggestion = exportSuggestions[label];\r\n          this.unexpected(\r\n            this.state.start,\r\n            `\\`declare export ${label}\\` is not supported. Use \\`${suggestion}\\` instead`,\r\n          );\r\n        }\r\n\r\n        if (\r\n          this.match(tt._var) || // declare export var ...\r\n          this.match(tt._function) || // declare export function ...\r\n          this.match(tt._class) || // declare export class ...\r\n          this.isContextual(\"opaque\") // declare export opaque ..\r\n        ) {\r\n          node.declaration = this.flowParseDeclare(this.startNode());\r\n          node.default = false;\r\n\r\n          return this.finishNode(node, \"DeclareExportDeclaration\");\r\n        } else if (\r\n          this.match(tt.star) || // declare export * from ''\r\n          this.match(tt.braceL) || // declare export {} ...\r\n          this.isContextual(\"interface\") || // declare export interface ...\r\n          this.isContextual(\"type\") || // declare export type ...\r\n          this.isContextual(\"opaque\") // declare export opaque type ...\r\n        ) {\r\n          node = this.parseExport(node);\r\n          if (node.type === \"ExportNamedDeclaration\") {\r\n            // flow does not support the ExportNamedDeclaration\r\n            // $FlowIgnore\r\n            node.type = \"ExportDeclaration\";\r\n            // $FlowFixMe\r\n            node.default = false;\r\n            delete node.exportKind;\r\n          }\r\n\r\n          // $FlowIgnore\r\n          node.type = \"Declare\" + node.type;\r\n\r\n          return node;\r\n        }\r\n      }\r\n\r\n      throw this.unexpected();\r\n    }\r\n\r\n    flowParseDeclareModuleExports(\r\n      node: N.FlowDeclareModuleExports,\r\n    ): N.FlowDeclareModuleExports {\r\n      this.next();\r\n      this.expectContextual(\"exports\");\r\n      node.typeAnnotation = this.flowParseTypeAnnotation();\r\n      this.semicolon();\r\n\r\n      return this.finishNode(node, \"DeclareModuleExports\");\r\n    }\r\n\r\n    flowParseDeclareTypeAlias(\r\n      node: N.FlowDeclareTypeAlias,\r\n    ): N.FlowDeclareTypeAlias {\r\n      this.next();\r\n      this.flowParseTypeAlias(node);\r\n      // Don't do finishNode as we don't want to process comments twice\r\n      node.type = \"DeclareTypeAlias\";\r\n      return node;\r\n    }\r\n\r\n    flowParseDeclareOpaqueType(\r\n      node: N.FlowDeclareOpaqueType,\r\n    ): N.FlowDeclareOpaqueType {\r\n      this.next();\r\n      this.flowParseOpaqueType(node, true);\r\n      // Don't do finishNode as we don't want to process comments twice\r\n      node.type = \"DeclareOpaqueType\";\r\n      return node;\r\n    }\r\n\r\n    flowParseDeclareInterface(\r\n      node: N.FlowDeclareInterface,\r\n    ): N.FlowDeclareInterface {\r\n      this.next();\r\n      this.flowParseInterfaceish(node);\r\n      return this.finishNode(node, \"DeclareInterface\");\r\n    }\r\n\r\n    // Interfaces\r\n\r\n    flowParseInterfaceish(\r\n      node: N.FlowDeclare,\r\n      isClass?: boolean = false,\r\n    ): void {\r\n      node.id = this.flowParseRestrictedIdentifier(/*liberal*/ !isClass);\r\n\r\n      if (this.isRelational(\"<\")) {\r\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\r\n      } else {\r\n        node.typeParameters = null;\r\n      }\r\n\r\n      node.extends = [];\r\n      node.implements = [];\r\n      node.mixins = [];\r\n\r\n      if (this.eat(tt._extends)) {\r\n        do {\r\n          node.extends.push(this.flowParseInterfaceExtends());\r\n        } while (!isClass && this.eat(tt.comma));\r\n      }\r\n\r\n      if (this.isContextual(\"mixins\")) {\r\n        this.next();\r\n        do {\r\n          node.mixins.push(this.flowParseInterfaceExtends());\r\n        } while (this.eat(tt.comma));\r\n      }\r\n\r\n      if (this.isContextual(\"implements\")) {\r\n        this.next();\r\n        do {\r\n          node.implements.push(this.flowParseInterfaceExtends());\r\n        } while (this.eat(tt.comma));\r\n      }\r\n\r\n      node.body = this.flowParseObjectType({\r\n        allowStatic: isClass,\r\n        allowExact: false,\r\n        allowSpread: false,\r\n        allowProto: isClass,\r\n        allowInexact: false,\r\n      });\r\n    }\r\n\r\n    flowParseInterfaceExtends(): N.FlowInterfaceExtends {\r\n      const node = this.startNode();\r\n\r\n      node.id = this.flowParseQualifiedTypeIdentifier();\r\n      if (this.isRelational(\"<\")) {\r\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\r\n      } else {\r\n        node.typeParameters = null;\r\n      }\r\n\r\n      return this.finishNode(node, \"InterfaceExtends\");\r\n    }\r\n\r\n    flowParseInterface(node: N.FlowInterface): N.FlowInterface {\r\n      this.flowParseInterfaceish(node);\r\n      return this.finishNode(node, \"InterfaceDeclaration\");\r\n    }\r\n\r\n    checkNotUnderscore(word: string) {\r\n      if (word === \"_\") {\r\n        throw this.unexpected(\r\n          null,\r\n          \"`_` is only allowed as a type argument to call or new\",\r\n        );\r\n      }\r\n    }\r\n\r\n    checkReservedType(word: string, startLoc: number) {\r\n      if (reservedTypes.indexOf(word) > -1) {\r\n        this.raise(startLoc, `Cannot overwrite reserved type ${word}`);\r\n      }\r\n    }\r\n\r\n    flowParseRestrictedIdentifier(liberal?: boolean): N.Identifier {\r\n      this.checkReservedType(this.state.value, this.state.start);\r\n      return this.parseIdentifier(liberal);\r\n    }\r\n\r\n    // Type aliases\r\n\r\n    flowParseTypeAlias(node: N.FlowTypeAlias): N.FlowTypeAlias {\r\n      node.id = this.flowParseRestrictedIdentifier();\r\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\r\n\r\n      if (this.isRelational(\"<\")) {\r\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\r\n      } else {\r\n        node.typeParameters = null;\r\n      }\r\n\r\n      node.right = this.flowParseTypeInitialiser(tt.eq);\r\n      this.semicolon();\r\n\r\n      return this.finishNode(node, \"TypeAlias\");\r\n    }\r\n\r\n    flowParseOpaqueType(\r\n      node: N.FlowOpaqueType,\r\n      declare: boolean,\r\n    ): N.FlowOpaqueType {\r\n      this.expectContextual(\"type\");\r\n      node.id = this.flowParseRestrictedIdentifier(/*liberal*/ true);\r\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\r\n\r\n      if (this.isRelational(\"<\")) {\r\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\r\n      } else {\r\n        node.typeParameters = null;\r\n      }\r\n\r\n      // Parse the supertype\r\n      node.supertype = null;\r\n      if (this.match(tt.colon)) {\r\n        node.supertype = this.flowParseTypeInitialiser(tt.colon);\r\n      }\r\n\r\n      node.impltype = null;\r\n      if (!declare) {\r\n        node.impltype = this.flowParseTypeInitialiser(tt.eq);\r\n      }\r\n      this.semicolon();\r\n\r\n      return this.finishNode(node, \"OpaqueType\");\r\n    }\r\n\r\n    // Type annotations\r\n\r\n    flowParseTypeParameter(\r\n      allowDefault?: boolean = true,\r\n      requireDefault?: boolean = false,\r\n    ): N.TypeParameter {\r\n      if (!allowDefault && requireDefault) {\r\n        throw new Error(\r\n          \"Cannot disallow a default value (`allowDefault`) while also requiring it (`requireDefault`).\",\r\n        );\r\n      }\r\n\r\n      const nodeStart = this.state.start;\r\n\r\n      const node = this.startNode();\r\n\r\n      const variance = this.flowParseVariance();\r\n\r\n      const ident = this.flowParseTypeAnnotatableIdentifier();\r\n      node.name = ident.name;\r\n      node.variance = variance;\r\n      node.bound = ident.typeAnnotation;\r\n\r\n      if (this.match(tt.eq)) {\r\n        if (allowDefault) {\r\n          this.eat(tt.eq);\r\n          node.default = this.flowParseType();\r\n        } else {\r\n          this.unexpected();\r\n        }\r\n      } else {\r\n        if (requireDefault) {\r\n          this.unexpected(\r\n            nodeStart,\r\n            // eslint-disable-next-line max-len\r\n            \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\r\n          );\r\n        }\r\n      }\r\n\r\n      return this.finishNode(node, \"TypeParameter\");\r\n    }\r\n\r\n    flowParseTypeParameterDeclaration(\r\n      allowDefault?: boolean = true,\r\n    ): N.TypeParameterDeclaration {\r\n      const oldInType = this.state.inType;\r\n      const node = this.startNode();\r\n      node.params = [];\r\n\r\n      this.state.inType = true;\r\n\r\n      // istanbul ignore else: this condition is already checked at all call sites\r\n      if (this.isRelational(\"<\") || this.match(tt.jsxTagStart)) {\r\n        this.next();\r\n      } else {\r\n        this.unexpected();\r\n      }\r\n\r\n      let defaultRequired = false;\r\n\r\n      do {\r\n        const typeParameter = this.flowParseTypeParameter(\r\n          allowDefault,\r\n          defaultRequired,\r\n        );\r\n\r\n        node.params.push(typeParameter);\r\n\r\n        if (typeParameter.default) {\r\n          defaultRequired = true;\r\n        }\r\n\r\n        if (!this.isRelational(\">\")) {\r\n          this.expect(tt.comma);\r\n        }\r\n      } while (!this.isRelational(\">\"));\r\n      this.expectRelational(\">\");\r\n\r\n      this.state.inType = oldInType;\r\n\r\n      return this.finishNode(node, \"TypeParameterDeclaration\");\r\n    }\r\n\r\n    flowParseTypeParameterInstantiation(): N.TypeParameterInstantiation {\r\n      const node = this.startNode();\r\n      const oldInType = this.state.inType;\r\n      node.params = [];\r\n\r\n      this.state.inType = true;\r\n\r\n      this.expectRelational(\"<\");\r\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\r\n      this.state.noAnonFunctionType = false;\r\n      while (!this.isRelational(\">\")) {\r\n        node.params.push(this.flowParseType());\r\n        if (!this.isRelational(\">\")) {\r\n          this.expect(tt.comma);\r\n        }\r\n      }\r\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\r\n      this.expectRelational(\">\");\r\n\r\n      this.state.inType = oldInType;\r\n\r\n      return this.finishNode(node, \"TypeParameterInstantiation\");\r\n    }\r\n\r\n    flowParseTypeParameterInstantiationCallOrNew(): N.TypeParameterInstantiation {\r\n      const node = this.startNode();\r\n      const oldInType = this.state.inType;\r\n      node.params = [];\r\n\r\n      this.state.inType = true;\r\n\r\n      this.expectRelational(\"<\");\r\n      while (!this.isRelational(\">\")) {\r\n        node.params.push(this.flowParseTypeOrImplicitInstantiation());\r\n        if (!this.isRelational(\">\")) {\r\n          this.expect(tt.comma);\r\n        }\r\n      }\r\n      this.expectRelational(\">\");\r\n\r\n      this.state.inType = oldInType;\r\n\r\n      return this.finishNode(node, \"TypeParameterInstantiation\");\r\n    }\r\n\r\n    flowParseInterfaceType(): N.FlowInterfaceType {\r\n      const node = this.startNode();\r\n      this.expectContextual(\"interface\");\r\n\r\n      node.extends = [];\r\n      if (this.eat(tt._extends)) {\r\n        do {\r\n          node.extends.push(this.flowParseInterfaceExtends());\r\n        } while (this.eat(tt.comma));\r\n      }\r\n\r\n      node.body = this.flowParseObjectType({\r\n        allowStatic: false,\r\n        allowExact: false,\r\n        allowSpread: false,\r\n        allowProto: false,\r\n        allowInexact: false,\r\n      });\r\n\r\n      return this.finishNode(node, \"InterfaceTypeAnnotation\");\r\n    }\r\n\r\n    flowParseObjectPropertyKey(): N.Expression {\r\n      return this.match(tt.num) || this.match(tt.string)\r\n        ? this.parseExprAtom()\r\n        : this.parseIdentifier(true);\r\n    }\r\n\r\n    flowParseObjectTypeIndexer(\r\n      node: N.FlowObjectTypeIndexer,\r\n      isStatic: boolean,\r\n      variance: ?N.FlowVariance,\r\n    ): N.FlowObjectTypeIndexer {\r\n      node.static = isStatic;\r\n\r\n      // Note: bracketL has already been consumed\r\n      if (this.lookahead().type === tt.colon) {\r\n        node.id = this.flowParseObjectPropertyKey();\r\n        node.key = this.flowParseTypeInitialiser();\r\n      } else {\r\n        node.id = null;\r\n        node.key = this.flowParseType();\r\n      }\r\n      this.expect(tt.bracketR);\r\n      node.value = this.flowParseTypeInitialiser();\r\n      node.variance = variance;\r\n\r\n      return this.finishNode(node, \"ObjectTypeIndexer\");\r\n    }\r\n\r\n    flowParseObjectTypeInternalSlot(\r\n      node: N.FlowObjectTypeInternalSlot,\r\n      isStatic: boolean,\r\n    ): N.FlowObjectTypeInternalSlot {\r\n      node.static = isStatic;\r\n      // Note: both bracketL have already been consumed\r\n      node.id = this.flowParseObjectPropertyKey();\r\n      this.expect(tt.bracketR);\r\n      this.expect(tt.bracketR);\r\n      if (this.isRelational(\"<\") || this.match(tt.parenL)) {\r\n        node.method = true;\r\n        node.optional = false;\r\n        node.value = this.flowParseObjectTypeMethodish(\r\n          this.startNodeAt(node.start, node.loc.start),\r\n        );\r\n      } else {\r\n        node.method = false;\r\n        if (this.eat(tt.question)) {\r\n          node.optional = true;\r\n        }\r\n        node.value = this.flowParseTypeInitialiser();\r\n      }\r\n      return this.finishNode(node, \"ObjectTypeInternalSlot\");\r\n    }\r\n\r\n    flowParseObjectTypeMethodish(\r\n      node: N.FlowFunctionTypeAnnotation,\r\n    ): N.FlowFunctionTypeAnnotation {\r\n      node.params = [];\r\n      node.rest = null;\r\n      node.typeParameters = null;\r\n\r\n      if (this.isRelational(\"<\")) {\r\n        node.typeParameters = this.flowParseTypeParameterDeclaration(\r\n          /* allowDefault */ false,\r\n        );\r\n      }\r\n\r\n      this.expect(tt.parenL);\r\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\r\n        node.params.push(this.flowParseFunctionTypeParam());\r\n        if (!this.match(tt.parenR)) {\r\n          this.expect(tt.comma);\r\n        }\r\n      }\r\n\r\n      if (this.eat(tt.ellipsis)) {\r\n        node.rest = this.flowParseFunctionTypeParam();\r\n      }\r\n      this.expect(tt.parenR);\r\n      node.returnType = this.flowParseTypeInitialiser();\r\n\r\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\r\n    }\r\n\r\n    flowParseObjectTypeCallProperty(\r\n      node: N.FlowObjectTypeCallProperty,\r\n      isStatic: boolean,\r\n    ): N.FlowObjectTypeCallProperty {\r\n      const valueNode = this.startNode();\r\n      node.static = isStatic;\r\n      node.value = this.flowParseObjectTypeMethodish(valueNode);\r\n      return this.finishNode(node, \"ObjectTypeCallProperty\");\r\n    }\r\n\r\n    flowParseObjectType({\r\n      allowStatic,\r\n      allowExact,\r\n      allowSpread,\r\n      allowProto,\r\n      allowInexact,\r\n    }: {\r\n      allowStatic: boolean,\r\n      allowExact: boolean,\r\n      allowSpread: boolean,\r\n      allowProto: boolean,\r\n      allowInexact: boolean,\r\n    }): N.FlowObjectTypeAnnotation {\r\n      const oldInType = this.state.inType;\r\n      this.state.inType = true;\r\n\r\n      const nodeStart = this.startNode();\r\n\r\n      nodeStart.callProperties = [];\r\n      nodeStart.properties = [];\r\n      nodeStart.indexers = [];\r\n      nodeStart.internalSlots = [];\r\n\r\n      let endDelim;\r\n      let exact;\r\n      let inexact = false;\r\n      if (allowExact && this.match(tt.braceBarL)) {\r\n        this.expect(tt.braceBarL);\r\n        endDelim = tt.braceBarR;\r\n        exact = true;\r\n      } else {\r\n        this.expect(tt.braceL);\r\n        endDelim = tt.braceR;\r\n        exact = false;\r\n      }\r\n\r\n      nodeStart.exact = exact;\r\n\r\n      while (!this.match(endDelim)) {\r\n        let isStatic = false;\r\n        let protoStart: ?number = null;\r\n        const node = this.startNode();\r\n\r\n        if (allowProto && this.isContextual(\"proto\")) {\r\n          const lookahead = this.lookahead();\r\n\r\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\r\n            this.next();\r\n            protoStart = this.state.start;\r\n            allowStatic = false;\r\n          }\r\n        }\r\n\r\n        if (allowStatic && this.isContextual(\"static\")) {\r\n          const lookahead = this.lookahead();\r\n\r\n          // static is a valid identifier name\r\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\r\n            this.next();\r\n            isStatic = true;\r\n          }\r\n        }\r\n\r\n        const variance = this.flowParseVariance();\r\n\r\n        if (this.eat(tt.bracketL)) {\r\n          if (protoStart != null) {\r\n            this.unexpected(protoStart);\r\n          }\r\n          if (this.eat(tt.bracketL)) {\r\n            if (variance) {\r\n              this.unexpected(variance.start);\r\n            }\r\n            nodeStart.internalSlots.push(\r\n              this.flowParseObjectTypeInternalSlot(node, isStatic),\r\n            );\r\n          } else {\r\n            nodeStart.indexers.push(\r\n              this.flowParseObjectTypeIndexer(node, isStatic, variance),\r\n            );\r\n          }\r\n        } else if (this.match(tt.parenL) || this.isRelational(\"<\")) {\r\n          if (protoStart != null) {\r\n            this.unexpected(protoStart);\r\n          }\r\n          if (variance) {\r\n            this.unexpected(variance.start);\r\n          }\r\n          nodeStart.callProperties.push(\r\n            this.flowParseObjectTypeCallProperty(node, isStatic),\r\n          );\r\n        } else {\r\n          let kind = \"init\";\r\n\r\n          if (this.isContextual(\"get\") || this.isContextual(\"set\")) {\r\n            const lookahead = this.lookahead();\r\n            if (\r\n              lookahead.type === tt.name ||\r\n              lookahead.type === tt.string ||\r\n              lookahead.type === tt.num\r\n            ) {\r\n              kind = this.state.value;\r\n              this.next();\r\n            }\r\n          }\r\n\r\n          const propOrInexact = this.flowParseObjectTypeProperty(\r\n            node,\r\n            isStatic,\r\n            protoStart,\r\n            variance,\r\n            kind,\r\n            allowSpread,\r\n            allowInexact,\r\n          );\r\n\r\n          if (propOrInexact === null) {\r\n            inexact = true;\r\n          } else {\r\n            nodeStart.properties.push(propOrInexact);\r\n          }\r\n        }\r\n\r\n        this.flowObjectTypeSemicolon();\r\n      }\r\n\r\n      this.expect(endDelim);\r\n\r\n      /* The inexact flag should only be added on ObjectTypeAnnotations that\r\n       * are not the body of an interface, declare interface, or declare class.\r\n       * Since spreads are only allowed in objec types, checking that is\r\n       * sufficient here.\r\n       */\r\n      if (allowSpread) {\r\n        nodeStart.inexact = inexact;\r\n      }\r\n\r\n      const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\r\n\r\n      this.state.inType = oldInType;\r\n\r\n      return out;\r\n    }\r\n\r\n    flowParseObjectTypeProperty(\r\n      node: N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty,\r\n      isStatic: boolean,\r\n      protoStart: ?number,\r\n      variance: ?N.FlowVariance,\r\n      kind: string,\r\n      allowSpread: boolean,\r\n      allowInexact: boolean,\r\n    ): (N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty) | null {\r\n      if (this.match(tt.ellipsis)) {\r\n        if (!allowSpread) {\r\n          this.unexpected(\r\n            null,\r\n            \"Spread operator cannot appear in class or interface definitions\",\r\n          );\r\n        }\r\n        if (protoStart != null) {\r\n          this.unexpected(protoStart);\r\n        }\r\n        if (variance) {\r\n          this.unexpected(\r\n            variance.start,\r\n            \"Spread properties cannot have variance\",\r\n          );\r\n        }\r\n        this.expect(tt.ellipsis);\r\n        const isInexactToken = this.eat(tt.comma) || this.eat(tt.semi);\r\n\r\n        if (this.match(tt.braceR)) {\r\n          if (allowInexact) return null;\r\n          this.unexpected(\r\n            null,\r\n            \"Explicit inexact syntax is only allowed inside inexact objects\",\r\n          );\r\n        }\r\n\r\n        if (this.match(tt.braceBarR)) {\r\n          this.unexpected(\r\n            null,\r\n            \"Explicit inexact syntax cannot appear inside an explicit exact object type\",\r\n          );\r\n        }\r\n\r\n        if (isInexactToken) {\r\n          this.unexpected(\r\n            null,\r\n            \"Explicit inexact syntax must appear at the end of an inexact object\",\r\n          );\r\n        }\r\n        node.argument = this.flowParseType();\r\n        return this.finishNode(node, \"ObjectTypeSpreadProperty\");\r\n      } else {\r\n        node.key = this.flowParseObjectPropertyKey();\r\n        node.static = isStatic;\r\n        node.proto = protoStart != null;\r\n        node.kind = kind;\r\n\r\n        let optional = false;\r\n        if (this.isRelational(\"<\") || this.match(tt.parenL)) {\r\n          // This is a method property\r\n          node.method = true;\r\n\r\n          if (protoStart != null) {\r\n            this.unexpected(protoStart);\r\n          }\r\n          if (variance) {\r\n            this.unexpected(variance.start);\r\n          }\r\n\r\n          node.value = this.flowParseObjectTypeMethodish(\r\n            this.startNodeAt(node.start, node.loc.start),\r\n          );\r\n          if (kind === \"get\" || kind === \"set\") {\r\n            this.flowCheckGetterSetterParams(node);\r\n          }\r\n        } else {\r\n          if (kind !== \"init\") this.unexpected();\r\n\r\n          node.method = false;\r\n\r\n          if (this.eat(tt.question)) {\r\n            optional = true;\r\n          }\r\n          node.value = this.flowParseTypeInitialiser();\r\n          node.variance = variance;\r\n        }\r\n\r\n        node.optional = optional;\r\n\r\n        return this.finishNode(node, \"ObjectTypeProperty\");\r\n      }\r\n    }\r\n\r\n    // This is similar to checkGetterSetterParams, but as\r\n    // @babel/parser uses non estree properties we cannot reuse it here\r\n    flowCheckGetterSetterParams(\r\n      property: N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty,\r\n    ): void {\r\n      const paramCount = property.kind === \"get\" ? 0 : 1;\r\n      const start = property.start;\r\n      const length =\r\n        property.value.params.length + (property.value.rest ? 1 : 0);\r\n      if (length !== paramCount) {\r\n        if (property.kind === \"get\") {\r\n          this.raise(start, \"getter must not have any formal parameters\");\r\n        } else {\r\n          this.raise(start, \"setter must have exactly one formal parameter\");\r\n        }\r\n      }\r\n\r\n      if (property.kind === \"set\" && property.value.rest) {\r\n        this.raise(\r\n          start,\r\n          \"setter function argument must not be a rest parameter\",\r\n        );\r\n      }\r\n    }\r\n\r\n    flowObjectTypeSemicolon(): void {\r\n      if (\r\n        !this.eat(tt.semi) &&\r\n        !this.eat(tt.comma) &&\r\n        !this.match(tt.braceR) &&\r\n        !this.match(tt.braceBarR)\r\n      ) {\r\n        this.unexpected();\r\n      }\r\n    }\r\n\r\n    flowParseQualifiedTypeIdentifier(\r\n      startPos?: number,\r\n      startLoc?: Position,\r\n      id?: N.Identifier,\r\n    ): N.FlowQualifiedTypeIdentifier {\r\n      startPos = startPos || this.state.start;\r\n      startLoc = startLoc || this.state.startLoc;\r\n      let node = id || this.parseIdentifier();\r\n\r\n      while (this.eat(tt.dot)) {\r\n        const node2 = this.startNodeAt(startPos, startLoc);\r\n        node2.qualification = node;\r\n        node2.id = this.parseIdentifier();\r\n        node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\r\n      }\r\n\r\n      return node;\r\n    }\r\n\r\n    flowParseGenericType(\r\n      startPos: number,\r\n      startLoc: Position,\r\n      id: N.Identifier,\r\n    ): N.FlowGenericTypeAnnotation {\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n\r\n      node.typeParameters = null;\r\n      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\r\n\r\n      if (this.isRelational(\"<\")) {\r\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\r\n      }\r\n\r\n      return this.finishNode(node, \"GenericTypeAnnotation\");\r\n    }\r\n\r\n    flowParseTypeofType(): N.FlowTypeofTypeAnnotation {\r\n      const node = this.startNode();\r\n      this.expect(tt._typeof);\r\n      node.argument = this.flowParsePrimaryType();\r\n      return this.finishNode(node, \"TypeofTypeAnnotation\");\r\n    }\r\n\r\n    flowParseTupleType(): N.FlowTupleTypeAnnotation {\r\n      const node = this.startNode();\r\n      node.types = [];\r\n      this.expect(tt.bracketL);\r\n      // We allow trailing commas\r\n      while (this.state.pos < this.length && !this.match(tt.bracketR)) {\r\n        node.types.push(this.flowParseType());\r\n        if (this.match(tt.bracketR)) break;\r\n        this.expect(tt.comma);\r\n      }\r\n      this.expect(tt.bracketR);\r\n      return this.finishNode(node, \"TupleTypeAnnotation\");\r\n    }\r\n\r\n    flowParseFunctionTypeParam(): N.FlowFunctionTypeParam {\r\n      let name = null;\r\n      let optional = false;\r\n      let typeAnnotation = null;\r\n      const node = this.startNode();\r\n      const lh = this.lookahead();\r\n      if (lh.type === tt.colon || lh.type === tt.question) {\r\n        name = this.parseIdentifier();\r\n        if (this.eat(tt.question)) {\r\n          optional = true;\r\n        }\r\n        typeAnnotation = this.flowParseTypeInitialiser();\r\n      } else {\r\n        typeAnnotation = this.flowParseType();\r\n      }\r\n      node.name = name;\r\n      node.optional = optional;\r\n      node.typeAnnotation = typeAnnotation;\r\n      return this.finishNode(node, \"FunctionTypeParam\");\r\n    }\r\n\r\n    reinterpretTypeAsFunctionTypeParam(\r\n      type: N.FlowType,\r\n    ): N.FlowFunctionTypeParam {\r\n      const node = this.startNodeAt(type.start, type.loc.start);\r\n      node.name = null;\r\n      node.optional = false;\r\n      node.typeAnnotation = type;\r\n      return this.finishNode(node, \"FunctionTypeParam\");\r\n    }\r\n\r\n    flowParseFunctionTypeParams(\r\n      params: N.FlowFunctionTypeParam[] = [],\r\n    ): { params: N.FlowFunctionTypeParam[], rest: ?N.FlowFunctionTypeParam } {\r\n      let rest: ?N.FlowFunctionTypeParam = null;\r\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\r\n        params.push(this.flowParseFunctionTypeParam());\r\n        if (!this.match(tt.parenR)) {\r\n          this.expect(tt.comma);\r\n        }\r\n      }\r\n      if (this.eat(tt.ellipsis)) {\r\n        rest = this.flowParseFunctionTypeParam();\r\n      }\r\n      return { params, rest };\r\n    }\r\n\r\n    flowIdentToTypeAnnotation(\r\n      startPos: number,\r\n      startLoc: Position,\r\n      node: N.FlowTypeAnnotation,\r\n      id: N.Identifier,\r\n    ): N.FlowTypeAnnotation {\r\n      switch (id.name) {\r\n        case \"any\":\r\n          return this.finishNode(node, \"AnyTypeAnnotation\");\r\n\r\n        case \"bool\":\r\n        case \"boolean\":\r\n          return this.finishNode(node, \"BooleanTypeAnnotation\");\r\n\r\n        case \"mixed\":\r\n          return this.finishNode(node, \"MixedTypeAnnotation\");\r\n\r\n        case \"empty\":\r\n          return this.finishNode(node, \"EmptyTypeAnnotation\");\r\n\r\n        case \"number\":\r\n          return this.finishNode(node, \"NumberTypeAnnotation\");\r\n\r\n        case \"string\":\r\n          return this.finishNode(node, \"StringTypeAnnotation\");\r\n\r\n        default:\r\n          this.checkNotUnderscore(id.name);\r\n          return this.flowParseGenericType(startPos, startLoc, id);\r\n      }\r\n    }\r\n\r\n    // The parsing of types roughly parallels the parsing of expressions, and\r\n    // primary types are kind of like primary expressions...they're the\r\n    // primitives with which other types are constructed.\r\n    flowParsePrimaryType(): N.FlowTypeAnnotation {\r\n      const startPos = this.state.start;\r\n      const startLoc = this.state.startLoc;\r\n      const node = this.startNode();\r\n      let tmp;\r\n      let type;\r\n      let isGroupedType = false;\r\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\r\n\r\n      switch (this.state.type) {\r\n        case tt.name:\r\n          if (this.isContextual(\"interface\")) {\r\n            return this.flowParseInterfaceType();\r\n          }\r\n\r\n          return this.flowIdentToTypeAnnotation(\r\n            startPos,\r\n            startLoc,\r\n            node,\r\n            this.parseIdentifier(),\r\n          );\r\n\r\n        case tt.braceL:\r\n          return this.flowParseObjectType({\r\n            allowStatic: false,\r\n            allowExact: false,\r\n            allowSpread: true,\r\n            allowProto: false,\r\n            allowInexact: true,\r\n          });\r\n\r\n        case tt.braceBarL:\r\n          return this.flowParseObjectType({\r\n            allowStatic: false,\r\n            allowExact: true,\r\n            allowSpread: true,\r\n            allowProto: false,\r\n            allowInexact: false,\r\n          });\r\n\r\n        case tt.bracketL:\r\n          return this.flowParseTupleType();\r\n\r\n        case tt.relational:\r\n          if (this.state.value === \"<\") {\r\n            node.typeParameters = this.flowParseTypeParameterDeclaration(\r\n              /* allowDefault */ false,\r\n            );\r\n            this.expect(tt.parenL);\r\n            tmp = this.flowParseFunctionTypeParams();\r\n            node.params = tmp.params;\r\n            node.rest = tmp.rest;\r\n            this.expect(tt.parenR);\r\n\r\n            this.expect(tt.arrow);\r\n\r\n            node.returnType = this.flowParseType();\r\n\r\n            return this.finishNode(node, \"FunctionTypeAnnotation\");\r\n          }\r\n          break;\r\n\r\n        case tt.parenL:\r\n          this.next();\r\n\r\n          // Check to see if this is actually a grouped type\r\n          if (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\r\n            if (this.match(tt.name)) {\r\n              const token = this.lookahead().type;\r\n              isGroupedType = token !== tt.question && token !== tt.colon;\r\n            } else {\r\n              isGroupedType = true;\r\n            }\r\n          }\r\n\r\n          if (isGroupedType) {\r\n            this.state.noAnonFunctionType = false;\r\n            type = this.flowParseType();\r\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\r\n\r\n            // A `,` or a `) =>` means this is an anonymous function type\r\n            if (\r\n              this.state.noAnonFunctionType ||\r\n              !(\r\n                this.match(tt.comma) ||\r\n                (this.match(tt.parenR) && this.lookahead().type === tt.arrow)\r\n              )\r\n            ) {\r\n              this.expect(tt.parenR);\r\n              return type;\r\n            } else {\r\n              // Eat a comma if there is one\r\n              this.eat(tt.comma);\r\n            }\r\n          }\r\n\r\n          if (type) {\r\n            tmp = this.flowParseFunctionTypeParams([\r\n              this.reinterpretTypeAsFunctionTypeParam(type),\r\n            ]);\r\n          } else {\r\n            tmp = this.flowParseFunctionTypeParams();\r\n          }\r\n\r\n          node.params = tmp.params;\r\n          node.rest = tmp.rest;\r\n\r\n          this.expect(tt.parenR);\r\n\r\n          this.expect(tt.arrow);\r\n\r\n          node.returnType = this.flowParseType();\r\n\r\n          node.typeParameters = null;\r\n\r\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\r\n\r\n        case tt.string:\r\n          return this.parseLiteral(\r\n            this.state.value,\r\n            \"StringLiteralTypeAnnotation\",\r\n          );\r\n\r\n        case tt._true:\r\n        case tt._false:\r\n          node.value = this.match(tt._true);\r\n          this.next();\r\n          return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\r\n\r\n        case tt.plusMin:\r\n          if (this.state.value === \"-\") {\r\n            this.next();\r\n            if (!this.match(tt.num)) {\r\n              this.unexpected(null, `Unexpected token, expected \"number\"`);\r\n            }\r\n\r\n            return this.parseLiteral(\r\n              -this.state.value,\r\n              \"NumberLiteralTypeAnnotation\",\r\n              node.start,\r\n              node.loc.start,\r\n            );\r\n          }\r\n\r\n          this.unexpected();\r\n        case tt.num:\r\n          return this.parseLiteral(\r\n            this.state.value,\r\n            \"NumberLiteralTypeAnnotation\",\r\n          );\r\n\r\n        case tt._void:\r\n          this.next();\r\n          return this.finishNode(node, \"VoidTypeAnnotation\");\r\n\r\n        case tt._null:\r\n          this.next();\r\n          return this.finishNode(node, \"NullLiteralTypeAnnotation\");\r\n\r\n        case tt._this:\r\n          this.next();\r\n          return this.finishNode(node, \"ThisTypeAnnotation\");\r\n\r\n        case tt.star:\r\n          this.next();\r\n          return this.finishNode(node, \"ExistsTypeAnnotation\");\r\n\r\n        default:\r\n          if (this.state.type.keyword === \"typeof\") {\r\n            return this.flowParseTypeofType();\r\n          } else if (this.state.type.keyword) {\r\n            const label = this.state.type.label;\r\n            this.next();\r\n            return super.createIdentifier(node, label);\r\n          }\r\n      }\r\n\r\n      throw this.unexpected();\r\n    }\r\n\r\n    flowParsePostfixType(): N.FlowTypeAnnotation {\r\n      const startPos = this.state.start,\r\n        startLoc = this.state.startLoc;\r\n      let type = this.flowParsePrimaryType();\r\n      while (this.match(tt.bracketL) && !this.canInsertSemicolon()) {\r\n        const node = this.startNodeAt(startPos, startLoc);\r\n        node.elementType = type;\r\n        this.expect(tt.bracketL);\r\n        this.expect(tt.bracketR);\r\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\r\n      }\r\n      return type;\r\n    }\r\n\r\n    flowParsePrefixType(): N.FlowTypeAnnotation {\r\n      const node = this.startNode();\r\n      if (this.eat(tt.question)) {\r\n        node.typeAnnotation = this.flowParsePrefixType();\r\n        return this.finishNode(node, \"NullableTypeAnnotation\");\r\n      } else {\r\n        return this.flowParsePostfixType();\r\n      }\r\n    }\r\n\r\n    flowParseAnonFunctionWithoutParens(): N.FlowTypeAnnotation {\r\n      const param = this.flowParsePrefixType();\r\n      if (!this.state.noAnonFunctionType && this.eat(tt.arrow)) {\r\n        // TODO: This should be a type error. Passing in a SourceLocation, and it expects a Position.\r\n        const node = this.startNodeAt(param.start, param.loc.start);\r\n        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\r\n        node.rest = null;\r\n        node.returnType = this.flowParseType();\r\n        node.typeParameters = null;\r\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\r\n      }\r\n      return param;\r\n    }\r\n\r\n    flowParseIntersectionType(): N.FlowTypeAnnotation {\r\n      const node = this.startNode();\r\n      this.eat(tt.bitwiseAND);\r\n      const type = this.flowParseAnonFunctionWithoutParens();\r\n      node.types = [type];\r\n      while (this.eat(tt.bitwiseAND)) {\r\n        node.types.push(this.flowParseAnonFunctionWithoutParens());\r\n      }\r\n      return node.types.length === 1\r\n        ? type\r\n        : this.finishNode(node, \"IntersectionTypeAnnotation\");\r\n    }\r\n\r\n    flowParseUnionType(): N.FlowTypeAnnotation {\r\n      const node = this.startNode();\r\n      this.eat(tt.bitwiseOR);\r\n      const type = this.flowParseIntersectionType();\r\n      node.types = [type];\r\n      while (this.eat(tt.bitwiseOR)) {\r\n        node.types.push(this.flowParseIntersectionType());\r\n      }\r\n      return node.types.length === 1\r\n        ? type\r\n        : this.finishNode(node, \"UnionTypeAnnotation\");\r\n    }\r\n\r\n    flowParseType(): N.FlowTypeAnnotation {\r\n      const oldInType = this.state.inType;\r\n      this.state.inType = true;\r\n      const type = this.flowParseUnionType();\r\n      this.state.inType = oldInType;\r\n      // Ensure that a brace after a function generic type annotation is a\r\n      // statement, except in arrow functions (noAnonFunctionType)\r\n      this.state.exprAllowed =\r\n        this.state.exprAllowed || this.state.noAnonFunctionType;\r\n      return type;\r\n    }\r\n\r\n    flowParseTypeOrImplicitInstantiation(): N.FlowTypeAnnotation {\r\n      if (this.state.type === tt.name && this.state.value === \"_\") {\r\n        const startPos = this.state.start;\r\n        const startLoc = this.state.startLoc;\r\n        const node = this.parseIdentifier();\r\n        return this.flowParseGenericType(startPos, startLoc, node);\r\n      } else {\r\n        return this.flowParseType();\r\n      }\r\n    }\r\n\r\n    flowParseTypeAnnotation(): N.FlowTypeAnnotation {\r\n      const node = this.startNode();\r\n      node.typeAnnotation = this.flowParseTypeInitialiser();\r\n      return this.finishNode(node, \"TypeAnnotation\");\r\n    }\r\n\r\n    flowParseTypeAnnotatableIdentifier(\r\n      allowPrimitiveOverride?: boolean,\r\n    ): N.Identifier {\r\n      const ident = allowPrimitiveOverride\r\n        ? this.parseIdentifier()\r\n        : this.flowParseRestrictedIdentifier();\r\n      if (this.match(tt.colon)) {\r\n        ident.typeAnnotation = this.flowParseTypeAnnotation();\r\n        this.resetEndLocation(ident);\r\n      }\r\n      return ident;\r\n    }\r\n\r\n    typeCastToParameter(node: N.Node): N.Node {\r\n      node.expression.typeAnnotation = node.typeAnnotation;\r\n\r\n      this.resetEndLocation(\r\n        node.expression,\r\n        node.typeAnnotation.end,\r\n        node.typeAnnotation.loc.end,\r\n      );\r\n\r\n      return node.expression;\r\n    }\r\n\r\n    flowParseVariance(): ?N.FlowVariance {\r\n      let variance = null;\r\n      if (this.match(tt.plusMin)) {\r\n        variance = this.startNode();\r\n        if (this.state.value === \"+\") {\r\n          variance.kind = \"plus\";\r\n        } else {\r\n          variance.kind = \"minus\";\r\n        }\r\n        this.next();\r\n        this.finishNode(variance, \"Variance\");\r\n      }\r\n      return variance;\r\n    }\r\n\r\n    // ==================================\r\n    // Overrides\r\n    // ==================================\r\n\r\n    parseFunctionBody(\r\n      node: N.Function,\r\n      allowExpressionBody: ?boolean,\r\n      isMethod?: boolean = false,\r\n    ): void {\r\n      if (allowExpressionBody) {\r\n        return this.forwardNoArrowParamsConversionAt(node, () =>\r\n          super.parseFunctionBody(node, true, isMethod),\r\n        );\r\n      }\r\n\r\n      return super.parseFunctionBody(node, false, isMethod);\r\n    }\r\n\r\n    parseFunctionBodyAndFinish(\r\n      node: N.BodilessFunctionOrMethodBase,\r\n      type: string,\r\n      isMethod?: boolean = false,\r\n    ): void {\r\n      if (this.match(tt.colon)) {\r\n        const typeNode = this.startNode();\r\n\r\n        [\r\n          // $FlowFixMe (destructuring not supported yet)\r\n          typeNode.typeAnnotation,\r\n          // $FlowFixMe (destructuring not supported yet)\r\n          node.predicate,\r\n        ] = this.flowParseTypeAndPredicateInitialiser();\r\n\r\n        node.returnType = typeNode.typeAnnotation\r\n          ? this.finishNode(typeNode, \"TypeAnnotation\")\r\n          : null;\r\n      }\r\n\r\n      super.parseFunctionBodyAndFinish(node, type, isMethod);\r\n    }\r\n\r\n    // interfaces\r\n    parseStatement(context: ?string, topLevel?: boolean): N.Statement {\r\n      // strict mode handling of `interface` since it's a reserved word\r\n      if (\r\n        this.state.strict &&\r\n        this.match(tt.name) &&\r\n        this.state.value === \"interface\"\r\n      ) {\r\n        const node = this.startNode();\r\n        this.next();\r\n        return this.flowParseInterface(node);\r\n      } else {\r\n        const stmt = super.parseStatement(context, topLevel);\r\n        // We will parse a flow pragma in any comment before the first statement.\r\n        if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\r\n          this.flowPragma = null;\r\n        }\r\n        return stmt;\r\n      }\r\n    }\r\n\r\n    // declares, interfaces and type aliases\r\n    parseExpressionStatement(\r\n      node: N.ExpressionStatement,\r\n      expr: N.Expression,\r\n    ): N.ExpressionStatement {\r\n      if (expr.type === \"Identifier\") {\r\n        if (expr.name === \"declare\") {\r\n          if (\r\n            this.match(tt._class) ||\r\n            this.match(tt.name) ||\r\n            this.match(tt._function) ||\r\n            this.match(tt._var) ||\r\n            this.match(tt._export)\r\n          ) {\r\n            return this.flowParseDeclare(node);\r\n          }\r\n        } else if (this.match(tt.name)) {\r\n          if (expr.name === \"interface\") {\r\n            return this.flowParseInterface(node);\r\n          } else if (expr.name === \"type\") {\r\n            return this.flowParseTypeAlias(node);\r\n          } else if (expr.name === \"opaque\") {\r\n            return this.flowParseOpaqueType(node, false);\r\n          }\r\n        }\r\n      }\r\n\r\n      return super.parseExpressionStatement(node, expr);\r\n    }\r\n\r\n    // export type\r\n    shouldParseExportDeclaration(): boolean {\r\n      return (\r\n        this.isContextual(\"type\") ||\r\n        this.isContextual(\"interface\") ||\r\n        this.isContextual(\"opaque\") ||\r\n        super.shouldParseExportDeclaration()\r\n      );\r\n    }\r\n\r\n    isExportDefaultSpecifier(): boolean {\r\n      if (\r\n        this.match(tt.name) &&\r\n        (this.state.value === \"type\" ||\r\n          this.state.value === \"interface\" ||\r\n          this.state.value === \"opaque\")\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      return super.isExportDefaultSpecifier();\r\n    }\r\n\r\n    parseConditional(\r\n      expr: N.Expression,\r\n      noIn: ?boolean,\r\n      startPos: number,\r\n      startLoc: Position,\r\n      refNeedsArrowPos?: ?Pos,\r\n    ): N.Expression {\r\n      if (!this.match(tt.question)) return expr;\r\n\r\n      // only do the expensive clone if there is a question mark\r\n      // and if we come from inside parens\r\n      if (refNeedsArrowPos) {\r\n        const state = this.state.clone();\r\n        try {\r\n          return super.parseConditional(expr, noIn, startPos, startLoc);\r\n        } catch (err) {\r\n          if (err instanceof SyntaxError) {\r\n            this.state = state;\r\n            refNeedsArrowPos.start = err.pos || this.state.start;\r\n            return expr;\r\n          } else {\r\n            // istanbul ignore next: no such error is expected\r\n            throw err;\r\n          }\r\n        }\r\n      }\r\n      this.expect(tt.question);\r\n      const state = this.state.clone();\r\n      const originalNoArrowAt = this.state.noArrowAt;\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n      let { consequent, failed } = this.tryParseConditionalConsequent();\r\n      let [valid, invalid] = this.getArrowLikeExpressions(consequent);\r\n\r\n      if (failed || invalid.length > 0) {\r\n        const noArrowAt = [...originalNoArrowAt];\r\n\r\n        if (invalid.length > 0) {\r\n          this.state = state;\r\n          this.state.noArrowAt = noArrowAt;\r\n\r\n          for (let i = 0; i < invalid.length; i++) {\r\n            noArrowAt.push(invalid[i].start);\r\n          }\r\n\r\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\r\n          [valid, invalid] = this.getArrowLikeExpressions(consequent);\r\n        }\r\n\r\n        if (failed && valid.length > 1) {\r\n          // if there are two or more possible correct ways of parsing, throw an\r\n          // error.\r\n          // e.g.   Source: a ? (b): c => (d): e => f\r\n          //      Result 1: a ? b : (c => ((d): e => f))\r\n          //      Result 2: a ? ((b): c => d) : (e => f)\r\n          this.raise(\r\n            state.start,\r\n            \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\r\n          );\r\n        }\r\n\r\n        if (failed && valid.length === 1) {\r\n          this.state = state;\r\n          this.state.noArrowAt = noArrowAt.concat(valid[0].start);\r\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\r\n        }\r\n\r\n        this.getArrowLikeExpressions(consequent, true);\r\n      }\r\n\r\n      this.state.noArrowAt = originalNoArrowAt;\r\n      this.expect(tt.colon);\r\n\r\n      node.test = expr;\r\n      node.consequent = consequent;\r\n      node.alternate = this.forwardNoArrowParamsConversionAt(node, () =>\r\n        this.parseMaybeAssign(noIn, undefined, undefined, undefined),\r\n      );\r\n\r\n      return this.finishNode(node, \"ConditionalExpression\");\r\n    }\r\n\r\n    tryParseConditionalConsequent(): {\r\n      consequent: N.Expression,\r\n      failed: boolean,\r\n    } {\r\n      this.state.noArrowParamsConversionAt.push(this.state.start);\r\n\r\n      const consequent = this.parseMaybeAssign();\r\n      const failed = !this.match(tt.colon);\r\n\r\n      this.state.noArrowParamsConversionAt.pop();\r\n\r\n      return { consequent, failed };\r\n    }\r\n\r\n    // Given an expression, walks through out its arrow functions whose body is\r\n    // an expression and through out conditional expressions. It returns every\r\n    // function which has been parsed with a return type but could have been\r\n    // parenthesized expressions.\r\n    // These functions are separated into two arrays: one containing the ones\r\n    // whose parameters can be converted to assignable lists, one containing the\r\n    // others.\r\n    getArrowLikeExpressions(\r\n      node: N.Expression,\r\n      disallowInvalid?: boolean,\r\n    ): [N.ArrowFunctionExpression[], N.ArrowFunctionExpression[]] {\r\n      const stack = [node];\r\n      const arrows: N.ArrowFunctionExpression[] = [];\r\n\r\n      while (stack.length !== 0) {\r\n        const node = stack.pop();\r\n        if (node.type === \"ArrowFunctionExpression\") {\r\n          if (node.typeParameters || !node.returnType) {\r\n            // This is an arrow expression without ambiguity, so check its parameters\r\n            this.toAssignableList(\r\n              // node.params is Expression[] instead of $ReadOnlyArray<Pattern> because it\r\n              // has not been converted yet.\r\n              ((node.params: any): N.Expression[]),\r\n              true,\r\n              \"arrow function parameters\",\r\n            );\r\n            // Enter scope, as checkParams defines bindings\r\n            this.scope.enter(functionFlags(false, false) | SCOPE_ARROW);\r\n            // Use super's method to force the parameters to be checked\r\n            super.checkParams(node, false, true);\r\n            this.scope.exit();\r\n          } else {\r\n            arrows.push(node);\r\n          }\r\n          stack.push(node.body);\r\n        } else if (node.type === \"ConditionalExpression\") {\r\n          stack.push(node.consequent);\r\n          stack.push(node.alternate);\r\n        }\r\n      }\r\n\r\n      if (disallowInvalid) {\r\n        for (let i = 0; i < arrows.length; i++) {\r\n          this.toAssignableList(\r\n            ((node.params: any): N.Expression[]),\r\n            true,\r\n            \"arrow function parameters\",\r\n          );\r\n        }\r\n        return [arrows, []];\r\n      }\r\n\r\n      return partition(arrows, node => {\r\n        try {\r\n          this.toAssignableList(\r\n            ((node.params: any): N.Expression[]),\r\n            true,\r\n            \"arrow function parameters\",\r\n          );\r\n          return true;\r\n        } catch (err) {\r\n          return false;\r\n        }\r\n      });\r\n    }\r\n\r\n    forwardNoArrowParamsConversionAt<T>(node: N.Node, parse: () => T): T {\r\n      let result: T;\r\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\r\n        this.state.noArrowParamsConversionAt.push(this.state.start);\r\n        result = parse();\r\n        this.state.noArrowParamsConversionAt.pop();\r\n      } else {\r\n        result = parse();\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    parseParenItem(\r\n      node: N.Expression,\r\n      startPos: number,\r\n      startLoc: Position,\r\n    ): N.Expression {\r\n      node = super.parseParenItem(node, startPos, startLoc);\r\n      if (this.eat(tt.question)) {\r\n        node.optional = true;\r\n        // Include questionmark in location of node\r\n        // Don't use this.finishNode() as otherwise we might process comments twice and\r\n        // include already consumed parens\r\n        this.resetEndLocation(node);\r\n      }\r\n\r\n      if (this.match(tt.colon)) {\r\n        const typeCastNode = this.startNodeAt(startPos, startLoc);\r\n        typeCastNode.expression = node;\r\n        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\r\n\r\n        return this.finishNode(typeCastNode, \"TypeCastExpression\");\r\n      }\r\n\r\n      return node;\r\n    }\r\n\r\n    assertModuleNodeAllowed(node: N.Node) {\r\n      if (\r\n        (node.type === \"ImportDeclaration\" &&\r\n          (node.importKind === \"type\" || node.importKind === \"typeof\")) ||\r\n        (node.type === \"ExportNamedDeclaration\" &&\r\n          node.exportKind === \"type\") ||\r\n        (node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\")\r\n      ) {\r\n        // Allow Flowtype imports and exports in all conditions because\r\n        // Flow itself does not care about 'sourceType'.\r\n        return;\r\n      }\r\n\r\n      super.assertModuleNodeAllowed(node);\r\n    }\r\n\r\n    parseExport(node: N.Node): N.AnyExport {\r\n      const decl = super.parseExport(node);\r\n      if (\r\n        decl.type === \"ExportNamedDeclaration\" ||\r\n        decl.type === \"ExportAllDeclaration\"\r\n      ) {\r\n        decl.exportKind = decl.exportKind || \"value\";\r\n      }\r\n      return decl;\r\n    }\r\n\r\n    parseExportDeclaration(node: N.ExportNamedDeclaration): ?N.Declaration {\r\n      if (this.isContextual(\"type\")) {\r\n        node.exportKind = \"type\";\r\n\r\n        const declarationNode = this.startNode();\r\n        this.next();\r\n\r\n        if (this.match(tt.braceL)) {\r\n          // export type { foo, bar };\r\n          node.specifiers = this.parseExportSpecifiers();\r\n          this.parseExportFrom(node);\r\n          return null;\r\n        } else {\r\n          // export type Foo = Bar;\r\n          return this.flowParseTypeAlias(declarationNode);\r\n        }\r\n      } else if (this.isContextual(\"opaque\")) {\r\n        node.exportKind = \"type\";\r\n\r\n        const declarationNode = this.startNode();\r\n        this.next();\r\n        // export opaque type Foo = Bar;\r\n        return this.flowParseOpaqueType(declarationNode, false);\r\n      } else if (this.isContextual(\"interface\")) {\r\n        node.exportKind = \"type\";\r\n        const declarationNode = this.startNode();\r\n        this.next();\r\n        return this.flowParseInterface(declarationNode);\r\n      } else {\r\n        return super.parseExportDeclaration(node);\r\n      }\r\n    }\r\n\r\n    eatExportStar(node: N.Node): boolean {\r\n      if (super.eatExportStar(...arguments)) return true;\r\n\r\n      if (this.isContextual(\"type\") && this.lookahead().type === tt.star) {\r\n        node.exportKind = \"type\";\r\n        this.next();\r\n        this.next();\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    maybeParseExportNamespaceSpecifier(node: N.Node): boolean {\r\n      const pos = this.state.start;\r\n      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\r\n      if (hasNamespace && node.exportKind === \"type\") {\r\n        this.unexpected(pos);\r\n      }\r\n      return hasNamespace;\r\n    }\r\n\r\n    parseClassId(node: N.Class, isStatement: boolean, optionalId: ?boolean) {\r\n      super.parseClassId(node, isStatement, optionalId);\r\n      if (this.isRelational(\"<\")) {\r\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\r\n      }\r\n    }\r\n\r\n    // ensure that inside flow types, we bypass the jsx parser plugin\r\n    getTokenFromCode(code: number): void {\r\n      const next = this.input.charCodeAt(this.state.pos + 1);\r\n      if (code === charCodes.leftCurlyBrace && next === charCodes.verticalBar) {\r\n        return this.finishOp(tt.braceBarL, 2);\r\n      } else if (\r\n        this.state.inType &&\r\n        (code === charCodes.greaterThan || code === charCodes.lessThan)\r\n      ) {\r\n        return this.finishOp(tt.relational, 1);\r\n      } else if (isIteratorStart(code, next)) {\r\n        this.state.isIterator = true;\r\n        return super.readWord();\r\n      } else {\r\n        return super.getTokenFromCode(code);\r\n      }\r\n    }\r\n\r\n    toAssignable(\r\n      node: N.Node,\r\n      isBinding: ?boolean,\r\n      contextDescription: string,\r\n    ): N.Node {\r\n      if (node.type === \"TypeCastExpression\") {\r\n        return super.toAssignable(\r\n          this.typeCastToParameter(node),\r\n          isBinding,\r\n          contextDescription,\r\n        );\r\n      } else {\r\n        return super.toAssignable(node, isBinding, contextDescription);\r\n      }\r\n    }\r\n\r\n    // turn type casts that we found in function parameter head into type annotated params\r\n    toAssignableList(\r\n      exprList: N.Expression[],\r\n      isBinding: ?boolean,\r\n      contextDescription: string,\r\n    ): $ReadOnlyArray<N.Pattern> {\r\n      for (let i = 0; i < exprList.length; i++) {\r\n        const expr = exprList[i];\r\n        if (expr && expr.type === \"TypeCastExpression\") {\r\n          exprList[i] = this.typeCastToParameter(expr);\r\n        }\r\n      }\r\n      return super.toAssignableList(exprList, isBinding, contextDescription);\r\n    }\r\n\r\n    // this is a list of nodes, from something like a call expression, we need to filter the\r\n    // type casts that we've found that are illegal in this context\r\n    toReferencedList(\r\n      exprList: $ReadOnlyArray<?N.Expression>,\r\n      isParenthesizedExpr?: boolean,\r\n    ): $ReadOnlyArray<?N.Expression> {\r\n      for (let i = 0; i < exprList.length; i++) {\r\n        const expr = exprList[i];\r\n        if (\r\n          expr &&\r\n          expr.type === \"TypeCastExpression\" &&\r\n          (!expr.extra || !expr.extra.parenthesized) &&\r\n          (exprList.length > 1 || !isParenthesizedExpr)\r\n        ) {\r\n          this.raise(\r\n            expr.typeAnnotation.start,\r\n            \"The type cast expression is expected to be wrapped with parenthesis\",\r\n          );\r\n        }\r\n      }\r\n\r\n      return exprList;\r\n    }\r\n\r\n    checkLVal(\r\n      expr: N.Expression,\r\n      bindingType: BindingTypes = BIND_NONE,\r\n      checkClashes: ?{ [key: string]: boolean },\r\n      contextDescription: string,\r\n    ): void {\r\n      if (expr.type !== \"TypeCastExpression\") {\r\n        return super.checkLVal(\r\n          expr,\r\n          bindingType,\r\n          checkClashes,\r\n          contextDescription,\r\n        );\r\n      }\r\n    }\r\n\r\n    // parse class property type annotations\r\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\r\n      if (this.match(tt.colon)) {\r\n        node.typeAnnotation = this.flowParseTypeAnnotation();\r\n      }\r\n      return super.parseClassProperty(node);\r\n    }\r\n\r\n    parseClassPrivateProperty(\r\n      node: N.ClassPrivateProperty,\r\n    ): N.ClassPrivateProperty {\r\n      if (this.match(tt.colon)) {\r\n        node.typeAnnotation = this.flowParseTypeAnnotation();\r\n      }\r\n      return super.parseClassPrivateProperty(node);\r\n    }\r\n\r\n    // determine whether or not we're currently in the position where a class method would appear\r\n    isClassMethod(): boolean {\r\n      return this.isRelational(\"<\") || super.isClassMethod();\r\n    }\r\n\r\n    // determine whether or not we're currently in the position where a class property would appear\r\n    isClassProperty(): boolean {\r\n      return this.match(tt.colon) || super.isClassProperty();\r\n    }\r\n\r\n    isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\r\n      return !this.match(tt.colon) && super.isNonstaticConstructor(method);\r\n    }\r\n\r\n    // parse type parameters for class methods\r\n    pushClassMethod(\r\n      classBody: N.ClassBody,\r\n      method: N.ClassMethod,\r\n      isGenerator: boolean,\r\n      isAsync: boolean,\r\n      isConstructor: boolean,\r\n      allowsDirectSuper: boolean,\r\n    ): void {\r\n      if ((method: $FlowFixMe).variance) {\r\n        this.unexpected((method: $FlowFixMe).variance.start);\r\n      }\r\n      delete (method: $FlowFixMe).variance;\r\n      if (this.isRelational(\"<\")) {\r\n        method.typeParameters = this.flowParseTypeParameterDeclaration(\r\n          /* allowDefault */ false,\r\n        );\r\n      }\r\n\r\n      super.pushClassMethod(\r\n        classBody,\r\n        method,\r\n        isGenerator,\r\n        isAsync,\r\n        isConstructor,\r\n        allowsDirectSuper,\r\n      );\r\n    }\r\n\r\n    pushClassPrivateMethod(\r\n      classBody: N.ClassBody,\r\n      method: N.ClassPrivateMethod,\r\n      isGenerator: boolean,\r\n      isAsync: boolean,\r\n    ): void {\r\n      if ((method: $FlowFixMe).variance) {\r\n        this.unexpected((method: $FlowFixMe).variance.start);\r\n      }\r\n      delete (method: $FlowFixMe).variance;\r\n      if (this.isRelational(\"<\")) {\r\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\r\n      }\r\n\r\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\r\n    }\r\n\r\n    // parse a the super class type parameters and implements\r\n    parseClassSuper(node: N.Class): void {\r\n      super.parseClassSuper(node);\r\n      if (node.superClass && this.isRelational(\"<\")) {\r\n        node.superTypeParameters = this.flowParseTypeParameterInstantiation();\r\n      }\r\n      if (this.isContextual(\"implements\")) {\r\n        this.next();\r\n        const implemented: N.FlowClassImplements[] = (node.implements = []);\r\n        do {\r\n          const node = this.startNode();\r\n          node.id = this.flowParseRestrictedIdentifier(/*liberal*/ true);\r\n          if (this.isRelational(\"<\")) {\r\n            node.typeParameters = this.flowParseTypeParameterInstantiation();\r\n          } else {\r\n            node.typeParameters = null;\r\n          }\r\n          implemented.push(this.finishNode(node, \"ClassImplements\"));\r\n        } while (this.eat(tt.comma));\r\n      }\r\n    }\r\n\r\n    parsePropertyName(\r\n      node: N.ObjectOrClassMember | N.ClassMember | N.TsNamedTypeElementBase,\r\n    ): N.Identifier {\r\n      const variance = this.flowParseVariance();\r\n      const key = super.parsePropertyName(node);\r\n      // $FlowIgnore (\"variance\" not defined on TsNamedTypeElementBase)\r\n      node.variance = variance;\r\n      return key;\r\n    }\r\n\r\n    // parse type parameters for object method shorthand\r\n    parseObjPropValue(\r\n      prop: N.ObjectMember,\r\n      startPos: ?number,\r\n      startLoc: ?Position,\r\n      isGenerator: boolean,\r\n      isAsync: boolean,\r\n      isPattern: boolean,\r\n      refShorthandDefaultPos: ?Pos,\r\n      containsEsc: boolean,\r\n    ): void {\r\n      if ((prop: $FlowFixMe).variance) {\r\n        this.unexpected((prop: $FlowFixMe).variance.start);\r\n      }\r\n      delete (prop: $FlowFixMe).variance;\r\n\r\n      let typeParameters;\r\n\r\n      // method shorthand\r\n      if (this.isRelational(\"<\")) {\r\n        typeParameters = this.flowParseTypeParameterDeclaration(\r\n          /* allowDefault */ false,\r\n        );\r\n        if (!this.match(tt.parenL)) this.unexpected();\r\n      }\r\n\r\n      super.parseObjPropValue(\r\n        prop,\r\n        startPos,\r\n        startLoc,\r\n        isGenerator,\r\n        isAsync,\r\n        isPattern,\r\n        refShorthandDefaultPos,\r\n        containsEsc,\r\n      );\r\n\r\n      // add typeParameters if we found them\r\n      if (typeParameters) {\r\n        (prop.value || prop).typeParameters = typeParameters;\r\n      }\r\n    }\r\n\r\n    parseAssignableListItemTypes(param: N.Pattern): N.Pattern {\r\n      if (this.eat(tt.question)) {\r\n        if (param.type !== \"Identifier\") {\r\n          throw this.raise(\r\n            param.start,\r\n            \"A binding pattern parameter cannot be optional in an implementation signature.\",\r\n          );\r\n        }\r\n\r\n        param.optional = true;\r\n      }\r\n      if (this.match(tt.colon)) {\r\n        param.typeAnnotation = this.flowParseTypeAnnotation();\r\n      }\r\n      this.resetEndLocation(param);\r\n      return param;\r\n    }\r\n\r\n    parseMaybeDefault(\r\n      startPos?: ?number,\r\n      startLoc?: ?Position,\r\n      left?: ?N.Pattern,\r\n    ): N.Pattern {\r\n      const node = super.parseMaybeDefault(startPos, startLoc, left);\r\n\r\n      if (\r\n        node.type === \"AssignmentPattern\" &&\r\n        node.typeAnnotation &&\r\n        node.right.start < node.typeAnnotation.start\r\n      ) {\r\n        this.raise(\r\n          node.typeAnnotation.start,\r\n          \"Type annotations must come before default assignments, \" +\r\n            \"e.g. instead of `age = 25: number` use `age: number = 25`\",\r\n        );\r\n      }\r\n\r\n      return node;\r\n    }\r\n\r\n    shouldParseDefaultImport(node: N.ImportDeclaration): boolean {\r\n      if (!hasTypeImportKind(node)) {\r\n        return super.shouldParseDefaultImport(node);\r\n      }\r\n\r\n      return isMaybeDefaultImport(this.state);\r\n    }\r\n\r\n    parseImportSpecifierLocal(\r\n      node: N.ImportDeclaration,\r\n      specifier: N.Node,\r\n      type: string,\r\n      contextDescription: string,\r\n    ): void {\r\n      specifier.local = hasTypeImportKind(node)\r\n        ? this.flowParseRestrictedIdentifier(true)\r\n        : this.parseIdentifier();\r\n\r\n      this.checkLVal(\r\n        specifier.local,\r\n        BIND_LEXICAL,\r\n        undefined,\r\n        contextDescription,\r\n      );\r\n      node.specifiers.push(this.finishNode(specifier, type));\r\n    }\r\n\r\n    // parse typeof and type imports\r\n    maybeParseDefaultImportSpecifier(node: N.ImportDeclaration): boolean {\r\n      node.importKind = \"value\";\r\n\r\n      let kind = null;\r\n      if (this.match(tt._typeof)) {\r\n        kind = \"typeof\";\r\n      } else if (this.isContextual(\"type\")) {\r\n        kind = \"type\";\r\n      }\r\n      if (kind) {\r\n        const lh = this.lookahead();\r\n\r\n        // import type * is not allowed\r\n        if (kind === \"type\" && lh.type === tt.star) {\r\n          this.unexpected(lh.start);\r\n        }\r\n\r\n        if (\r\n          isMaybeDefaultImport(lh) ||\r\n          lh.type === tt.braceL ||\r\n          lh.type === tt.star\r\n        ) {\r\n          this.next();\r\n          node.importKind = kind;\r\n        }\r\n      }\r\n\r\n      return super.maybeParseDefaultImportSpecifier(node);\r\n    }\r\n\r\n    // parse import-type/typeof shorthand\r\n    parseImportSpecifier(node: N.ImportDeclaration): void {\r\n      const specifier = this.startNode();\r\n      const firstIdentLoc = this.state.start;\r\n      const firstIdent = this.parseIdentifier(true);\r\n\r\n      let specifierTypeKind = null;\r\n      if (firstIdent.name === \"type\") {\r\n        specifierTypeKind = \"type\";\r\n      } else if (firstIdent.name === \"typeof\") {\r\n        specifierTypeKind = \"typeof\";\r\n      }\r\n\r\n      let isBinding = false;\r\n      if (this.isContextual(\"as\") && !this.isLookaheadContextual(\"as\")) {\r\n        const as_ident = this.parseIdentifier(true);\r\n        if (\r\n          specifierTypeKind !== null &&\r\n          !this.match(tt.name) &&\r\n          !this.state.type.keyword\r\n        ) {\r\n          // `import {type as ,` or `import {type as }`\r\n          specifier.imported = as_ident;\r\n          specifier.importKind = specifierTypeKind;\r\n          specifier.local = as_ident.__clone();\r\n        } else {\r\n          // `import {type as foo`\r\n          specifier.imported = firstIdent;\r\n          specifier.importKind = null;\r\n          specifier.local = this.parseIdentifier();\r\n        }\r\n      } else if (\r\n        specifierTypeKind !== null &&\r\n        (this.match(tt.name) || this.state.type.keyword)\r\n      ) {\r\n        // `import {type foo`\r\n        specifier.imported = this.parseIdentifier(true);\r\n        specifier.importKind = specifierTypeKind;\r\n        if (this.eatContextual(\"as\")) {\r\n          specifier.local = this.parseIdentifier();\r\n        } else {\r\n          isBinding = true;\r\n          specifier.local = specifier.imported.__clone();\r\n        }\r\n      } else {\r\n        isBinding = true;\r\n        specifier.imported = firstIdent;\r\n        specifier.importKind = null;\r\n        specifier.local = specifier.imported.__clone();\r\n      }\r\n\r\n      const nodeIsTypeImport = hasTypeImportKind(node);\r\n      const specifierIsTypeImport = hasTypeImportKind(specifier);\r\n\r\n      if (nodeIsTypeImport && specifierIsTypeImport) {\r\n        this.raise(\r\n          firstIdentLoc,\r\n          \"The `type` and `typeof` keywords on named imports can only be used on regular \" +\r\n            \"`import` statements. It cannot be used with `import type` or `import typeof` statements\",\r\n        );\r\n      }\r\n\r\n      if (nodeIsTypeImport || specifierIsTypeImport) {\r\n        this.checkReservedType(specifier.local.name, specifier.local.start);\r\n      }\r\n\r\n      if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {\r\n        this.checkReservedWord(\r\n          specifier.local.name,\r\n          specifier.start,\r\n          true,\r\n          true,\r\n        );\r\n      }\r\n\r\n      this.checkLVal(\r\n        specifier.local,\r\n        BIND_LEXICAL,\r\n        undefined,\r\n        \"import specifier\",\r\n      );\r\n      node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\r\n    }\r\n\r\n    // parse function type parameters - function foo<T>() {}\r\n    parseFunctionParams(node: N.Function, allowModifiers?: boolean): void {\r\n      // $FlowFixMe\r\n      const kind = node.kind;\r\n      if (kind !== \"get\" && kind !== \"set\" && this.isRelational(\"<\")) {\r\n        node.typeParameters = this.flowParseTypeParameterDeclaration(\r\n          /* allowDefault */ false,\r\n        );\r\n      }\r\n      super.parseFunctionParams(node, allowModifiers);\r\n    }\r\n\r\n    // parse flow type annotations on variable declarator heads - let foo: string = bar\r\n    parseVarId(\r\n      decl: N.VariableDeclarator,\r\n      kind: \"var\" | \"let\" | \"const\",\r\n    ): void {\r\n      super.parseVarId(decl, kind);\r\n      if (this.match(tt.colon)) {\r\n        decl.id.typeAnnotation = this.flowParseTypeAnnotation();\r\n        this.resetEndLocation(decl.id); // set end position to end of type\r\n      }\r\n    }\r\n\r\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\r\n    parseAsyncArrowFromCallExpression(\r\n      node: N.ArrowFunctionExpression,\r\n      call: N.CallExpression,\r\n    ): N.ArrowFunctionExpression {\r\n      if (this.match(tt.colon)) {\r\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\r\n        this.state.noAnonFunctionType = true;\r\n        node.returnType = this.flowParseTypeAnnotation();\r\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\r\n      }\r\n\r\n      return super.parseAsyncArrowFromCallExpression(node, call);\r\n    }\r\n\r\n    // todo description\r\n    shouldParseAsyncArrow(): boolean {\r\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\r\n    }\r\n\r\n    // We need to support type parameter declarations for arrow functions. This\r\n    // is tricky. There are three situations we need to handle\r\n    //\r\n    // 1. This is either JSX or an arrow function. We'll try JSX first. If that\r\n    //    fails, we'll try an arrow function. If that fails, we'll throw the JSX\r\n    //    error.\r\n    // 2. This is an arrow function. We'll parse the type parameter declaration,\r\n    //    parse the rest, make sure the rest is an arrow function, and go from\r\n    //    there\r\n    // 3. This is neither. Just call the super method\r\n    parseMaybeAssign(\r\n      noIn?: ?boolean,\r\n      refShorthandDefaultPos?: ?Pos,\r\n      afterLeftParse?: Function,\r\n      refNeedsArrowPos?: ?Pos,\r\n    ): N.Expression {\r\n      let jsxError = null;\r\n      if (\r\n        this.hasPlugin(\"jsx\") &&\r\n        (this.match(tt.jsxTagStart) || this.isRelational(\"<\"))\r\n      ) {\r\n        const state = this.state.clone();\r\n        try {\r\n          return super.parseMaybeAssign(\r\n            noIn,\r\n            refShorthandDefaultPos,\r\n            afterLeftParse,\r\n            refNeedsArrowPos,\r\n          );\r\n        } catch (err) {\r\n          if (err instanceof SyntaxError) {\r\n            this.state = state;\r\n\r\n            // Remove `tc.j_expr` and `tc.j_oTag` from context added\r\n            // by parsing `jsxTagStart` to stop the JSX plugin from\r\n            // messing with the tokens\r\n            const cLength = this.state.context.length;\r\n            if (this.state.context[cLength - 1] === tc.j_oTag) {\r\n              this.state.context.length -= 2;\r\n            }\r\n\r\n            jsxError = err;\r\n          } else {\r\n            // istanbul ignore next: no such error is expected\r\n            throw err;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (jsxError != null || this.isRelational(\"<\")) {\r\n        let arrowExpression;\r\n        let typeParameters;\r\n        try {\r\n          typeParameters = this.flowParseTypeParameterDeclaration();\r\n          arrowExpression = this.forwardNoArrowParamsConversionAt(\r\n            typeParameters,\r\n            () =>\r\n              super.parseMaybeAssign(\r\n                noIn,\r\n                refShorthandDefaultPos,\r\n                afterLeftParse,\r\n                refNeedsArrowPos,\r\n              ),\r\n          );\r\n          arrowExpression.typeParameters = typeParameters;\r\n          this.resetStartLocationFromNode(arrowExpression, typeParameters);\r\n        } catch (err) {\r\n          throw jsxError || err;\r\n        }\r\n\r\n        if (arrowExpression.type === \"ArrowFunctionExpression\") {\r\n          return arrowExpression;\r\n        } else if (jsxError != null) {\r\n          throw jsxError;\r\n        } else {\r\n          this.raise(\r\n            typeParameters.start,\r\n            \"Expected an arrow function after this type parameter declaration\",\r\n          );\r\n        }\r\n      }\r\n\r\n      return super.parseMaybeAssign(\r\n        noIn,\r\n        refShorthandDefaultPos,\r\n        afterLeftParse,\r\n        refNeedsArrowPos,\r\n      );\r\n    }\r\n\r\n    // handle return types for arrow functions\r\n    parseArrow(node: N.ArrowFunctionExpression): ?N.ArrowFunctionExpression {\r\n      if (this.match(tt.colon)) {\r\n        const state = this.state.clone();\r\n        try {\r\n          const oldNoAnonFunctionType = this.state.noAnonFunctionType;\r\n          this.state.noAnonFunctionType = true;\r\n\r\n          const typeNode = this.startNode();\r\n\r\n          [\r\n            // $FlowFixMe (destructuring not supported yet)\r\n            typeNode.typeAnnotation,\r\n            // $FlowFixMe (destructuring not supported yet)\r\n            node.predicate,\r\n          ] = this.flowParseTypeAndPredicateInitialiser();\r\n\r\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\r\n\r\n          if (this.canInsertSemicolon()) this.unexpected();\r\n          if (!this.match(tt.arrow)) this.unexpected();\r\n\r\n          // assign after it is clear it is an arrow\r\n          node.returnType = typeNode.typeAnnotation\r\n            ? this.finishNode(typeNode, \"TypeAnnotation\")\r\n            : null;\r\n        } catch (err) {\r\n          if (err instanceof SyntaxError) {\r\n            this.state = state;\r\n          } else {\r\n            // istanbul ignore next: no such error is expected\r\n            throw err;\r\n          }\r\n        }\r\n      }\r\n\r\n      return super.parseArrow(node);\r\n    }\r\n\r\n    shouldParseArrow(): boolean {\r\n      return this.match(tt.colon) || super.shouldParseArrow();\r\n    }\r\n\r\n    setArrowFunctionParameters(\r\n      node: N.ArrowFunctionExpression,\r\n      params: N.Expression[],\r\n    ): void {\r\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\r\n        node.params = params;\r\n      } else {\r\n        super.setArrowFunctionParameters(node, params);\r\n      }\r\n    }\r\n\r\n    checkParams(\r\n      node: N.Function,\r\n      allowDuplicates: boolean,\r\n      isArrowFunction: ?boolean,\r\n    ): void {\r\n      if (\r\n        isArrowFunction &&\r\n        this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      return super.checkParams(node, allowDuplicates, isArrowFunction);\r\n    }\r\n\r\n    parseParenAndDistinguishExpression(canBeArrow: boolean): N.Expression {\r\n      return super.parseParenAndDistinguishExpression(\r\n        canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1,\r\n      );\r\n    }\r\n\r\n    parseSubscripts(\r\n      base: N.Expression,\r\n      startPos: number,\r\n      startLoc: Position,\r\n      noCalls?: ?boolean,\r\n    ): N.Expression {\r\n      if (\r\n        base.type === \"Identifier\" &&\r\n        base.name === \"غير_متزامن\" &&\r\n        this.state.noArrowAt.indexOf(startPos) !== -1\r\n      ) {\r\n        this.next();\r\n\r\n        const node = this.startNodeAt(startPos, startLoc);\r\n        node.callee = base;\r\n        node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\r\n        base = this.finishNode(node, \"CallExpression\");\r\n      } else if (\r\n        base.type === \"Identifier\" &&\r\n        base.name === \"غير_متزامن\" &&\r\n        this.isRelational(\"<\")\r\n      ) {\r\n        const state = this.state.clone();\r\n        let error;\r\n        try {\r\n          const node = this.parseAsyncArrowWithTypeParameters(\r\n            startPos,\r\n            startLoc,\r\n          );\r\n          if (node) return node;\r\n        } catch (e) {\r\n          error = e;\r\n        }\r\n\r\n        this.state = state;\r\n        try {\r\n          return super.parseSubscripts(base, startPos, startLoc, noCalls);\r\n        } catch (e) {\r\n          throw error || e;\r\n        }\r\n      }\r\n\r\n      return super.parseSubscripts(base, startPos, startLoc, noCalls);\r\n    }\r\n\r\n    parseSubscript(\r\n      base: N.Expression,\r\n      startPos: number,\r\n      startLoc: Position,\r\n      noCalls: ?boolean,\r\n      subscriptState: N.ParseSubscriptState,\r\n      maybeAsyncArrow: boolean,\r\n    ): N.Expression {\r\n      if (this.match(tt.questionDot) && this.isLookaheadRelational(\"<\")) {\r\n        this.expectPlugin(\"optionalChaining\");\r\n        subscriptState.optionalChainMember = true;\r\n        if (noCalls) {\r\n          subscriptState.stop = true;\r\n          return base;\r\n        }\r\n        this.next();\r\n        const node: N.OptionalCallExpression = this.startNodeAt(\r\n          startPos,\r\n          startLoc,\r\n        );\r\n        node.callee = base;\r\n        node.typeArguments = this.flowParseTypeParameterInstantiation();\r\n        this.expect(tt.parenL);\r\n        // $FlowFixMe\r\n        node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\r\n        node.optional = true;\r\n        return this.finishNode(node, \"OptionalCallExpression\");\r\n      } else if (\r\n        !noCalls &&\r\n        this.shouldParseTypes() &&\r\n        this.isRelational(\"<\")\r\n      ) {\r\n        const node = this.startNodeAt(startPos, startLoc);\r\n        node.callee = base;\r\n        const state = this.state.clone();\r\n        try {\r\n          node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\r\n          this.expect(tt.parenL);\r\n          node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\r\n          if (subscriptState.optionalChainMember) {\r\n            node.optional = false;\r\n            return this.finishNode(node, \"OptionalCallExpression\");\r\n          }\r\n          return this.finishNode(node, \"CallExpression\");\r\n        } catch (e) {\r\n          if (e instanceof SyntaxError) {\r\n            this.state = state;\r\n          } else {\r\n            throw e;\r\n          }\r\n        }\r\n      }\r\n\r\n      return super.parseSubscript(\r\n        base,\r\n        startPos,\r\n        startLoc,\r\n        noCalls,\r\n        subscriptState,\r\n        maybeAsyncArrow,\r\n      );\r\n    }\r\n\r\n    parseNewArguments(node: N.NewExpression): void {\r\n      let targs = null;\r\n      if (this.shouldParseTypes() && this.isRelational(\"<\")) {\r\n        const state = this.state.clone();\r\n        try {\r\n          targs = this.flowParseTypeParameterInstantiationCallOrNew();\r\n        } catch (e) {\r\n          if (e instanceof SyntaxError) {\r\n            this.state = state;\r\n          } else {\r\n            throw e;\r\n          }\r\n        }\r\n      }\r\n      node.typeArguments = targs;\r\n\r\n      super.parseNewArguments(node);\r\n    }\r\n\r\n    parseAsyncArrowWithTypeParameters(\r\n      startPos: number,\r\n      startLoc: Position,\r\n    ): ?N.ArrowFunctionExpression {\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n      this.parseFunctionParams(node);\r\n      if (!this.parseArrow(node)) return;\r\n      return this.parseArrowExpression(\r\n        node,\r\n        /* params */ undefined,\r\n        /* isAsync */ true,\r\n      );\r\n    }\r\n\r\n    readToken_mult_modulo(code: number): void {\r\n      const next = this.input.charCodeAt(this.state.pos + 1);\r\n      if (\r\n        code === charCodes.asterisk &&\r\n        next === charCodes.slash &&\r\n        this.state.hasFlowComment\r\n      ) {\r\n        this.state.hasFlowComment = false;\r\n        this.state.pos += 2;\r\n        this.nextToken();\r\n        return;\r\n      }\r\n\r\n      super.readToken_mult_modulo(code);\r\n    }\r\n\r\n    readToken_pipe_amp(code: number): void {\r\n      const next = this.input.charCodeAt(this.state.pos + 1);\r\n      if (\r\n        code === charCodes.verticalBar &&\r\n        next === charCodes.rightCurlyBrace\r\n      ) {\r\n        // '|}'\r\n        this.finishOp(tt.braceBarR, 2);\r\n        return;\r\n      }\r\n\r\n      super.readToken_pipe_amp(code);\r\n    }\r\n\r\n    parseTopLevel(file: N.File, program: N.Program): N.File {\r\n      const fileNode = super.parseTopLevel(file, program);\r\n      if (this.state.hasFlowComment) {\r\n        this.unexpected(null, \"Unterminated flow-comment\");\r\n      }\r\n      return fileNode;\r\n    }\r\n\r\n    skipBlockComment(): void {\r\n      if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\r\n        if (this.state.hasFlowComment) {\r\n          this.unexpected(\r\n            null,\r\n            \"Cannot have a flow comment inside another flow comment\",\r\n          );\r\n        }\r\n        this.hasFlowCommentCompletion();\r\n        this.state.pos += this.skipFlowComment();\r\n        this.state.hasFlowComment = true;\r\n        return;\r\n      }\r\n\r\n      if (this.state.hasFlowComment) {\r\n        const end = this.input.indexOf(\"*-/\", (this.state.pos += 2));\r\n        if (end === -1) this.raise(this.state.pos - 2, \"Unterminated comment\");\r\n        this.state.pos = end + 3;\r\n        return;\r\n      }\r\n\r\n      super.skipBlockComment();\r\n    }\r\n\r\n    skipFlowComment(): number | boolean {\r\n      const { pos } = this.state;\r\n      let shiftToFirstNonWhiteSpace = 2;\r\n      while (\r\n        [charCodes.space, charCodes.tab].includes(\r\n          this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace),\r\n        )\r\n      ) {\r\n        shiftToFirstNonWhiteSpace++;\r\n      }\r\n\r\n      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\r\n      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\r\n\r\n      if (ch2 === charCodes.colon && ch3 === charCodes.colon) {\r\n        return shiftToFirstNonWhiteSpace + 2; // check for /*::\r\n      }\r\n      if (\r\n        this.input.slice(\r\n          shiftToFirstNonWhiteSpace + pos,\r\n          shiftToFirstNonWhiteSpace + pos + 12,\r\n        ) === \"flow-include\"\r\n      ) {\r\n        return shiftToFirstNonWhiteSpace + 12; // check for /*flow-include\r\n      }\r\n      if (ch2 === charCodes.colon && ch3 !== charCodes.colon) {\r\n        return shiftToFirstNonWhiteSpace; // check for /*:, advance up to :\r\n      }\r\n      return false;\r\n    }\r\n\r\n    hasFlowCommentCompletion(): void {\r\n      const end = this.input.indexOf(\"*/\", this.state.pos);\r\n      if (end === -1) {\r\n        this.raise(this.state.pos, \"Unterminated comment\");\r\n      }\r\n    }\r\n  };\r\n","// @flow\r\n\r\nconst entities: { [name: string]: string } = {\r\n  quot: \"\\u0022\",\r\n  amp: \"&\",\r\n  apos: \"\\u0027\",\r\n  lt: \"<\",\r\n  gt: \">\",\r\n  nbsp: \"\\u00A0\",\r\n  iexcl: \"\\u00A1\",\r\n  cent: \"\\u00A2\",\r\n  pound: \"\\u00A3\",\r\n  curren: \"\\u00A4\",\r\n  yen: \"\\u00A5\",\r\n  brvbar: \"\\u00A6\",\r\n  sect: \"\\u00A7\",\r\n  uml: \"\\u00A8\",\r\n  copy: \"\\u00A9\",\r\n  ordf: \"\\u00AA\",\r\n  laquo: \"\\u00AB\",\r\n  not: \"\\u00AC\",\r\n  shy: \"\\u00AD\",\r\n  reg: \"\\u00AE\",\r\n  macr: \"\\u00AF\",\r\n  deg: \"\\u00B0\",\r\n  plusmn: \"\\u00B1\",\r\n  sup2: \"\\u00B2\",\r\n  sup3: \"\\u00B3\",\r\n  acute: \"\\u00B4\",\r\n  micro: \"\\u00B5\",\r\n  para: \"\\u00B6\",\r\n  middot: \"\\u00B7\",\r\n  cedil: \"\\u00B8\",\r\n  sup1: \"\\u00B9\",\r\n  ordm: \"\\u00BA\",\r\n  raquo: \"\\u00BB\",\r\n  frac14: \"\\u00BC\",\r\n  frac12: \"\\u00BD\",\r\n  frac34: \"\\u00BE\",\r\n  iquest: \"\\u00BF\",\r\n  Agrave: \"\\u00C0\",\r\n  Aacute: \"\\u00C1\",\r\n  Acirc: \"\\u00C2\",\r\n  Atilde: \"\\u00C3\",\r\n  Auml: \"\\u00C4\",\r\n  Aring: \"\\u00C5\",\r\n  AElig: \"\\u00C6\",\r\n  Ccedil: \"\\u00C7\",\r\n  Egrave: \"\\u00C8\",\r\n  Eacute: \"\\u00C9\",\r\n  Ecirc: \"\\u00CA\",\r\n  Euml: \"\\u00CB\",\r\n  Igrave: \"\\u00CC\",\r\n  Iacute: \"\\u00CD\",\r\n  Icirc: \"\\u00CE\",\r\n  Iuml: \"\\u00CF\",\r\n  ETH: \"\\u00D0\",\r\n  Ntilde: \"\\u00D1\",\r\n  Ograve: \"\\u00D2\",\r\n  Oacute: \"\\u00D3\",\r\n  Ocirc: \"\\u00D4\",\r\n  Otilde: \"\\u00D5\",\r\n  Ouml: \"\\u00D6\",\r\n  times: \"\\u00D7\",\r\n  Oslash: \"\\u00D8\",\r\n  Ugrave: \"\\u00D9\",\r\n  Uacute: \"\\u00DA\",\r\n  Ucirc: \"\\u00DB\",\r\n  Uuml: \"\\u00DC\",\r\n  Yacute: \"\\u00DD\",\r\n  THORN: \"\\u00DE\",\r\n  szlig: \"\\u00DF\",\r\n  agrave: \"\\u00E0\",\r\n  aacute: \"\\u00E1\",\r\n  acirc: \"\\u00E2\",\r\n  atilde: \"\\u00E3\",\r\n  auml: \"\\u00E4\",\r\n  aring: \"\\u00E5\",\r\n  aelig: \"\\u00E6\",\r\n  ccedil: \"\\u00E7\",\r\n  egrave: \"\\u00E8\",\r\n  eacute: \"\\u00E9\",\r\n  ecirc: \"\\u00EA\",\r\n  euml: \"\\u00EB\",\r\n  igrave: \"\\u00EC\",\r\n  iacute: \"\\u00ED\",\r\n  icirc: \"\\u00EE\",\r\n  iuml: \"\\u00EF\",\r\n  eth: \"\\u00F0\",\r\n  ntilde: \"\\u00F1\",\r\n  ograve: \"\\u00F2\",\r\n  oacute: \"\\u00F3\",\r\n  ocirc: \"\\u00F4\",\r\n  otilde: \"\\u00F5\",\r\n  ouml: \"\\u00F6\",\r\n  divide: \"\\u00F7\",\r\n  oslash: \"\\u00F8\",\r\n  ugrave: \"\\u00F9\",\r\n  uacute: \"\\u00FA\",\r\n  ucirc: \"\\u00FB\",\r\n  uuml: \"\\u00FC\",\r\n  yacute: \"\\u00FD\",\r\n  thorn: \"\\u00FE\",\r\n  yuml: \"\\u00FF\",\r\n  OElig: \"\\u0152\",\r\n  oelig: \"\\u0153\",\r\n  Scaron: \"\\u0160\",\r\n  scaron: \"\\u0161\",\r\n  Yuml: \"\\u0178\",\r\n  fnof: \"\\u0192\",\r\n  circ: \"\\u02C6\",\r\n  tilde: \"\\u02DC\",\r\n  Alpha: \"\\u0391\",\r\n  Beta: \"\\u0392\",\r\n  Gamma: \"\\u0393\",\r\n  Delta: \"\\u0394\",\r\n  Epsilon: \"\\u0395\",\r\n  Zeta: \"\\u0396\",\r\n  Eta: \"\\u0397\",\r\n  Theta: \"\\u0398\",\r\n  Iota: \"\\u0399\",\r\n  Kappa: \"\\u039A\",\r\n  Lambda: \"\\u039B\",\r\n  Mu: \"\\u039C\",\r\n  Nu: \"\\u039D\",\r\n  Xi: \"\\u039E\",\r\n  Omicron: \"\\u039F\",\r\n  Pi: \"\\u03A0\",\r\n  Rho: \"\\u03A1\",\r\n  Sigma: \"\\u03A3\",\r\n  Tau: \"\\u03A4\",\r\n  Upsilon: \"\\u03A5\",\r\n  Phi: \"\\u03A6\",\r\n  Chi: \"\\u03A7\",\r\n  Psi: \"\\u03A8\",\r\n  Omega: \"\\u03A9\",\r\n  alpha: \"\\u03B1\",\r\n  beta: \"\\u03B2\",\r\n  gamma: \"\\u03B3\",\r\n  delta: \"\\u03B4\",\r\n  epsilon: \"\\u03B5\",\r\n  zeta: \"\\u03B6\",\r\n  eta: \"\\u03B7\",\r\n  theta: \"\\u03B8\",\r\n  iota: \"\\u03B9\",\r\n  kappa: \"\\u03BA\",\r\n  lambda: \"\\u03BB\",\r\n  mu: \"\\u03BC\",\r\n  nu: \"\\u03BD\",\r\n  xi: \"\\u03BE\",\r\n  omicron: \"\\u03BF\",\r\n  pi: \"\\u03C0\",\r\n  rho: \"\\u03C1\",\r\n  sigmaf: \"\\u03C2\",\r\n  sigma: \"\\u03C3\",\r\n  tau: \"\\u03C4\",\r\n  upsilon: \"\\u03C5\",\r\n  phi: \"\\u03C6\",\r\n  chi: \"\\u03C7\",\r\n  psi: \"\\u03C8\",\r\n  omega: \"\\u03C9\",\r\n  thetasym: \"\\u03D1\",\r\n  upsih: \"\\u03D2\",\r\n  piv: \"\\u03D6\",\r\n  ensp: \"\\u2002\",\r\n  emsp: \"\\u2003\",\r\n  thinsp: \"\\u2009\",\r\n  zwnj: \"\\u200C\",\r\n  zwj: \"\\u200D\",\r\n  lrm: \"\\u200E\",\r\n  rlm: \"\\u200F\",\r\n  ndash: \"\\u2013\",\r\n  mdash: \"\\u2014\",\r\n  lsquo: \"\\u2018\",\r\n  rsquo: \"\\u2019\",\r\n  sbquo: \"\\u201A\",\r\n  ldquo: \"\\u201C\",\r\n  rdquo: \"\\u201D\",\r\n  bdquo: \"\\u201E\",\r\n  dagger: \"\\u2020\",\r\n  Dagger: \"\\u2021\",\r\n  bull: \"\\u2022\",\r\n  hellip: \"\\u2026\",\r\n  permil: \"\\u2030\",\r\n  prime: \"\\u2032\",\r\n  Prime: \"\\u2033\",\r\n  lsaquo: \"\\u2039\",\r\n  rsaquo: \"\\u203A\",\r\n  oline: \"\\u203E\",\r\n  frasl: \"\\u2044\",\r\n  euro: \"\\u20AC\",\r\n  image: \"\\u2111\",\r\n  weierp: \"\\u2118\",\r\n  real: \"\\u211C\",\r\n  trade: \"\\u2122\",\r\n  alefsym: \"\\u2135\",\r\n  larr: \"\\u2190\",\r\n  uarr: \"\\u2191\",\r\n  rarr: \"\\u2192\",\r\n  darr: \"\\u2193\",\r\n  harr: \"\\u2194\",\r\n  crarr: \"\\u21B5\",\r\n  lArr: \"\\u21D0\",\r\n  uArr: \"\\u21D1\",\r\n  rArr: \"\\u21D2\",\r\n  dArr: \"\\u21D3\",\r\n  hArr: \"\\u21D4\",\r\n  forall: \"\\u2200\",\r\n  part: \"\\u2202\",\r\n  exist: \"\\u2203\",\r\n  empty: \"\\u2205\",\r\n  nabla: \"\\u2207\",\r\n  isin: \"\\u2208\",\r\n  notin: \"\\u2209\",\r\n  ni: \"\\u220B\",\r\n  prod: \"\\u220F\",\r\n  sum: \"\\u2211\",\r\n  minus: \"\\u2212\",\r\n  lowast: \"\\u2217\",\r\n  radic: \"\\u221A\",\r\n  prop: \"\\u221D\",\r\n  infin: \"\\u221E\",\r\n  ang: \"\\u2220\",\r\n  and: \"\\u2227\",\r\n  or: \"\\u2228\",\r\n  cap: \"\\u2229\",\r\n  cup: \"\\u222A\",\r\n  int: \"\\u222B\",\r\n  there4: \"\\u2234\",\r\n  sim: \"\\u223C\",\r\n  cong: \"\\u2245\",\r\n  asymp: \"\\u2248\",\r\n  ne: \"\\u2260\",\r\n  equiv: \"\\u2261\",\r\n  le: \"\\u2264\",\r\n  ge: \"\\u2265\",\r\n  sub: \"\\u2282\",\r\n  sup: \"\\u2283\",\r\n  nsub: \"\\u2284\",\r\n  sube: \"\\u2286\",\r\n  supe: \"\\u2287\",\r\n  oplus: \"\\u2295\",\r\n  otimes: \"\\u2297\",\r\n  perp: \"\\u22A5\",\r\n  sdot: \"\\u22C5\",\r\n  lceil: \"\\u2308\",\r\n  rceil: \"\\u2309\",\r\n  lfloor: \"\\u230A\",\r\n  rfloor: \"\\u230B\",\r\n  lang: \"\\u2329\",\r\n  rang: \"\\u232A\",\r\n  loz: \"\\u25CA\",\r\n  spades: \"\\u2660\",\r\n  clubs: \"\\u2663\",\r\n  hearts: \"\\u2665\",\r\n  diams: \"\\u2666\",\r\n};\r\nexport default entities;\r\n","// @flow\r\n\r\nimport * as charCodes from \"charcodes\";\r\n\r\nimport XHTMLEntities from \"./xhtml\";\r\nimport type Parser from \"../../parser\";\r\nimport { TokenType, types as tt } from \"../../tokenizer/types\";\r\nimport { TokContext, types as tc } from \"../../tokenizer/context\";\r\nimport * as N from \"../../types\";\r\nimport { isIdentifierChar, isIdentifierStart } from \"../../util/identifier\";\r\nimport type { Pos, Position } from \"../../util/location\";\r\nimport { isNewLine } from \"../../util/whitespace\";\r\n\r\nconst HEX_NUMBER = /^[\\da-fA-F]+$/;\r\nconst DECIMAL_NUMBER = /^\\d+$/;\r\n\r\n// Be aware that this file is always executed and not only when the plugin is enabled.\r\n// Therefore this contexts and tokens do always exist.\r\ntc.j_oTag = new TokContext(\"<tag\", false);\r\ntc.j_cTag = new TokContext(\"</tag\", false);\r\ntc.j_expr = new TokContext(\"<tag>...</tag>\", true, true);\r\n\r\ntt.jsxName = new TokenType(\"jsxName\");\r\ntt.jsxText = new TokenType(\"jsxText\", { beforeExpr: true });\r\ntt.jsxTagStart = new TokenType(\"jsxTagStart\", { startsExpr: true });\r\ntt.jsxTagEnd = new TokenType(\"jsxTagEnd\");\r\n\r\ntt.jsxTagStart.updateContext = function() {\r\n  this.state.context.push(tc.j_expr); // treat as beginning of JSX expression\r\n  this.state.context.push(tc.j_oTag); // start opening tag context\r\n  this.state.exprAllowed = false;\r\n};\r\n\r\ntt.jsxTagEnd.updateContext = function(prevType) {\r\n  const out = this.state.context.pop();\r\n  if ((out === tc.j_oTag && prevType === tt.slash) || out === tc.j_cTag) {\r\n    this.state.context.pop();\r\n    this.state.exprAllowed = this.curContext() === tc.j_expr;\r\n  } else {\r\n    this.state.exprAllowed = true;\r\n  }\r\n};\r\n\r\nfunction isFragment(object: ?N.JSXElement): boolean {\r\n  return object\r\n    ? object.type === \"JSXOpeningFragment\" ||\r\n        object.type === \"JSXClosingFragment\"\r\n    : false;\r\n}\r\n\r\n// Transforms JSX element name to string.\r\n\r\nfunction getQualifiedJSXName(\r\n  object: N.JSXIdentifier | N.JSXNamespacedName | N.JSXMemberExpression,\r\n): string {\r\n  if (object.type === \"JSXIdentifier\") {\r\n    return object.name;\r\n  }\r\n\r\n  if (object.type === \"JSXNamespacedName\") {\r\n    return object.namespace.name + \":\" + object.name.name;\r\n  }\r\n\r\n  if (object.type === \"JSXMemberExpression\") {\r\n    return (\r\n      getQualifiedJSXName(object.object) +\r\n      \".\" +\r\n      getQualifiedJSXName(object.property)\r\n    );\r\n  }\r\n\r\n  // istanbul ignore next\r\n  throw new Error(\"Node had unexpected type: \" + object.type);\r\n}\r\n\r\nexport default (superClass: Class<Parser>): Class<Parser> =>\r\n  class extends superClass {\r\n    // Reads inline JSX contents token.\r\n\r\n    jsxReadToken(): void {\r\n      let out = \"\";\r\n      let chunkStart = this.state.pos;\r\n      for (;;) {\r\n        if (this.state.pos >= this.length) {\r\n          this.raise(this.state.start, \"Unterminated JSX contents\");\r\n        }\r\n\r\n        const ch = this.input.charCodeAt(this.state.pos);\r\n\r\n        switch (ch) {\r\n          case charCodes.lessThan:\r\n          case charCodes.leftCurlyBrace:\r\n            if (this.state.pos === this.state.start) {\r\n              if (ch === charCodes.lessThan && this.state.exprAllowed) {\r\n                ++this.state.pos;\r\n                return this.finishToken(tt.jsxTagStart);\r\n              }\r\n              return super.getTokenFromCode(ch);\r\n            }\r\n            out += this.input.slice(chunkStart, this.state.pos);\r\n            return this.finishToken(tt.jsxText, out);\r\n\r\n          case charCodes.ampersand:\r\n            out += this.input.slice(chunkStart, this.state.pos);\r\n            out += this.jsxReadEntity();\r\n            chunkStart = this.state.pos;\r\n            break;\r\n\r\n          default:\r\n            if (isNewLine(ch)) {\r\n              out += this.input.slice(chunkStart, this.state.pos);\r\n              out += this.jsxReadNewLine(true);\r\n              chunkStart = this.state.pos;\r\n            } else {\r\n              ++this.state.pos;\r\n            }\r\n        }\r\n      }\r\n    }\r\n\r\n    jsxReadNewLine(normalizeCRLF: boolean): string {\r\n      const ch = this.input.charCodeAt(this.state.pos);\r\n      let out;\r\n      ++this.state.pos;\r\n      if (\r\n        ch === charCodes.carriageReturn &&\r\n        this.input.charCodeAt(this.state.pos) === charCodes.lineFeed\r\n      ) {\r\n        ++this.state.pos;\r\n        out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\r\n      } else {\r\n        out = String.fromCharCode(ch);\r\n      }\r\n      ++this.state.curLine;\r\n      this.state.lineStart = this.state.pos;\r\n\r\n      return out;\r\n    }\r\n\r\n    jsxReadString(quote: number): void {\r\n      let out = \"\";\r\n      let chunkStart = ++this.state.pos;\r\n      for (;;) {\r\n        if (this.state.pos >= this.length) {\r\n          this.raise(this.state.start, \"Unterminated string constant\");\r\n        }\r\n\r\n        const ch = this.input.charCodeAt(this.state.pos);\r\n        if (ch === quote) break;\r\n        if (ch === charCodes.ampersand) {\r\n          out += this.input.slice(chunkStart, this.state.pos);\r\n          out += this.jsxReadEntity();\r\n          chunkStart = this.state.pos;\r\n        } else if (isNewLine(ch)) {\r\n          out += this.input.slice(chunkStart, this.state.pos);\r\n          out += this.jsxReadNewLine(false);\r\n          chunkStart = this.state.pos;\r\n        } else {\r\n          ++this.state.pos;\r\n        }\r\n      }\r\n      out += this.input.slice(chunkStart, this.state.pos++);\r\n      return this.finishToken(tt.string, out);\r\n    }\r\n\r\n    jsxReadEntity(): string {\r\n      let str = \"\";\r\n      let count = 0;\r\n      let entity;\r\n      let ch = this.input[this.state.pos];\r\n\r\n      const startPos = ++this.state.pos;\r\n      while (this.state.pos < this.length && count++ < 10) {\r\n        ch = this.input[this.state.pos++];\r\n        if (ch === \";\") {\r\n          if (str[0] === \"#\") {\r\n            if (str[1] === \"x\") {\r\n              str = str.substr(2);\r\n              if (HEX_NUMBER.test(str)) {\r\n                entity = String.fromCodePoint(parseInt(str, 16));\r\n              }\r\n            } else {\r\n              str = str.substr(1);\r\n              if (DECIMAL_NUMBER.test(str)) {\r\n                entity = String.fromCodePoint(parseInt(str, 10));\r\n              }\r\n            }\r\n          } else {\r\n            entity = XHTMLEntities[str];\r\n          }\r\n          break;\r\n        }\r\n        str += ch;\r\n      }\r\n      if (!entity) {\r\n        this.state.pos = startPos;\r\n        return \"&\";\r\n      }\r\n      return entity;\r\n    }\r\n\r\n    // Read a JSX identifier (valid tag or attribute name).\r\n    //\r\n    // Optimized version since JSX identifiers can\"t contain\r\n    // escape characters and so can be read as single slice.\r\n    // Also assumes that first character was already checked\r\n    // by isIdentifierStart in readToken.\r\n\r\n    jsxReadWord(): void {\r\n      let ch;\r\n      const start = this.state.pos;\r\n      do {\r\n        ch = this.input.charCodeAt(++this.state.pos);\r\n      } while (isIdentifierChar(ch) || ch === charCodes.dash);\r\n      return this.finishToken(\r\n        tt.jsxName,\r\n        this.input.slice(start, this.state.pos),\r\n      );\r\n    }\r\n\r\n    // Parse next token as JSX identifier\r\n\r\n    jsxParseIdentifier(): N.JSXIdentifier {\r\n      const node = this.startNode();\r\n      if (this.match(tt.jsxName)) {\r\n        node.name = this.state.value;\r\n      } else if (this.state.type.keyword) {\r\n        node.name = this.state.type.keyword;\r\n      } else {\r\n        this.unexpected();\r\n      }\r\n      this.next();\r\n      return this.finishNode(node, \"JSXIdentifier\");\r\n    }\r\n\r\n    // Parse namespaced identifier.\r\n\r\n    jsxParseNamespacedName(): N.JSXNamespacedName {\r\n      const startPos = this.state.start;\r\n      const startLoc = this.state.startLoc;\r\n      const name = this.jsxParseIdentifier();\r\n      if (!this.eat(tt.colon)) return name;\r\n\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n      node.namespace = name;\r\n      node.name = this.jsxParseIdentifier();\r\n      return this.finishNode(node, \"JSXNamespacedName\");\r\n    }\r\n\r\n    // Parses element name in any form - namespaced, member\r\n    // or single identifier.\r\n\r\n    jsxParseElementName(): N.JSXNamespacedName | N.JSXMemberExpression {\r\n      const startPos = this.state.start;\r\n      const startLoc = this.state.startLoc;\r\n      let node = this.jsxParseNamespacedName();\r\n      while (this.eat(tt.dot)) {\r\n        const newNode = this.startNodeAt(startPos, startLoc);\r\n        newNode.object = node;\r\n        newNode.property = this.jsxParseIdentifier();\r\n        node = this.finishNode(newNode, \"JSXMemberExpression\");\r\n      }\r\n      return node;\r\n    }\r\n\r\n    // Parses any type of JSX attribute value.\r\n\r\n    jsxParseAttributeValue(): N.Expression {\r\n      let node;\r\n      switch (this.state.type) {\r\n        case tt.braceL:\r\n          node = this.startNode();\r\n          this.next();\r\n          node = this.jsxParseExpressionContainer(node);\r\n          if (node.expression.type === \"JSXEmptyExpression\") {\r\n            throw this.raise(\r\n              node.start,\r\n              \"JSX attributes must only be assigned a non-empty expression\",\r\n            );\r\n          } else {\r\n            return node;\r\n          }\r\n\r\n        case tt.jsxTagStart:\r\n        case tt.string:\r\n          return this.parseExprAtom();\r\n\r\n        default:\r\n          throw this.raise(\r\n            this.state.start,\r\n            \"JSX value should be either an expression or a quoted JSX text\",\r\n          );\r\n      }\r\n    }\r\n\r\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\r\n    // and so it should start at the end of last read token (left brace) and finish\r\n    // at the beginning of the next one (right brace).\r\n\r\n    jsxParseEmptyExpression(): N.JSXEmptyExpression {\r\n      const node = this.startNodeAt(\r\n        this.state.lastTokEnd,\r\n        this.state.lastTokEndLoc,\r\n      );\r\n      return this.finishNodeAt(\r\n        node,\r\n        \"JSXEmptyExpression\",\r\n        this.state.start,\r\n        this.state.startLoc,\r\n      );\r\n    }\r\n\r\n    // Parse JSX spread child\r\n\r\n    jsxParseSpreadChild(node: N.JSXSpreadChild): N.JSXSpreadChild {\r\n      this.next(); // ellipsis\r\n      node.expression = this.parseExpression();\r\n      this.expect(tt.braceR);\r\n\r\n      return this.finishNode(node, \"JSXSpreadChild\");\r\n    }\r\n\r\n    // Parses JSX expression enclosed into curly brackets.\r\n\r\n    jsxParseExpressionContainer(\r\n      node: N.JSXExpressionContainer,\r\n    ): N.JSXExpressionContainer {\r\n      if (this.match(tt.braceR)) {\r\n        node.expression = this.jsxParseEmptyExpression();\r\n      } else {\r\n        node.expression = this.parseExpression();\r\n      }\r\n      this.expect(tt.braceR);\r\n      return this.finishNode(node, \"JSXExpressionContainer\");\r\n    }\r\n\r\n    // Parses following JSX attribute name-value pair.\r\n\r\n    jsxParseAttribute(): N.JSXAttribute {\r\n      const node = this.startNode();\r\n      if (this.eat(tt.braceL)) {\r\n        this.expect(tt.ellipsis);\r\n        node.argument = this.parseMaybeAssign();\r\n        this.expect(tt.braceR);\r\n        return this.finishNode(node, \"JSXSpreadAttribute\");\r\n      }\r\n      node.name = this.jsxParseNamespacedName();\r\n      node.value = this.eat(tt.eq) ? this.jsxParseAttributeValue() : null;\r\n      return this.finishNode(node, \"JSXAttribute\");\r\n    }\r\n\r\n    // Parses JSX opening tag starting after \"<\".\r\n\r\n    jsxParseOpeningElementAt(\r\n      startPos: number,\r\n      startLoc: Position,\r\n    ): N.JSXOpeningElement {\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n      if (this.match(tt.jsxTagEnd)) {\r\n        this.expect(tt.jsxTagEnd);\r\n        return this.finishNode(node, \"JSXOpeningFragment\");\r\n      }\r\n      node.name = this.jsxParseElementName();\r\n      return this.jsxParseOpeningElementAfterName(node);\r\n    }\r\n\r\n    jsxParseOpeningElementAfterName(\r\n      node: N.JSXOpeningElement,\r\n    ): N.JSXOpeningElement {\r\n      const attributes: N.JSXAttribute[] = [];\r\n      while (!this.match(tt.slash) && !this.match(tt.jsxTagEnd)) {\r\n        attributes.push(this.jsxParseAttribute());\r\n      }\r\n      node.attributes = attributes;\r\n      node.selfClosing = this.eat(tt.slash);\r\n      this.expect(tt.jsxTagEnd);\r\n      return this.finishNode(node, \"JSXOpeningElement\");\r\n    }\r\n\r\n    // Parses JSX closing tag starting after \"</\".\r\n\r\n    jsxParseClosingElementAt(\r\n      startPos: number,\r\n      startLoc: Position,\r\n    ): N.JSXClosingElement {\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n      if (this.match(tt.jsxTagEnd)) {\r\n        this.expect(tt.jsxTagEnd);\r\n        return this.finishNode(node, \"JSXClosingFragment\");\r\n      }\r\n      node.name = this.jsxParseElementName();\r\n      this.expect(tt.jsxTagEnd);\r\n      return this.finishNode(node, \"JSXClosingElement\");\r\n    }\r\n\r\n    // Parses entire JSX element, including it\"s opening tag\r\n    // (starting after \"<\"), attributes, contents and closing tag.\r\n\r\n    jsxParseElementAt(startPos: number, startLoc: Position): N.JSXElement {\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n      const children = [];\r\n      const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\r\n      let closingElement = null;\r\n\r\n      if (!openingElement.selfClosing) {\r\n        contents: for (;;) {\r\n          switch (this.state.type) {\r\n            case tt.jsxTagStart:\r\n              startPos = this.state.start;\r\n              startLoc = this.state.startLoc;\r\n              this.next();\r\n              if (this.eat(tt.slash)) {\r\n                closingElement = this.jsxParseClosingElementAt(\r\n                  startPos,\r\n                  startLoc,\r\n                );\r\n                break contents;\r\n              }\r\n              children.push(this.jsxParseElementAt(startPos, startLoc));\r\n              break;\r\n\r\n            case tt.jsxText:\r\n              children.push(this.parseExprAtom());\r\n              break;\r\n\r\n            case tt.braceL: {\r\n              const node = this.startNode();\r\n              this.next();\r\n              if (this.match(tt.ellipsis)) {\r\n                children.push(this.jsxParseSpreadChild(node));\r\n              } else {\r\n                children.push(this.jsxParseExpressionContainer(node));\r\n              }\r\n\r\n              break;\r\n            }\r\n            // istanbul ignore next - should never happen\r\n            default:\r\n              throw this.unexpected();\r\n          }\r\n        }\r\n\r\n        if (isFragment(openingElement) && !isFragment(closingElement)) {\r\n          this.raise(\r\n            // $FlowIgnore\r\n            closingElement.start,\r\n            \"Expected corresponding JSX closing tag for <>\",\r\n          );\r\n        } else if (!isFragment(openingElement) && isFragment(closingElement)) {\r\n          this.raise(\r\n            // $FlowIgnore\r\n            closingElement.start,\r\n            \"Expected corresponding JSX closing tag for <\" +\r\n              getQualifiedJSXName(openingElement.name) +\r\n              \">\",\r\n          );\r\n        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\r\n          if (\r\n            // $FlowIgnore\r\n            getQualifiedJSXName(closingElement.name) !==\r\n            getQualifiedJSXName(openingElement.name)\r\n          ) {\r\n            this.raise(\r\n              // $FlowIgnore\r\n              closingElement.start,\r\n              \"Expected corresponding JSX closing tag for <\" +\r\n                getQualifiedJSXName(openingElement.name) +\r\n                \">\",\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      if (isFragment(openingElement)) {\r\n        node.openingFragment = openingElement;\r\n        node.closingFragment = closingElement;\r\n      } else {\r\n        node.openingElement = openingElement;\r\n        node.closingElement = closingElement;\r\n      }\r\n      node.children = children;\r\n      if (this.match(tt.relational) && this.state.value === \"<\") {\r\n        this.raise(\r\n          this.state.start,\r\n          \"Adjacent JSX elements must be wrapped in an enclosing tag. \" +\r\n            \"Did you want a JSX fragment <>...</>?\",\r\n        );\r\n      }\r\n\r\n      return isFragment(openingElement)\r\n        ? this.finishNode(node, \"JSXFragment\")\r\n        : this.finishNode(node, \"JSXElement\");\r\n    }\r\n\r\n    // Parses entire JSX element from current position.\r\n\r\n    jsxParseElement(): N.JSXElement {\r\n      const startPos = this.state.start;\r\n      const startLoc = this.state.startLoc;\r\n      this.next();\r\n      return this.jsxParseElementAt(startPos, startLoc);\r\n    }\r\n\r\n    // ==================================\r\n    // Overrides\r\n    // ==================================\r\n\r\n    parseExprAtom(refShortHandDefaultPos: ?Pos): N.Expression {\r\n      if (this.match(tt.jsxText)) {\r\n        return this.parseLiteral(this.state.value, \"JSXText\");\r\n      } else if (this.match(tt.jsxTagStart)) {\r\n        return this.jsxParseElement();\r\n      } else if (\r\n        this.isRelational(\"<\") &&\r\n        this.input.charCodeAt(this.state.pos) !== charCodes.exclamationMark\r\n      ) {\r\n        // In case we encounter an lt token here it will always be the start of\r\n        // jsx as the lt sign is not allowed in places that expect an expression\r\n        this.finishToken(tt.jsxTagStart);\r\n        return this.jsxParseElement();\r\n      } else {\r\n        return super.parseExprAtom(refShortHandDefaultPos);\r\n      }\r\n    }\r\n\r\n    getTokenFromCode(code: number): void {\r\n      if (this.state.inPropertyName) return super.getTokenFromCode(code);\r\n\r\n      const context = this.curContext();\r\n\r\n      if (context === tc.j_expr) {\r\n        return this.jsxReadToken();\r\n      }\r\n\r\n      if (context === tc.j_oTag || context === tc.j_cTag) {\r\n        if (isIdentifierStart(code)) {\r\n          return this.jsxReadWord();\r\n        }\r\n\r\n        if (code === charCodes.greaterThan) {\r\n          ++this.state.pos;\r\n          return this.finishToken(tt.jsxTagEnd);\r\n        }\r\n\r\n        if (\r\n          (code === charCodes.quotationMark || code === charCodes.apostrophe) &&\r\n          context === tc.j_oTag\r\n        ) {\r\n          return this.jsxReadString(code);\r\n        }\r\n      }\r\n\r\n      if (\r\n        code === charCodes.lessThan &&\r\n        this.state.exprAllowed &&\r\n        this.input.charCodeAt(this.state.pos + 1) !== charCodes.exclamationMark\r\n      ) {\r\n        ++this.state.pos;\r\n        return this.finishToken(tt.jsxTagStart);\r\n      }\r\n\r\n      return super.getTokenFromCode(code);\r\n    }\r\n\r\n    updateContext(prevType: TokenType): void {\r\n      if (this.match(tt.braceL)) {\r\n        const curContext = this.curContext();\r\n        if (curContext === tc.j_oTag) {\r\n          this.state.context.push(tc.braceExpression);\r\n        } else if (curContext === tc.j_expr) {\r\n          this.state.context.push(tc.templateQuasi);\r\n        } else {\r\n          super.updateContext(prevType);\r\n        }\r\n        this.state.exprAllowed = true;\r\n      } else if (this.match(tt.slash) && prevType === tt.jsxTagStart) {\r\n        this.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore\r\n        this.state.context.push(tc.j_cTag); // reconsider as closing tag context\r\n        this.state.exprAllowed = false;\r\n      } else {\r\n        return super.updateContext(prevType);\r\n      }\r\n    }\r\n  };\r\n","// @flow\r\nimport {\r\n  SCOPE_ARROW,\r\n  SCOPE_ASYNC,\r\n  SCOPE_DIRECT_SUPER,\r\n  SCOPE_FUNCTION,\r\n  SCOPE_GENERATOR,\r\n  SCOPE_SIMPLE_CATCH,\r\n  SCOPE_SUPER,\r\n  SCOPE_PROGRAM,\r\n  SCOPE_VAR,\r\n  SCOPE_CLASS,\r\n  BIND_SCOPE_FUNCTION,\r\n  BIND_SCOPE_VAR,\r\n  BIND_SCOPE_LEXICAL,\r\n  BIND_KIND_VALUE,\r\n  type ScopeFlags,\r\n  type BindingTypes,\r\n} from \"./scopeflags\";\r\nimport * as N from \"../types\";\r\n\r\n// Start an AST node, attaching a start offset.\r\nexport class Scope {\r\n  flags: ScopeFlags;\r\n  // A list of var-declared names in the current lexical scope\r\n  var: string[] = [];\r\n  // A list of lexically-declared names in the current lexical scope\r\n  lexical: string[] = [];\r\n  // A list of lexically-declared FunctionDeclaration names in the current lexical scope\r\n  functions: string[] = [];\r\n\r\n  constructor(flags: ScopeFlags) {\r\n    this.flags = flags;\r\n  }\r\n}\r\n\r\ntype raiseFunction = (number, string) => void;\r\n\r\n// The functions in this module keep track of declared variables in the\r\n// current scope in order to detect duplicate variable names.\r\nexport default class ScopeHandler<IScope: Scope = Scope> {\r\n  scopeStack: Array<IScope> = [];\r\n  raise: raiseFunction;\r\n  inModule: boolean;\r\n  undefinedExports: Map<string, number> = new Map();\r\n\r\n  constructor(raise: raiseFunction, inModule: boolean) {\r\n    this.raise = raise;\r\n    this.inModule = inModule;\r\n  }\r\n\r\n  get inFunction() {\r\n    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\r\n  }\r\n  get inGenerator() {\r\n    return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;\r\n  }\r\n  get inAsync() {\r\n    return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;\r\n  }\r\n  get allowSuper() {\r\n    return (this.currentThisScope().flags & SCOPE_SUPER) > 0;\r\n  }\r\n  get allowDirectSuper() {\r\n    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\r\n  }\r\n  get inNonArrowFunction() {\r\n    return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;\r\n  }\r\n  get treatFunctionsAsVar() {\r\n    return this.treatFunctionsAsVarInScope(this.currentScope());\r\n  }\r\n\r\n  createScope(flags: ScopeFlags): Scope {\r\n    return new Scope(flags);\r\n  }\r\n  // This method will be overwritten by subclasses\r\n  +createScope: (flags: ScopeFlags) => IScope;\r\n\r\n  enter(flags: ScopeFlags) {\r\n    this.scopeStack.push(this.createScope(flags));\r\n  }\r\n\r\n  exit() {\r\n    this.scopeStack.pop();\r\n  }\r\n\r\n  // The spec says:\r\n  // > At the top level of a function, or script, function declarations are\r\n  // > treated like var declarations rather than like lexical declarations.\r\n  treatFunctionsAsVarInScope(scope: IScope): boolean {\r\n    return !!(\r\n      scope.flags & SCOPE_FUNCTION ||\r\n      (!this.inModule && scope.flags & SCOPE_PROGRAM)\r\n    );\r\n  }\r\n\r\n  declareName(name: string, bindingType: BindingTypes, pos: number) {\r\n    let scope = this.currentScope();\r\n    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {\r\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\r\n\r\n      if (bindingType & BIND_SCOPE_FUNCTION) {\r\n        scope.functions.push(name);\r\n      } else {\r\n        scope.lexical.push(name);\r\n      }\r\n\r\n      if (bindingType & BIND_SCOPE_LEXICAL) {\r\n        this.maybeExportDefined(scope, name);\r\n      }\r\n    } else if (bindingType & BIND_SCOPE_VAR) {\r\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\r\n        scope = this.scopeStack[i];\r\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\r\n        scope.var.push(name);\r\n        this.maybeExportDefined(scope, name);\r\n\r\n        if (scope.flags & SCOPE_VAR) break;\r\n      }\r\n    }\r\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\r\n      this.undefinedExports.delete(name);\r\n    }\r\n  }\r\n\r\n  maybeExportDefined(scope: IScope, name: string) {\r\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\r\n      this.undefinedExports.delete(name);\r\n    }\r\n  }\r\n\r\n  checkRedeclarationInScope(\r\n    scope: IScope,\r\n    name: string,\r\n    bindingType: BindingTypes,\r\n    pos: number,\r\n  ) {\r\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\r\n      this.raise(pos, `Identifier '${name}' has already been declared`);\r\n    }\r\n  }\r\n\r\n  isRedeclaredInScope(\r\n    scope: IScope,\r\n    name: string,\r\n    bindingType: BindingTypes,\r\n  ): boolean {\r\n    if (!(bindingType & BIND_KIND_VALUE)) return false;\r\n\r\n    if (bindingType & BIND_SCOPE_LEXICAL) {\r\n      return (\r\n        scope.lexical.indexOf(name) > -1 ||\r\n        scope.functions.indexOf(name) > -1 ||\r\n        scope.var.indexOf(name) > -1\r\n      );\r\n    }\r\n\r\n    if (bindingType & BIND_SCOPE_FUNCTION) {\r\n      return (\r\n        scope.lexical.indexOf(name) > -1 ||\r\n        (!this.treatFunctionsAsVarInScope(scope) &&\r\n          scope.var.indexOf(name) > -1)\r\n      );\r\n    }\r\n\r\n    return (\r\n      (scope.lexical.indexOf(name) > -1 &&\r\n        !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name)) ||\r\n      (!this.treatFunctionsAsVarInScope(scope) &&\r\n        scope.functions.indexOf(name) > -1)\r\n    );\r\n  }\r\n\r\n  checkLocalExport(id: N.Identifier) {\r\n    if (\r\n      this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\r\n      this.scopeStack[0].var.indexOf(id.name) === -1 &&\r\n      // In strict mode, scope.functions will always be empty.\r\n      // Modules are strict by default, but the `scriptMode` option\r\n      // can overwrite this behavior.\r\n      this.scopeStack[0].functions.indexOf(id.name) === -1\r\n    ) {\r\n      this.undefinedExports.set(id.name, id.start);\r\n    }\r\n  }\r\n\r\n  currentScope(): IScope {\r\n    return this.scopeStack[this.scopeStack.length - 1];\r\n  }\r\n\r\n  // $FlowIgnore\r\n  currentVarScope(): IScope {\r\n    for (let i = this.scopeStack.length - 1; ; i--) {\r\n      const scope = this.scopeStack[i];\r\n      if (scope.flags & SCOPE_VAR) {\r\n        return scope;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\r\n  // $FlowIgnore\r\n  currentThisScope(): IScope {\r\n    for (let i = this.scopeStack.length - 1; ; i--) {\r\n      const scope = this.scopeStack[i];\r\n      if (\r\n        (scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) &&\r\n        !(scope.flags & SCOPE_ARROW)\r\n      ) {\r\n        return scope;\r\n      }\r\n    }\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport ScopeHandler, { Scope } from \"../../util/scope\";\r\nimport {\r\n  BIND_KIND_TYPE,\r\n  BIND_FLAGS_TS_ENUM,\r\n  BIND_FLAGS_TS_CONST_ENUM,\r\n  BIND_FLAGS_TS_EXPORT_ONLY,\r\n  BIND_KIND_VALUE,\r\n  BIND_FLAGS_CLASS,\r\n  type ScopeFlags,\r\n  type BindingTypes,\r\n} from \"../../util/scopeflags\";\r\nimport * as N from \"../../types\";\r\n\r\nclass TypeScriptScope extends Scope {\r\n  types: string[] = [];\r\n\r\n  // enums (which are also in .types)\r\n  enums: string[] = [];\r\n\r\n  // const enums (which are also in .enums and .types)\r\n  constEnums: string[] = [];\r\n\r\n  // classes (which are also in .lexical) and interface (which are also in .types)\r\n  classes: string[] = [];\r\n\r\n  // namespaces and bodyless-functions are too difficult to track,\r\n  // especially without type analysis.\r\n  // We need to track them anyway, to avoid \"X is not defined\" errors\r\n  // when exporting them.\r\n  exportOnlyBindings: string[] = [];\r\n}\r\n\r\n// See https://github.com/babel/babel/pull/9766#discussion_r268920730 for an\r\n// explanation of how typescript handles scope.\r\n\r\nexport default class TypeScriptScopeHandler extends ScopeHandler<TypeScriptScope> {\r\n  createScope(flags: ScopeFlags): TypeScriptScope {\r\n    return new TypeScriptScope(flags);\r\n  }\r\n\r\n  declareName(name: string, bindingType: BindingTypes, pos: number) {\r\n    const scope = this.currentScope();\r\n    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {\r\n      this.maybeExportDefined(scope, name);\r\n      scope.exportOnlyBindings.push(name);\r\n      return;\r\n    }\r\n\r\n    super.declareName(...arguments);\r\n\r\n    if (bindingType & BIND_KIND_TYPE) {\r\n      if (!(bindingType & BIND_KIND_VALUE)) {\r\n        // \"Value\" bindings have already been registered by the superclass.\r\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\r\n        this.maybeExportDefined(scope, name);\r\n      }\r\n      scope.types.push(name);\r\n    }\r\n    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);\r\n    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);\r\n    if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);\r\n  }\r\n\r\n  isRedeclaredInScope(\r\n    scope: TypeScriptScope,\r\n    name: string,\r\n    bindingType: BindingTypes,\r\n  ): boolean {\r\n    if (scope.enums.indexOf(name) > -1) {\r\n      if (bindingType & BIND_FLAGS_TS_ENUM) {\r\n        // Enums can be merged with other enums if they are both\r\n        //  const or both non-const.\r\n        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);\r\n        const wasConst = scope.constEnums.indexOf(name) > -1;\r\n        return isConst !== wasConst;\r\n      }\r\n      return true;\r\n    }\r\n    if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {\r\n      if (scope.lexical.indexOf(name) > -1) {\r\n        // Classes can be merged with interfaces\r\n        return !!(bindingType & BIND_KIND_VALUE);\r\n      } else {\r\n        // Interface can be merged with other classes or interfaces\r\n        return false;\r\n      }\r\n    }\r\n    if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {\r\n      return true;\r\n    }\r\n\r\n    return super.isRedeclaredInScope(...arguments);\r\n  }\r\n\r\n  checkLocalExport(id: N.Identifier) {\r\n    if (\r\n      this.scopeStack[0].types.indexOf(id.name) === -1 &&\r\n      this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1\r\n    ) {\r\n      super.checkLocalExport(id);\r\n    }\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport type { TokenType } from \"../../tokenizer/types\";\r\nimport { types as tt } from \"../../tokenizer/types\";\r\nimport { types as ct } from \"../../tokenizer/context\";\r\nimport * as N from \"../../types\";\r\nimport type { Pos, Position } from \"../../util/location\";\r\nimport type Parser from \"../../parser\";\r\nimport {\r\n  type BindingTypes,\r\n  BIND_NONE,\r\n  SCOPE_OTHER,\r\n  BIND_TS_ENUM,\r\n  BIND_TS_CONST_ENUM,\r\n  BIND_TS_TYPE,\r\n  BIND_TS_INTERFACE,\r\n  BIND_TS_FN_TYPE,\r\n  BIND_TS_NAMESPACE,\r\n} from \"../../util/scopeflags\";\r\nimport TypeScriptScopeHandler from \"./scope\";\r\n\r\ntype TsModifier =\r\n  | \"readonly\"\r\n  | \"abstract\"\r\n  | \"static\"\r\n  | \"public\"\r\n  | \"private\"\r\n  | \"protected\";\r\n\r\nfunction nonNull<T>(x: ?T): T {\r\n  if (x == null) {\r\n    // $FlowIgnore\r\n    throw new Error(`Unexpected ${x} value.`);\r\n  }\r\n  return x;\r\n}\r\n\r\nfunction assert(x: boolean): void {\r\n  if (!x) {\r\n    throw new Error(\"Assert fail\");\r\n  }\r\n}\r\n\r\ntype ParsingContext =\r\n  | \"EnumMembers\"\r\n  | \"HeritageClauseElement\"\r\n  | \"TupleElementTypes\"\r\n  | \"TypeMembers\"\r\n  | \"TypeParametersOrArguments\";\r\n\r\n// Doesn't handle \"void\" or \"null\" because those are keywords, not identifiers.\r\nfunction keywordTypeFromName(\r\n  value: string,\r\n): N.TsKeywordTypeType | typeof undefined {\r\n  switch (value) {\r\n    case \"any\":\r\n      return \"TSAnyKeyword\";\r\n    case \"boolean\":\r\n      return \"TSBooleanKeyword\";\r\n    case \"bigint\":\r\n      return \"TSBigIntKeyword\";\r\n    case \"never\":\r\n      return \"TSNeverKeyword\";\r\n    case \"number\":\r\n      return \"TSNumberKeyword\";\r\n    case \"object\":\r\n      return \"TSObjectKeyword\";\r\n    case \"string\":\r\n      return \"TSStringKeyword\";\r\n    case \"symbol\":\r\n      return \"TSSymbolKeyword\";\r\n    case \"undefined\":\r\n      return \"TSUndefinedKeyword\";\r\n    case \"unknown\":\r\n      return \"TSUnknownKeyword\";\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n\r\nexport default (superClass: Class<Parser>): Class<Parser> =>\r\n  class extends superClass {\r\n    getScopeHandler(): Class<TypeScriptScopeHandler> {\r\n      return TypeScriptScopeHandler;\r\n    }\r\n\r\n    tsIsIdentifier(): boolean {\r\n      // TODO: actually a bit more complex in TypeScript, but shouldn't matter.\r\n      // See https://github.com/Microsoft/TypeScript/issues/15008\r\n      return this.match(tt.name);\r\n    }\r\n\r\n    tsNextTokenCanFollowModifier() {\r\n      // Note: TypeScript's implementation is much more complicated because\r\n      // more things are considered modifiers there.\r\n      // This implementation only handles modifiers not handled by @babel/parser itself. And \"static\".\r\n      // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...\r\n      this.next();\r\n      return (\r\n        !this.hasPrecedingLineBreak() &&\r\n        !this.match(tt.parenL) &&\r\n        !this.match(tt.parenR) &&\r\n        !this.match(tt.colon) &&\r\n        !this.match(tt.eq) &&\r\n        !this.match(tt.question) &&\r\n        !this.match(tt.bang)\r\n      );\r\n    }\r\n\r\n    /** Parses a modifier matching one the given modifier names. */\r\n    tsParseModifier<T: TsModifier>(allowedModifiers: T[]): ?T {\r\n      if (!this.match(tt.name)) {\r\n        return undefined;\r\n      }\r\n\r\n      const modifier = this.state.value;\r\n      if (\r\n        allowedModifiers.indexOf(modifier) !== -1 &&\r\n        this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))\r\n      ) {\r\n        return modifier;\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    tsIsListTerminator(kind: ParsingContext): boolean {\r\n      switch (kind) {\r\n        case \"EnumMembers\":\r\n        case \"TypeMembers\":\r\n          return this.match(tt.braceR);\r\n        case \"HeritageClauseElement\":\r\n          return this.match(tt.braceL);\r\n        case \"TupleElementTypes\":\r\n          return this.match(tt.bracketR);\r\n        case \"TypeParametersOrArguments\":\r\n          return this.isRelational(\">\");\r\n      }\r\n\r\n      throw new Error(\"Unreachable\");\r\n    }\r\n\r\n    tsParseList<T: N.Node>(kind: ParsingContext, parseElement: () => T): T[] {\r\n      const result: T[] = [];\r\n      while (!this.tsIsListTerminator(kind)) {\r\n        // Skipping \"parseListElement\" from the TS source since that's just for error handling.\r\n        result.push(parseElement());\r\n      }\r\n      return result;\r\n    }\r\n\r\n    tsParseDelimitedList<T: N.Node>(\r\n      kind: ParsingContext,\r\n      parseElement: () => T,\r\n    ): T[] {\r\n      return nonNull(\r\n        this.tsParseDelimitedListWorker(\r\n          kind,\r\n          parseElement,\r\n          /* expectSuccess */ true,\r\n        ),\r\n      );\r\n    }\r\n\r\n    /**\r\n     * If !expectSuccess, returns undefined instead of failing to parse.\r\n     * If expectSuccess, parseElement should always return a defined value.\r\n     */\r\n    tsParseDelimitedListWorker<T: N.Node>(\r\n      kind: ParsingContext,\r\n      parseElement: () => ?T,\r\n      expectSuccess: boolean,\r\n    ): ?(T[]) {\r\n      const result = [];\r\n\r\n      while (true) {\r\n        if (this.tsIsListTerminator(kind)) {\r\n          break;\r\n        }\r\n\r\n        const element = parseElement();\r\n        if (element == null) {\r\n          return undefined;\r\n        }\r\n        result.push(element);\r\n\r\n        if (this.eat(tt.comma)) {\r\n          continue;\r\n        }\r\n\r\n        if (this.tsIsListTerminator(kind)) {\r\n          break;\r\n        }\r\n\r\n        if (expectSuccess) {\r\n          // This will fail with an error about a missing comma\r\n          this.expect(tt.comma);\r\n        }\r\n        return undefined;\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    tsParseBracketedList<T: N.Node>(\r\n      kind: ParsingContext,\r\n      parseElement: () => T,\r\n      bracket: boolean,\r\n      skipFirstToken: boolean,\r\n    ): T[] {\r\n      if (!skipFirstToken) {\r\n        if (bracket) {\r\n          this.expect(tt.bracketL);\r\n        } else {\r\n          this.expectRelational(\"<\");\r\n        }\r\n      }\r\n\r\n      const result = this.tsParseDelimitedList(kind, parseElement);\r\n\r\n      if (bracket) {\r\n        this.expect(tt.bracketR);\r\n      } else {\r\n        this.expectRelational(\">\");\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    tsParseImportType(): N.TsImportType {\r\n      const node: N.TsImportType = this.startNode();\r\n      this.expect(tt._import);\r\n      this.expect(tt.parenL);\r\n      if (!this.match(tt.string)) {\r\n        throw this.unexpected(\r\n          null,\r\n          \"Argument in a type import must be a string literal\",\r\n        );\r\n      }\r\n\r\n      // For compatibility to estree we cannot call parseLiteral directly here\r\n      node.argument = this.parseExprAtom();\r\n      this.expect(tt.parenR);\r\n\r\n      if (this.eat(tt.dot)) {\r\n        node.qualifier = this.tsParseEntityName(/* allowReservedWords */ true);\r\n      }\r\n      if (this.isRelational(\"<\")) {\r\n        node.typeParameters = this.tsParseTypeArguments();\r\n      }\r\n      return this.finishNode(node, \"TSImportType\");\r\n    }\r\n\r\n    tsParseEntityName(allowReservedWords: boolean): N.TsEntityName {\r\n      let entity: N.TsEntityName = this.parseIdentifier();\r\n      while (this.eat(tt.dot)) {\r\n        const node: N.TsQualifiedName = this.startNodeAtNode(entity);\r\n        node.left = entity;\r\n        node.right = this.parseIdentifier(allowReservedWords);\r\n        entity = this.finishNode(node, \"TSQualifiedName\");\r\n      }\r\n      return entity;\r\n    }\r\n\r\n    tsParseTypeReference(): N.TsTypeReference {\r\n      const node: N.TsTypeReference = this.startNode();\r\n      node.typeName = this.tsParseEntityName(/* allowReservedWords */ false);\r\n      if (!this.hasPrecedingLineBreak() && this.isRelational(\"<\")) {\r\n        node.typeParameters = this.tsParseTypeArguments();\r\n      }\r\n      return this.finishNode(node, \"TSTypeReference\");\r\n    }\r\n\r\n    tsParseThisTypePredicate(lhs: N.TsThisType): N.TsTypePredicate {\r\n      this.next();\r\n      const node: N.TsTypePredicate = this.startNodeAtNode(lhs);\r\n      node.parameterName = lhs;\r\n      node.typeAnnotation = this.tsParseTypeAnnotation(/* eatColon */ false);\r\n      return this.finishNode(node, \"TSTypePredicate\");\r\n    }\r\n\r\n    tsParseThisTypeNode(): N.TsThisType {\r\n      const node: N.TsThisType = this.startNode();\r\n      this.next();\r\n      return this.finishNode(node, \"TSThisType\");\r\n    }\r\n\r\n    tsParseTypeQuery(): N.TsTypeQuery {\r\n      const node: N.TsTypeQuery = this.startNode();\r\n      this.expect(tt._typeof);\r\n      if (this.match(tt._import)) {\r\n        node.exprName = this.tsParseImportType();\r\n      } else {\r\n        node.exprName = this.tsParseEntityName(/* allowReservedWords */ true);\r\n      }\r\n      return this.finishNode(node, \"TSTypeQuery\");\r\n    }\r\n\r\n    tsParseTypeParameter(): N.TsTypeParameter {\r\n      const node: N.TsTypeParameter = this.startNode();\r\n      node.name = this.parseIdentifierName(node.start);\r\n      node.constraint = this.tsEatThenParseType(tt._extends);\r\n      node.default = this.tsEatThenParseType(tt.eq);\r\n      return this.finishNode(node, \"TSTypeParameter\");\r\n    }\r\n\r\n    tsTryParseTypeParameters(): ?N.TsTypeParameterDeclaration {\r\n      if (this.isRelational(\"<\")) {\r\n        return this.tsParseTypeParameters();\r\n      }\r\n    }\r\n\r\n    tsParseTypeParameters() {\r\n      const node: N.TsTypeParameterDeclaration = this.startNode();\r\n\r\n      if (this.isRelational(\"<\") || this.match(tt.jsxTagStart)) {\r\n        this.next();\r\n      } else {\r\n        this.unexpected();\r\n      }\r\n\r\n      node.params = this.tsParseBracketedList(\r\n        \"TypeParametersOrArguments\",\r\n        this.tsParseTypeParameter.bind(this),\r\n        /* bracket */ false,\r\n        /* skipFirstToken */ true,\r\n      );\r\n      return this.finishNode(node, \"TSTypeParameterDeclaration\");\r\n    }\r\n\r\n    tsTryNextParseConstantContext(): ?N.TsTypeReference {\r\n      if (this.lookahead().type === tt._const) {\r\n        this.next();\r\n        return this.tsParseTypeReference();\r\n      }\r\n      return null;\r\n    }\r\n\r\n    // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\r\n    // but here it's always false, because this is only used for types.\r\n    tsFillSignature(\r\n      returnToken: TokenType,\r\n      signature: N.TsSignatureDeclaration,\r\n    ): void {\r\n      // Arrow fns *must* have return token (`=>`). Normal functions can omit it.\r\n      const returnTokenRequired = returnToken === tt.arrow;\r\n      signature.typeParameters = this.tsTryParseTypeParameters();\r\n      this.expect(tt.parenL);\r\n      signature.parameters = this.tsParseBindingListForSignature();\r\n      if (returnTokenRequired) {\r\n        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(\r\n          returnToken,\r\n        );\r\n      } else if (this.match(returnToken)) {\r\n        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(\r\n          returnToken,\r\n        );\r\n      }\r\n    }\r\n\r\n    tsParseBindingListForSignature(): $ReadOnlyArray<\r\n      N.Identifier | N.RestElement | N.ObjectPattern | N.ArrayPattern,\r\n    > {\r\n      return this.parseBindingList(tt.parenR).map(pattern => {\r\n        if (\r\n          pattern.type !== \"Identifier\" &&\r\n          pattern.type !== \"RestElement\" &&\r\n          pattern.type !== \"ObjectPattern\" &&\r\n          pattern.type !== \"ArrayPattern\"\r\n        ) {\r\n          throw this.unexpected(\r\n            pattern.start,\r\n            `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${\r\n              pattern.type\r\n            }`,\r\n          );\r\n        }\r\n        return pattern;\r\n      });\r\n    }\r\n\r\n    tsParseTypeMemberSemicolon(): void {\r\n      if (!this.eat(tt.comma)) {\r\n        this.semicolon();\r\n      }\r\n    }\r\n\r\n    tsParseSignatureMember(\r\n      kind: \"TSCallSignatureDeclaration\" | \"TSConstructSignatureDeclaration\",\r\n      node: N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration,\r\n    ): N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration {\r\n      this.tsFillSignature(tt.colon, node);\r\n      this.tsParseTypeMemberSemicolon();\r\n      return this.finishNode(node, kind);\r\n    }\r\n\r\n    tsIsUnambiguouslyIndexSignature() {\r\n      this.next(); // Skip '{'\r\n      return this.eat(tt.name) && this.match(tt.colon);\r\n    }\r\n\r\n    tsTryParseIndexSignature(node: N.TsIndexSignature): ?N.TsIndexSignature {\r\n      if (\r\n        !(\r\n          this.match(tt.bracketL) &&\r\n          this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))\r\n        )\r\n      ) {\r\n        return undefined;\r\n      }\r\n\r\n      this.expect(tt.bracketL);\r\n      const id = this.parseIdentifier();\r\n      id.typeAnnotation = this.tsParseTypeAnnotation();\r\n      this.resetEndLocation(id); // set end position to end of type\r\n\r\n      this.expect(tt.bracketR);\r\n      node.parameters = [id];\r\n\r\n      const type = this.tsTryParseTypeAnnotation();\r\n      if (type) node.typeAnnotation = type;\r\n      this.tsParseTypeMemberSemicolon();\r\n      return this.finishNode(node, \"TSIndexSignature\");\r\n    }\r\n\r\n    tsParsePropertyOrMethodSignature(\r\n      node: N.TsPropertySignature | N.TsMethodSignature,\r\n      readonly: boolean,\r\n    ): N.TsPropertySignature | N.TsMethodSignature {\r\n      if (this.eat(tt.question)) node.optional = true;\r\n      const nodeAny: any = node;\r\n\r\n      if (!readonly && (this.match(tt.parenL) || this.isRelational(\"<\"))) {\r\n        const method: N.TsMethodSignature = nodeAny;\r\n        this.tsFillSignature(tt.colon, method);\r\n        this.tsParseTypeMemberSemicolon();\r\n        return this.finishNode(method, \"TSMethodSignature\");\r\n      } else {\r\n        const property: N.TsPropertySignature = nodeAny;\r\n        if (readonly) property.readonly = true;\r\n        const type = this.tsTryParseTypeAnnotation();\r\n        if (type) property.typeAnnotation = type;\r\n        this.tsParseTypeMemberSemicolon();\r\n        return this.finishNode(property, \"TSPropertySignature\");\r\n      }\r\n    }\r\n\r\n    tsParseTypeMember(): N.TsTypeElement {\r\n      const node: any = this.startNode();\r\n\r\n      if (this.match(tt.parenL) || this.isRelational(\"<\")) {\r\n        return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\r\n      }\r\n\r\n      if (this.match(tt._new)) {\r\n        const id: N.Identifier = this.startNode();\r\n        this.next();\r\n        if (this.match(tt.parenL) || this.isRelational(\"<\")) {\r\n          return this.tsParseSignatureMember(\r\n            \"TSConstructSignatureDeclaration\",\r\n            node,\r\n          );\r\n        } else {\r\n          node.key = this.createIdentifier(id, \"new\");\r\n          return this.tsParsePropertyOrMethodSignature(node, false);\r\n        }\r\n      }\r\n\r\n      const readonly = !!this.tsParseModifier([\"readonly\"]);\r\n\r\n      const idx = this.tsTryParseIndexSignature(node);\r\n      if (idx) {\r\n        if (readonly) node.readonly = true;\r\n        return idx;\r\n      }\r\n\r\n      this.parsePropertyName(node);\r\n      return this.tsParsePropertyOrMethodSignature(node, readonly);\r\n    }\r\n\r\n    tsParseTypeLiteral(): N.TsTypeLiteral {\r\n      const node: N.TsTypeLiteral = this.startNode();\r\n      node.members = this.tsParseObjectTypeMembers();\r\n      return this.finishNode(node, \"TSTypeLiteral\");\r\n    }\r\n\r\n    tsParseObjectTypeMembers(): $ReadOnlyArray<N.TsTypeElement> {\r\n      this.expect(tt.braceL);\r\n      const members = this.tsParseList(\r\n        \"TypeMembers\",\r\n        this.tsParseTypeMember.bind(this),\r\n      );\r\n      this.expect(tt.braceR);\r\n      return members;\r\n    }\r\n\r\n    tsIsStartOfMappedType(): boolean {\r\n      this.next();\r\n      if (this.eat(tt.plusMin)) {\r\n        return this.isContextual(\"readonly\");\r\n      }\r\n      if (this.isContextual(\"readonly\")) {\r\n        this.next();\r\n      }\r\n      if (!this.match(tt.bracketL)) {\r\n        return false;\r\n      }\r\n      this.next();\r\n      if (!this.tsIsIdentifier()) {\r\n        return false;\r\n      }\r\n      this.next();\r\n      return this.match(tt._in);\r\n    }\r\n\r\n    tsParseMappedTypeParameter(): N.TsTypeParameter {\r\n      const node: N.TsTypeParameter = this.startNode();\r\n      node.name = this.parseIdentifierName(node.start);\r\n      node.constraint = this.tsExpectThenParseType(tt._in);\r\n      return this.finishNode(node, \"TSTypeParameter\");\r\n    }\r\n\r\n    tsParseMappedType(): N.TsMappedType {\r\n      const node: N.TsMappedType = this.startNode();\r\n\r\n      this.expect(tt.braceL);\r\n\r\n      if (this.match(tt.plusMin)) {\r\n        node.readonly = this.state.value;\r\n        this.next();\r\n        this.expectContextual(\"readonly\");\r\n      } else if (this.eatContextual(\"readonly\")) {\r\n        node.readonly = true;\r\n      }\r\n\r\n      this.expect(tt.bracketL);\r\n      node.typeParameter = this.tsParseMappedTypeParameter();\r\n      this.expect(tt.bracketR);\r\n\r\n      if (this.match(tt.plusMin)) {\r\n        node.optional = this.state.value;\r\n        this.next();\r\n        this.expect(tt.question);\r\n      } else if (this.eat(tt.question)) {\r\n        node.optional = true;\r\n      }\r\n\r\n      node.typeAnnotation = this.tsTryParseType();\r\n      this.semicolon();\r\n      this.expect(tt.braceR);\r\n\r\n      return this.finishNode(node, \"TSMappedType\");\r\n    }\r\n\r\n    tsParseTupleType(): N.TsTupleType {\r\n      const node: N.TsTupleType = this.startNode();\r\n      node.elementTypes = this.tsParseBracketedList(\r\n        \"TupleElementTypes\",\r\n        this.tsParseTupleElementType.bind(this),\r\n        /* bracket */ true,\r\n        /* skipFirstToken */ false,\r\n      );\r\n\r\n      // Validate the elementTypes to ensure:\r\n      //   No mandatory elements may follow optional elements\r\n      //   If there's a rest element, it must be at the end of the tuple\r\n      let seenOptionalElement = false;\r\n      node.elementTypes.forEach(elementNode => {\r\n        if (elementNode.type === \"TSOptionalType\") {\r\n          seenOptionalElement = true;\r\n        } else if (seenOptionalElement && elementNode.type !== \"TSRestType\") {\r\n          this.raise(\r\n            elementNode.start,\r\n            \"A required element cannot follow an optional element.\",\r\n          );\r\n        }\r\n      });\r\n\r\n      return this.finishNode(node, \"TSTupleType\");\r\n    }\r\n\r\n    tsParseTupleElementType(): N.TsType {\r\n      // parses `...TsType[]`\r\n      if (this.match(tt.ellipsis)) {\r\n        const restNode: N.TsRestType = this.startNode();\r\n        this.next(); // skips ellipsis\r\n        restNode.typeAnnotation = this.tsParseType();\r\n        this.checkCommaAfterRest();\r\n        return this.finishNode(restNode, \"TSRestType\");\r\n      }\r\n\r\n      const type = this.tsParseType();\r\n      // parses `TsType?`\r\n      if (this.eat(tt.question)) {\r\n        const optionalTypeNode: N.TsOptionalType = this.startNodeAtNode(type);\r\n        optionalTypeNode.typeAnnotation = type;\r\n        return this.finishNode(optionalTypeNode, \"TSOptionalType\");\r\n      }\r\n      return type;\r\n    }\r\n\r\n    tsParseParenthesizedType(): N.TsParenthesizedType {\r\n      const node = this.startNode();\r\n      this.expect(tt.parenL);\r\n      node.typeAnnotation = this.tsParseType();\r\n      this.expect(tt.parenR);\r\n      return this.finishNode(node, \"TSParenthesizedType\");\r\n    }\r\n\r\n    tsParseFunctionOrConstructorType(\r\n      type: \"TSFunctionType\" | \"TSConstructorType\",\r\n    ): N.TsFunctionOrConstructorType {\r\n      const node: N.TsFunctionOrConstructorType = this.startNode();\r\n      if (type === \"TSConstructorType\") {\r\n        this.expect(tt._new);\r\n      }\r\n      this.tsFillSignature(tt.arrow, node);\r\n      return this.finishNode(node, type);\r\n    }\r\n\r\n    tsParseLiteralTypeNode(): N.TsLiteralType {\r\n      const node: N.TsLiteralType = this.startNode();\r\n      node.literal = (() => {\r\n        switch (this.state.type) {\r\n          case tt.num:\r\n          case tt.string:\r\n          case tt._true:\r\n          case tt._false:\r\n            // For compatibility to estree we cannot call parseLiteral directly here\r\n            return this.parseExprAtom();\r\n          default:\r\n            throw this.unexpected();\r\n        }\r\n      })();\r\n      return this.finishNode(node, \"TSLiteralType\");\r\n    }\r\n\r\n    tsParseTemplateLiteralType(): N.TsType {\r\n      const node: N.TsLiteralType = this.startNode();\r\n      const templateNode = this.parseTemplate(false);\r\n      if (templateNode.expressions.length > 0) {\r\n        throw this.raise(\r\n          templateNode.expressions[0].start,\r\n          \"Template literal types cannot have any substitution\",\r\n        );\r\n      }\r\n      node.literal = templateNode;\r\n      return this.finishNode(node, \"TSLiteralType\");\r\n    }\r\n\r\n    tsParseNonArrayType(): N.TsType {\r\n      switch (this.state.type) {\r\n        case tt.name:\r\n        case tt._void:\r\n        case tt._null: {\r\n          const type = this.match(tt._void)\r\n            ? \"TSVoidKeyword\"\r\n            : this.match(tt._null)\r\n            ? \"TSNullKeyword\"\r\n            : keywordTypeFromName(this.state.value);\r\n          if (type !== undefined && this.lookahead().type !== tt.dot) {\r\n            const node: N.TsKeywordType = this.startNode();\r\n            this.next();\r\n            return this.finishNode(node, type);\r\n          }\r\n          return this.tsParseTypeReference();\r\n        }\r\n        case tt.string:\r\n        case tt.num:\r\n        case tt._true:\r\n        case tt._false:\r\n          return this.tsParseLiteralTypeNode();\r\n        case tt.plusMin:\r\n          if (this.state.value === \"-\") {\r\n            const node: N.TsLiteralType = this.startNode();\r\n            if (this.lookahead().type !== tt.num) {\r\n              throw this.unexpected();\r\n            }\r\n            node.literal = this.parseMaybeUnary();\r\n            return this.finishNode(node, \"TSLiteralType\");\r\n          }\r\n          break;\r\n        case tt._this: {\r\n          const thisKeyword = this.tsParseThisTypeNode();\r\n          if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\r\n            return this.tsParseThisTypePredicate(thisKeyword);\r\n          } else {\r\n            return thisKeyword;\r\n          }\r\n        }\r\n        case tt._typeof:\r\n          return this.tsParseTypeQuery();\r\n        case tt._import:\r\n          return this.tsParseImportType();\r\n        case tt.braceL:\r\n          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))\r\n            ? this.tsParseMappedType()\r\n            : this.tsParseTypeLiteral();\r\n        case tt.bracketL:\r\n          return this.tsParseTupleType();\r\n        case tt.parenL:\r\n          return this.tsParseParenthesizedType();\r\n        case tt.backQuote:\r\n          return this.tsParseTemplateLiteralType();\r\n      }\r\n\r\n      throw this.unexpected();\r\n    }\r\n\r\n    tsParseArrayTypeOrHigher(): N.TsType {\r\n      let type = this.tsParseNonArrayType();\r\n      while (!this.hasPrecedingLineBreak() && this.eat(tt.bracketL)) {\r\n        if (this.match(tt.bracketR)) {\r\n          const node: N.TsArrayType = this.startNodeAtNode(type);\r\n          node.elementType = type;\r\n          this.expect(tt.bracketR);\r\n          type = this.finishNode(node, \"TSArrayType\");\r\n        } else {\r\n          const node: N.TsIndexedAccessType = this.startNodeAtNode(type);\r\n          node.objectType = type;\r\n          node.indexType = this.tsParseType();\r\n          this.expect(tt.bracketR);\r\n          type = this.finishNode(node, \"TSIndexedAccessType\");\r\n        }\r\n      }\r\n      return type;\r\n    }\r\n\r\n    tsParseTypeOperator(\r\n      operator: \"keyof\" | \"unique\" | \"readonly\",\r\n    ): N.TsTypeOperator {\r\n      const node: N.TsTypeOperator = this.startNode();\r\n      this.expectContextual(operator);\r\n      node.operator = operator;\r\n      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\r\n\r\n      if (operator === \"readonly\") {\r\n        this.tsCheckTypeAnnotationForReadOnly(node);\r\n      }\r\n\r\n      return this.finishNode(node, \"TSTypeOperator\");\r\n    }\r\n\r\n    tsCheckTypeAnnotationForReadOnly(node: N.Node) {\r\n      switch (node.typeAnnotation.type) {\r\n        case \"TSTupleType\":\r\n        case \"TSArrayType\":\r\n          return;\r\n        default:\r\n          this.raise(\r\n            node.start,\r\n            \"'readonly' type modifier is only permitted on array and tuple literal types.\",\r\n          );\r\n      }\r\n    }\r\n\r\n    tsParseInferType(): N.TsInferType {\r\n      const node = this.startNode();\r\n      this.expectContextual(\"infer\");\r\n      const typeParameter = this.startNode();\r\n      typeParameter.name = this.parseIdentifierName(typeParameter.start);\r\n      node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\r\n      return this.finishNode(node, \"TSInferType\");\r\n    }\r\n\r\n    tsParseTypeOperatorOrHigher(): N.TsType {\r\n      const operator = [\"keyof\", \"unique\", \"readonly\"].find(kw =>\r\n        this.isContextual(kw),\r\n      );\r\n      return operator\r\n        ? this.tsParseTypeOperator(operator)\r\n        : this.isContextual(\"infer\")\r\n        ? this.tsParseInferType()\r\n        : this.tsParseArrayTypeOrHigher();\r\n    }\r\n\r\n    tsParseUnionOrIntersectionType(\r\n      kind: \"TSUnionType\" | \"TSIntersectionType\",\r\n      parseConstituentType: () => N.TsType,\r\n      operator: TokenType,\r\n    ): N.TsType {\r\n      this.eat(operator);\r\n      let type = parseConstituentType();\r\n      if (this.match(operator)) {\r\n        const types = [type];\r\n        while (this.eat(operator)) {\r\n          types.push(parseConstituentType());\r\n        }\r\n        const node: N.TsUnionType | N.TsIntersectionType = this.startNodeAtNode(\r\n          type,\r\n        );\r\n        node.types = types;\r\n        type = this.finishNode(node, kind);\r\n      }\r\n      return type;\r\n    }\r\n\r\n    tsParseIntersectionTypeOrHigher(): N.TsType {\r\n      return this.tsParseUnionOrIntersectionType(\r\n        \"TSIntersectionType\",\r\n        this.tsParseTypeOperatorOrHigher.bind(this),\r\n        tt.bitwiseAND,\r\n      );\r\n    }\r\n\r\n    tsParseUnionTypeOrHigher() {\r\n      return this.tsParseUnionOrIntersectionType(\r\n        \"TSUnionType\",\r\n        this.tsParseIntersectionTypeOrHigher.bind(this),\r\n        tt.bitwiseOR,\r\n      );\r\n    }\r\n\r\n    tsIsStartOfFunctionType() {\r\n      if (this.isRelational(\"<\")) {\r\n        return true;\r\n      }\r\n      return (\r\n        this.match(tt.parenL) &&\r\n        this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))\r\n      );\r\n    }\r\n\r\n    tsSkipParameterStart(): boolean {\r\n      if (this.match(tt.name) || this.match(tt._this)) {\r\n        this.next();\r\n        return true;\r\n      }\r\n\r\n      if (this.match(tt.braceL)) {\r\n        let braceStackCounter = 1;\r\n        this.next();\r\n\r\n        while (braceStackCounter > 0) {\r\n          if (this.match(tt.braceL)) {\r\n            ++braceStackCounter;\r\n          } else if (this.match(tt.braceR)) {\r\n            --braceStackCounter;\r\n          }\r\n          this.next();\r\n        }\r\n        return true;\r\n      }\r\n\r\n      if (this.match(tt.bracketL)) {\r\n        let braceStackCounter = 1;\r\n        this.next();\r\n\r\n        while (braceStackCounter > 0) {\r\n          if (this.match(tt.bracketL)) {\r\n            ++braceStackCounter;\r\n          } else if (this.match(tt.bracketR)) {\r\n            --braceStackCounter;\r\n          }\r\n          this.next();\r\n        }\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    tsIsUnambiguouslyStartOfFunctionType(): boolean {\r\n      this.next();\r\n      if (this.match(tt.parenR) || this.match(tt.ellipsis)) {\r\n        // ( )\r\n        // ( ...\r\n        return true;\r\n      }\r\n      if (this.tsSkipParameterStart()) {\r\n        if (\r\n          this.match(tt.colon) ||\r\n          this.match(tt.comma) ||\r\n          this.match(tt.question) ||\r\n          this.match(tt.eq)\r\n        ) {\r\n          // ( xxx :\r\n          // ( xxx ,\r\n          // ( xxx ?\r\n          // ( xxx =\r\n          return true;\r\n        }\r\n        if (this.match(tt.parenR)) {\r\n          this.next();\r\n          if (this.match(tt.arrow)) {\r\n            // ( xxx ) =>\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    tsParseTypeOrTypePredicateAnnotation(\r\n      returnToken: TokenType,\r\n    ): N.TsTypeAnnotation {\r\n      return this.tsInType(() => {\r\n        const t: N.TsTypeAnnotation = this.startNode();\r\n        this.expect(returnToken);\r\n\r\n        const typePredicateVariable =\r\n          this.tsIsIdentifier() &&\r\n          this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\r\n\r\n        if (!typePredicateVariable) {\r\n          return this.tsParseTypeAnnotation(/* eatColon */ false, t);\r\n        }\r\n\r\n        const type = this.tsParseTypeAnnotation(/* eatColon */ false);\r\n\r\n        const node: N.TsTypePredicate = this.startNodeAtNode(\r\n          typePredicateVariable,\r\n        );\r\n        node.parameterName = typePredicateVariable;\r\n        node.typeAnnotation = type;\r\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\r\n        return this.finishNode(t, \"TSTypeAnnotation\");\r\n      });\r\n    }\r\n\r\n    tsTryParseTypeOrTypePredicateAnnotation(): ?N.TsTypeAnnotation {\r\n      return this.match(tt.colon)\r\n        ? this.tsParseTypeOrTypePredicateAnnotation(tt.colon)\r\n        : undefined;\r\n    }\r\n\r\n    tsTryParseTypeAnnotation(): ?N.TsTypeAnnotation {\r\n      return this.match(tt.colon) ? this.tsParseTypeAnnotation() : undefined;\r\n    }\r\n\r\n    tsTryParseType(): ?N.TsType {\r\n      return this.tsEatThenParseType(tt.colon);\r\n    }\r\n\r\n    tsParseTypePredicatePrefix(): ?N.Identifier {\r\n      const id = this.parseIdentifier();\r\n      if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\r\n        this.next();\r\n        return id;\r\n      }\r\n    }\r\n\r\n    tsParseTypeAnnotation(\r\n      eatColon = true,\r\n      t: N.TsTypeAnnotation = this.startNode(),\r\n    ): N.TsTypeAnnotation {\r\n      this.tsInType(() => {\r\n        if (eatColon) this.expect(tt.colon);\r\n        t.typeAnnotation = this.tsParseType();\r\n      });\r\n      return this.finishNode(t, \"TSTypeAnnotation\");\r\n    }\r\n\r\n    /** Be sure to be in a type context before calling this, using `tsInType`. */\r\n    tsParseType(): N.TsType {\r\n      // Need to set `state.inType` so that we don't parse JSX in a type context.\r\n      assert(this.state.inType);\r\n      const type = this.tsParseNonConditionalType();\r\n      if (this.hasPrecedingLineBreak() || !this.eat(tt._extends)) {\r\n        return type;\r\n      }\r\n      const node: N.TsConditionalType = this.startNodeAtNode(type);\r\n      node.checkType = type;\r\n      node.extendsType = this.tsParseNonConditionalType();\r\n      this.expect(tt.question);\r\n      node.trueType = this.tsParseType();\r\n      this.expect(tt.colon);\r\n      node.falseType = this.tsParseType();\r\n      return this.finishNode(node, \"TSConditionalType\");\r\n    }\r\n\r\n    tsParseNonConditionalType(): N.TsType {\r\n      if (this.tsIsStartOfFunctionType()) {\r\n        return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\r\n      }\r\n      if (this.match(tt._new)) {\r\n        // As in `new () => Date`\r\n        return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\r\n      }\r\n      return this.tsParseUnionTypeOrHigher();\r\n    }\r\n\r\n    tsParseTypeAssertion(): N.TsTypeAssertion {\r\n      const node: N.TsTypeAssertion = this.startNode();\r\n      const _const = this.tsTryNextParseConstantContext();\r\n      node.typeAnnotation = _const || this.tsNextThenParseType();\r\n      this.expectRelational(\">\");\r\n      node.expression = this.parseMaybeUnary();\r\n      return this.finishNode(node, \"TSTypeAssertion\");\r\n    }\r\n\r\n    tsParseHeritageClause(\r\n      descriptor: string,\r\n    ): $ReadOnlyArray<N.TsExpressionWithTypeArguments> {\r\n      const originalStart = this.state.start;\r\n\r\n      const delimitedList = this.tsParseDelimitedList(\r\n        \"HeritageClauseElement\",\r\n        this.tsParseExpressionWithTypeArguments.bind(this),\r\n      );\r\n\r\n      if (!delimitedList.length) {\r\n        this.raise(originalStart, `'${descriptor}' list cannot be empty.`);\r\n      }\r\n\r\n      return delimitedList;\r\n    }\r\n\r\n    tsParseExpressionWithTypeArguments(): N.TsExpressionWithTypeArguments {\r\n      const node: N.TsExpressionWithTypeArguments = this.startNode();\r\n      // Note: TS uses parseLeftHandSideExpressionOrHigher,\r\n      // then has grammar errors later if it's not an EntityName.\r\n      node.expression = this.tsParseEntityName(/* allowReservedWords */ false);\r\n      if (this.isRelational(\"<\")) {\r\n        node.typeParameters = this.tsParseTypeArguments();\r\n      }\r\n\r\n      return this.finishNode(node, \"TSExpressionWithTypeArguments\");\r\n    }\r\n\r\n    tsParseInterfaceDeclaration(\r\n      node: N.TsInterfaceDeclaration,\r\n    ): N.TsInterfaceDeclaration {\r\n      node.id = this.parseIdentifier();\r\n      this.checkLVal(\r\n        node.id,\r\n        BIND_TS_INTERFACE,\r\n        undefined,\r\n        \"typescript interface declaration\",\r\n      );\r\n      node.typeParameters = this.tsTryParseTypeParameters();\r\n      if (this.eat(tt._extends)) {\r\n        node.extends = this.tsParseHeritageClause(\"extends\");\r\n      }\r\n      const body: N.TSInterfaceBody = this.startNode();\r\n      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\r\n      node.body = this.finishNode(body, \"TSInterfaceBody\");\r\n      return this.finishNode(node, \"TSInterfaceDeclaration\");\r\n    }\r\n\r\n    tsParseTypeAliasDeclaration(\r\n      node: N.TsTypeAliasDeclaration,\r\n    ): N.TsTypeAliasDeclaration {\r\n      node.id = this.parseIdentifier();\r\n      this.checkLVal(node.id, BIND_TS_TYPE, undefined, \"typescript type alias\");\r\n\r\n      node.typeParameters = this.tsTryParseTypeParameters();\r\n      node.typeAnnotation = this.tsExpectThenParseType(tt.eq);\r\n      this.semicolon();\r\n      return this.finishNode(node, \"TSTypeAliasDeclaration\");\r\n    }\r\n\r\n    tsInNoContext<T>(cb: () => T): T {\r\n      const oldContext = this.state.context;\r\n      this.state.context = [oldContext[0]];\r\n      try {\r\n        return cb();\r\n      } finally {\r\n        this.state.context = oldContext;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Runs `cb` in a type context.\r\n     * This should be called one token *before* the first type token,\r\n     * so that the call to `next()` is run in type context.\r\n     */\r\n    tsInType<T>(cb: () => T): T {\r\n      const oldInType = this.state.inType;\r\n      this.state.inType = true;\r\n      try {\r\n        return cb();\r\n      } finally {\r\n        this.state.inType = oldInType;\r\n      }\r\n    }\r\n\r\n    tsEatThenParseType(token: TokenType): N.TsType | typeof undefined {\r\n      return !this.match(token) ? undefined : this.tsNextThenParseType();\r\n    }\r\n\r\n    tsExpectThenParseType(token: TokenType): N.TsType {\r\n      return this.tsDoThenParseType(() => this.expect(token));\r\n    }\r\n\r\n    tsNextThenParseType(): N.TsType {\r\n      return this.tsDoThenParseType(() => this.next());\r\n    }\r\n\r\n    tsDoThenParseType(cb: () => void): N.TsType {\r\n      return this.tsInType(() => {\r\n        cb();\r\n        return this.tsParseType();\r\n      });\r\n    }\r\n\r\n    tsParseEnumMember(): N.TsEnumMember {\r\n      const node: N.TsEnumMember = this.startNode();\r\n      // Computed property names are grammar errors in an enum, so accept just string literal or identifier.\r\n      node.id = this.match(tt.string)\r\n        ? this.parseExprAtom()\r\n        : this.parseIdentifier(/* liberal */ true);\r\n      if (this.eat(tt.eq)) {\r\n        node.initializer = this.parseMaybeAssign();\r\n      }\r\n      return this.finishNode(node, \"TSEnumMember\");\r\n    }\r\n\r\n    tsParseEnumDeclaration(\r\n      node: N.TsEnumDeclaration,\r\n      isConst: boolean,\r\n    ): N.TsEnumDeclaration {\r\n      if (isConst) node.const = true;\r\n      node.id = this.parseIdentifier();\r\n      this.checkLVal(\r\n        node.id,\r\n        isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM,\r\n        undefined,\r\n        \"typescript enum declaration\",\r\n      );\r\n\r\n      this.expect(tt.braceL);\r\n      node.members = this.tsParseDelimitedList(\r\n        \"EnumMembers\",\r\n        this.tsParseEnumMember.bind(this),\r\n      );\r\n      this.expect(tt.braceR);\r\n      return this.finishNode(node, \"TSEnumDeclaration\");\r\n    }\r\n\r\n    tsParseModuleBlock(): N.TsModuleBlock {\r\n      const node: N.TsModuleBlock = this.startNode();\r\n      this.scope.enter(SCOPE_OTHER);\r\n\r\n      this.expect(tt.braceL);\r\n      // Inside of a module block is considered \"top-level\", meaning it can have imports and exports.\r\n      this.parseBlockOrModuleBlockBody(\r\n        (node.body = []),\r\n        /* directives */ undefined,\r\n        /* topLevel */ true,\r\n        /* end */ tt.braceR,\r\n      );\r\n      this.scope.exit();\r\n      return this.finishNode(node, \"TSModuleBlock\");\r\n    }\r\n\r\n    tsParseModuleOrNamespaceDeclaration(\r\n      node: N.TsModuleDeclaration,\r\n      nested?: boolean = false,\r\n    ): N.TsModuleDeclaration {\r\n      node.id = this.parseIdentifier();\r\n\r\n      if (!nested) {\r\n        this.checkLVal(\r\n          node.id,\r\n          BIND_TS_NAMESPACE,\r\n          null,\r\n          \"module or namespace declaration\",\r\n        );\r\n      }\r\n\r\n      if (this.eat(tt.dot)) {\r\n        const inner = this.startNode();\r\n        this.tsParseModuleOrNamespaceDeclaration(inner, true);\r\n        node.body = inner;\r\n      } else {\r\n        node.body = this.tsParseModuleBlock();\r\n      }\r\n      return this.finishNode(node, \"TSModuleDeclaration\");\r\n    }\r\n\r\n    tsParseAmbientExternalModuleDeclaration(\r\n      node: N.TsModuleDeclaration,\r\n    ): N.TsModuleDeclaration {\r\n      if (this.isContextual(\"global\")) {\r\n        node.global = true;\r\n        node.id = this.parseIdentifier();\r\n      } else if (this.match(tt.string)) {\r\n        node.id = this.parseExprAtom();\r\n      } else {\r\n        this.unexpected();\r\n      }\r\n\r\n      if (this.match(tt.braceL)) {\r\n        node.body = this.tsParseModuleBlock();\r\n      } else {\r\n        this.semicolon();\r\n      }\r\n\r\n      return this.finishNode(node, \"TSModuleDeclaration\");\r\n    }\r\n\r\n    tsParseImportEqualsDeclaration(\r\n      node: N.TsImportEqualsDeclaration,\r\n      isExport?: boolean,\r\n    ): N.TsImportEqualsDeclaration {\r\n      node.isExport = isExport || false;\r\n      node.id = this.parseIdentifier();\r\n      this.expect(tt.eq);\r\n      node.moduleReference = this.tsParseModuleReference();\r\n      this.semicolon();\r\n      return this.finishNode(node, \"TSImportEqualsDeclaration\");\r\n    }\r\n\r\n    tsIsExternalModuleReference(): boolean {\r\n      return (\r\n        this.isContextual(\"require\") && this.lookahead().type === tt.parenL\r\n      );\r\n    }\r\n\r\n    tsParseModuleReference(): N.TsModuleReference {\r\n      return this.tsIsExternalModuleReference()\r\n        ? this.tsParseExternalModuleReference()\r\n        : this.tsParseEntityName(/* allowReservedWords */ false);\r\n    }\r\n\r\n    tsParseExternalModuleReference(): N.TsExternalModuleReference {\r\n      const node: N.TsExternalModuleReference = this.startNode();\r\n      this.expectContextual(\"require\");\r\n      this.expect(tt.parenL);\r\n      if (!this.match(tt.string)) {\r\n        throw this.unexpected();\r\n      }\r\n      // For compatibility to estree we cannot call parseLiteral directly here\r\n      node.expression = this.parseExprAtom();\r\n      this.expect(tt.parenR);\r\n      return this.finishNode(node, \"TSExternalModuleReference\");\r\n    }\r\n\r\n    // Utilities\r\n\r\n    tsLookAhead<T>(f: () => T): T {\r\n      const state = this.state.clone();\r\n      const res = f();\r\n      this.state = state;\r\n      return res;\r\n    }\r\n\r\n    tsTryParseAndCatch<T>(f: () => T): ?T {\r\n      const state = this.state.clone();\r\n      try {\r\n        return f();\r\n      } catch (e) {\r\n        if (e instanceof SyntaxError) {\r\n          this.state = state;\r\n          return undefined;\r\n        }\r\n        throw e;\r\n      }\r\n    }\r\n\r\n    tsTryParse<T>(f: () => ?T): ?T {\r\n      const state = this.state.clone();\r\n      const result = f();\r\n      if (result !== undefined && result !== false) {\r\n        return result;\r\n      } else {\r\n        this.state = state;\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    tsTryParseDeclare(nany: any): ?N.Declaration {\r\n      if (this.isLineTerminator()) {\r\n        return;\r\n      }\r\n      let starttype = this.state.type;\r\n      let kind;\r\n\r\n      if (this.isContextual(\"let\")) {\r\n        starttype = tt._var;\r\n        kind = \"let\";\r\n      }\r\n\r\n      switch (starttype) {\r\n        case tt._function:\r\n          return this.parseFunctionStatement(\r\n            nany,\r\n            /* async */ false,\r\n            /* declarationPosition */ true,\r\n          );\r\n        case tt._class:\r\n          return this.parseClass(\r\n            nany,\r\n            /* isStatement */ true,\r\n            /* optionalId */ false,\r\n          );\r\n        case tt._const:\r\n          if (this.match(tt._const) && this.isLookaheadContextual(\"enum\")) {\r\n            // `const enum = 0;` not allowed because \"enum\" is a strict mode reserved word.\r\n            this.expect(tt._const);\r\n            this.expectContextual(\"enum\");\r\n            return this.tsParseEnumDeclaration(nany, /* isConst */ true);\r\n          }\r\n        // falls through\r\n        case tt._var:\r\n          kind = kind || this.state.value;\r\n          return this.parseVarStatement(nany, kind);\r\n        case tt.name: {\r\n          const value = this.state.value;\r\n          if (value === \"global\") {\r\n            return this.tsParseAmbientExternalModuleDeclaration(nany);\r\n          } else {\r\n            return this.tsParseDeclaration(nany, value, /* next */ true);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.\r\n    tsTryParseExportDeclaration(): ?N.Declaration {\r\n      return this.tsParseDeclaration(\r\n        this.startNode(),\r\n        this.state.value,\r\n        /* next */ true,\r\n      );\r\n    }\r\n\r\n    tsParseExpressionStatement(node: any, expr: N.Identifier): ?N.Declaration {\r\n      switch (expr.name) {\r\n        case \"declare\": {\r\n          const declaration = this.tsTryParseDeclare(node);\r\n          if (declaration) {\r\n            declaration.declare = true;\r\n            return declaration;\r\n          }\r\n          break;\r\n        }\r\n        case \"global\":\r\n          // `global { }` (with no `declare`) may appear inside an ambient module declaration.\r\n          // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past \"global\".\r\n          if (this.match(tt.braceL)) {\r\n            const mod: N.TsModuleDeclaration = node;\r\n            mod.global = true;\r\n            mod.id = expr;\r\n            mod.body = this.tsParseModuleBlock();\r\n            return this.finishNode(mod, \"TSModuleDeclaration\");\r\n          }\r\n          break;\r\n\r\n        default:\r\n          return this.tsParseDeclaration(node, expr.name, /* next */ false);\r\n      }\r\n    }\r\n\r\n    // Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.\r\n    tsParseDeclaration(\r\n      node: any,\r\n      value: string,\r\n      next: boolean,\r\n    ): ?N.Declaration {\r\n      switch (value) {\r\n        case \"abstract\":\r\n          if (this.tsCheckLineTerminatorAndMatch(tt._class, next)) {\r\n            const cls: N.ClassDeclaration = node;\r\n            cls.abstract = true;\r\n            if (next) {\r\n              this.next();\r\n              if (!this.match(tt._class)) {\r\n                this.unexpected(null, tt._class);\r\n              }\r\n            }\r\n            return this.parseClass(\r\n              cls,\r\n              /* isStatement */ true,\r\n              /* optionalId */ false,\r\n            );\r\n          }\r\n          break;\r\n\r\n        case \"enum\":\r\n          if (next || this.match(tt.name)) {\r\n            if (next) this.next();\r\n            return this.tsParseEnumDeclaration(node, /* isConst */ false);\r\n          }\r\n          break;\r\n\r\n        case \"interface\":\r\n          if (this.tsCheckLineTerminatorAndMatch(tt.name, next)) {\r\n            if (next) this.next();\r\n            return this.tsParseInterfaceDeclaration(node);\r\n          }\r\n          break;\r\n\r\n        case \"module\":\r\n          if (next) this.next();\r\n          if (this.match(tt.string)) {\r\n            return this.tsParseAmbientExternalModuleDeclaration(node);\r\n          } else if (this.tsCheckLineTerminatorAndMatch(tt.name, next)) {\r\n            return this.tsParseModuleOrNamespaceDeclaration(node);\r\n          }\r\n          break;\r\n\r\n        case \"namespace\":\r\n          if (this.tsCheckLineTerminatorAndMatch(tt.name, next)) {\r\n            if (next) this.next();\r\n            return this.tsParseModuleOrNamespaceDeclaration(node);\r\n          }\r\n          break;\r\n\r\n        case \"type\":\r\n          if (this.tsCheckLineTerminatorAndMatch(tt.name, next)) {\r\n            if (next) this.next();\r\n            return this.tsParseTypeAliasDeclaration(node);\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    tsCheckLineTerminatorAndMatch(tokenType: TokenType, next: boolean) {\r\n      return (next || this.match(tokenType)) && !this.isLineTerminator();\r\n    }\r\n\r\n    tsTryParseGenericAsyncArrowFunction(\r\n      startPos: number,\r\n      startLoc: Position,\r\n    ): ?N.ArrowFunctionExpression {\r\n      if (!this.isRelational(\"<\")) {\r\n        return undefined;\r\n      }\r\n      const res: ?N.ArrowFunctionExpression = this.tsTryParseAndCatch(() => {\r\n        const node: N.ArrowFunctionExpression = this.startNodeAt(\r\n          startPos,\r\n          startLoc,\r\n        );\r\n        node.typeParameters = this.tsParseTypeParameters();\r\n        // Don't use overloaded parseFunctionParams which would look for \"<\" again.\r\n        super.parseFunctionParams(node);\r\n        node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\r\n        this.expect(tt.arrow);\r\n        return node;\r\n      });\r\n\r\n      if (!res) {\r\n        return undefined;\r\n      }\r\n\r\n      return this.parseArrowExpression(\r\n        res,\r\n        /* params are already set */ null,\r\n        /* async */ true,\r\n      );\r\n    }\r\n\r\n    tsParseTypeArguments(): N.TsTypeParameterInstantiation {\r\n      const node = this.startNode();\r\n      node.params = this.tsInType(() =>\r\n        // Temporarily remove a JSX parsing context, which makes us scan different tokens.\r\n        this.tsInNoContext(() => {\r\n          this.expectRelational(\"<\");\r\n          return this.tsParseDelimitedList(\r\n            \"TypeParametersOrArguments\",\r\n            this.tsParseType.bind(this),\r\n          );\r\n        }),\r\n      );\r\n      // This reads the next token after the `>` too, so do this in the enclosing context.\r\n      // But be sure not to parse a regex in the jsx expression `<C<number> />`, so set exprAllowed = false\r\n      this.state.exprAllowed = false;\r\n      this.expectRelational(\">\");\r\n      return this.finishNode(node, \"TSTypeParameterInstantiation\");\r\n    }\r\n\r\n    tsIsDeclarationStart(): boolean {\r\n      if (this.match(tt.name)) {\r\n        switch (this.state.value) {\r\n          case \"abstract\":\r\n          case \"declare\":\r\n          case \"enum\":\r\n          case \"interface\":\r\n          case \"module\":\r\n          case \"namespace\":\r\n          case \"type\":\r\n            return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    // ======================================================\r\n    // OVERRIDES\r\n    // ======================================================\r\n\r\n    isExportDefaultSpecifier(): boolean {\r\n      if (this.tsIsDeclarationStart()) return false;\r\n      return super.isExportDefaultSpecifier();\r\n    }\r\n\r\n    parseAssignableListItem(\r\n      allowModifiers: ?boolean,\r\n      decorators: N.Decorator[],\r\n    ): N.Pattern | N.TSParameterProperty {\r\n      // Store original location/position to include modifiers in range\r\n      const startPos = this.state.start;\r\n      const startLoc = this.state.startLoc;\r\n\r\n      let accessibility: ?N.Accessibility;\r\n      let readonly = false;\r\n      if (allowModifiers) {\r\n        accessibility = this.parseAccessModifier();\r\n        readonly = !!this.tsParseModifier([\"readonly\"]);\r\n      }\r\n\r\n      const left = this.parseMaybeDefault();\r\n      this.parseAssignableListItemTypes(left);\r\n      const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\r\n      if (accessibility || readonly) {\r\n        const pp: N.TSParameterProperty = this.startNodeAt(startPos, startLoc);\r\n        if (decorators.length) {\r\n          pp.decorators = decorators;\r\n        }\r\n        if (accessibility) pp.accessibility = accessibility;\r\n        if (readonly) pp.readonly = readonly;\r\n        if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\r\n          throw this.raise(\r\n            pp.start,\r\n            \"A parameter property may not be declared using a binding pattern.\",\r\n          );\r\n        }\r\n        pp.parameter = elt;\r\n        return this.finishNode(pp, \"TSParameterProperty\");\r\n      }\r\n\r\n      if (decorators.length) {\r\n        left.decorators = decorators;\r\n      }\r\n\r\n      return elt;\r\n    }\r\n\r\n    parseFunctionBodyAndFinish(\r\n      node: N.BodilessFunctionOrMethodBase,\r\n      type: string,\r\n      isMethod?: boolean = false,\r\n    ): void {\r\n      if (this.match(tt.colon)) {\r\n        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);\r\n      }\r\n\r\n      const bodilessType =\r\n        type === \"FunctionDeclaration\"\r\n          ? \"TSDeclareFunction\"\r\n          : type === \"ClassMethod\"\r\n          ? \"TSDeclareMethod\"\r\n          : undefined;\r\n      if (bodilessType && !this.match(tt.braceL) && this.isLineTerminator()) {\r\n        this.finishNode(node, bodilessType);\r\n        return;\r\n      }\r\n\r\n      super.parseFunctionBodyAndFinish(node, type, isMethod);\r\n    }\r\n\r\n    checkFunctionStatementId(node: N.Function): void {\r\n      if (!node.body && node.id) {\r\n        this.checkLVal(node.id, BIND_TS_FN_TYPE, null, \"function name\");\r\n      } else {\r\n        super.checkFunctionStatementId(...arguments);\r\n      }\r\n    }\r\n\r\n    parseSubscript(\r\n      base: N.Expression,\r\n      startPos: number,\r\n      startLoc: Position,\r\n      noCalls: ?boolean,\r\n      state: N.ParseSubscriptState,\r\n      maybeAsyncArrow: boolean,\r\n    ): N.Expression {\r\n      if (!this.hasPrecedingLineBreak() && this.match(tt.bang)) {\r\n        this.state.exprAllowed = false;\r\n        this.next();\r\n\r\n        const nonNullExpression: N.TsNonNullExpression = this.startNodeAt(\r\n          startPos,\r\n          startLoc,\r\n        );\r\n        nonNullExpression.expression = base;\r\n        return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\r\n      }\r\n\r\n      if (this.isRelational(\"<\")) {\r\n        // tsTryParseAndCatch is expensive, so avoid if not necessary.\r\n        // There are number of things we are going to \"maybe\" parse, like type arguments on\r\n        // tagged template expressions. If any of them fail, walk it back and continue.\r\n        const result = this.tsTryParseAndCatch(() => {\r\n          if (!noCalls && this.atPossibleAsync(base)) {\r\n            // Almost certainly this is a generic async function `async <T>() => ...\r\n            // But it might be a call with a type argument `async<T>();`\r\n            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(\r\n              startPos,\r\n              startLoc,\r\n            );\r\n            if (asyncArrowFn) {\r\n              return asyncArrowFn;\r\n            }\r\n          }\r\n\r\n          const node: N.CallExpression = this.startNodeAt(startPos, startLoc);\r\n          node.callee = base;\r\n\r\n          const typeArguments = this.tsParseTypeArguments();\r\n\r\n          if (typeArguments) {\r\n            if (!noCalls && this.eat(tt.parenL)) {\r\n              // possibleAsync always false here, because we would have handled it above.\r\n              // $FlowIgnore (won't be any undefined arguments)\r\n              node.arguments = this.parseCallExpressionArguments(\r\n                tt.parenR,\r\n                /* possibleAsync */ false,\r\n              );\r\n              node.typeParameters = typeArguments;\r\n              return this.finishCallExpression(node);\r\n            } else if (this.match(tt.backQuote)) {\r\n              return this.parseTaggedTemplateExpression(\r\n                startPos,\r\n                startLoc,\r\n                base,\r\n                state,\r\n                typeArguments,\r\n              );\r\n            }\r\n          }\r\n\r\n          this.unexpected();\r\n        });\r\n\r\n        if (result) return result;\r\n      }\r\n\r\n      return super.parseSubscript(\r\n        base,\r\n        startPos,\r\n        startLoc,\r\n        noCalls,\r\n        state,\r\n        maybeAsyncArrow,\r\n      );\r\n    }\r\n\r\n    parseNewArguments(node: N.NewExpression): void {\r\n      if (this.isRelational(\"<\")) {\r\n        // tsTryParseAndCatch is expensive, so avoid if not necessary.\r\n        // 99% certain this is `new C<T>();`. But may be `new C < T;`, which is also legal.\r\n        const typeParameters = this.tsTryParseAndCatch(() => {\r\n          const args = this.tsParseTypeArguments();\r\n          if (!this.match(tt.parenL)) this.unexpected();\r\n          return args;\r\n        });\r\n        if (typeParameters) {\r\n          node.typeParameters = typeParameters;\r\n        }\r\n      }\r\n\r\n      super.parseNewArguments(node);\r\n    }\r\n\r\n    parseExprOp(\r\n      left: N.Expression,\r\n      leftStartPos: number,\r\n      leftStartLoc: Position,\r\n      minPrec: number,\r\n      noIn: ?boolean,\r\n    ) {\r\n      if (\r\n        nonNull(tt._in.binop) > minPrec &&\r\n        !this.hasPrecedingLineBreak() &&\r\n        this.isContextual(\"as\")\r\n      ) {\r\n        const node: N.TsAsExpression = this.startNodeAt(\r\n          leftStartPos,\r\n          leftStartLoc,\r\n        );\r\n        node.expression = left;\r\n        const _const = this.tsTryNextParseConstantContext();\r\n        if (_const) {\r\n          node.typeAnnotation = _const;\r\n        } else {\r\n          node.typeAnnotation = this.tsNextThenParseType();\r\n        }\r\n        this.finishNode(node, \"TSAsExpression\");\r\n        return this.parseExprOp(\r\n          node,\r\n          leftStartPos,\r\n          leftStartLoc,\r\n          minPrec,\r\n          noIn,\r\n        );\r\n      }\r\n\r\n      return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn);\r\n    }\r\n\r\n    checkReservedWord(\r\n      word: string, // eslint-disable-line no-unused-vars\r\n      startLoc: number, // eslint-disable-line no-unused-vars\r\n      checkKeywords: boolean, // eslint-disable-line no-unused-vars\r\n      // eslint-disable-next-line no-unused-vars\r\n      isBinding: boolean,\r\n    ): void {\r\n      // Don't bother checking for TypeScript code.\r\n      // Strict mode words may be allowed as in `declare namespace N { const static: number; }`.\r\n      // And we have a type checker anyway, so don't bother having the parser do it.\r\n    }\r\n\r\n    /*\r\n    Don't bother doing this check in TypeScript code because:\r\n    1. We may have a nested export statement with the same name:\r\n      export const x = 0;\r\n      export namespace N {\r\n        export const x = 1;\r\n      }\r\n    2. We have a type checker to warn us about this sort of thing.\r\n    */\r\n    checkDuplicateExports() {}\r\n\r\n    parseImport(node: N.Node): N.AnyImport {\r\n      if (this.match(tt.name) && this.lookahead().type === tt.eq) {\r\n        return this.tsParseImportEqualsDeclaration(node);\r\n      }\r\n      return super.parseImport(node);\r\n    }\r\n\r\n    parseExport(node: N.Node): N.AnyExport {\r\n      if (this.match(tt._import)) {\r\n        // `export import A = B;`\r\n        this.expect(tt._import);\r\n        return this.tsParseImportEqualsDeclaration(node, /* isExport */ true);\r\n      } else if (this.eat(tt.eq)) {\r\n        // `export = x;`\r\n        const assign: N.TsExportAssignment = node;\r\n        assign.expression = this.parseExpression();\r\n        this.semicolon();\r\n        return this.finishNode(assign, \"TSExportAssignment\");\r\n      } else if (this.eatContextual(\"as\")) {\r\n        // `export as namespace A;`\r\n        const decl: N.TsNamespaceExportDeclaration = node;\r\n        // See `parseNamespaceExportDeclaration` in TypeScript's own parser\r\n        this.expectContextual(\"namespace\");\r\n        decl.id = this.parseIdentifier();\r\n        this.semicolon();\r\n        return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\r\n      } else {\r\n        return super.parseExport(node);\r\n      }\r\n    }\r\n\r\n    isAbstractClass(): boolean {\r\n      return (\r\n        this.isContextual(\"abstract\") && this.lookahead().type === tt._class\r\n      );\r\n    }\r\n\r\n    parseExportDefaultExpression(): N.Expression | N.Declaration {\r\n      if (this.isAbstractClass()) {\r\n        const cls = this.startNode();\r\n        this.next(); // Skip \"abstract\"\r\n        this.parseClass(cls, true, true);\r\n        cls.abstract = true;\r\n        return cls;\r\n      }\r\n\r\n      // export default interface allowed in:\r\n      // https://github.com/Microsoft/TypeScript/pull/16040\r\n      if (this.state.value === \"interface\") {\r\n        const result = this.tsParseDeclaration(\r\n          this.startNode(),\r\n          this.state.value,\r\n          true,\r\n        );\r\n\r\n        if (result) return result;\r\n      }\r\n\r\n      return super.parseExportDefaultExpression();\r\n    }\r\n\r\n    parseStatementContent(context: ?string, topLevel: ?boolean): N.Statement {\r\n      if (this.state.type === tt._const) {\r\n        const ahead = this.lookahead();\r\n        if (ahead.type === tt.name && ahead.value === \"enum\") {\r\n          const node: N.TsEnumDeclaration = this.startNode();\r\n          this.expect(tt._const);\r\n          this.expectContextual(\"enum\");\r\n          return this.tsParseEnumDeclaration(node, /* isConst */ true);\r\n        }\r\n      }\r\n      return super.parseStatementContent(context, topLevel);\r\n    }\r\n\r\n    parseAccessModifier(): ?N.Accessibility {\r\n      return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\r\n    }\r\n\r\n    parseClassMember(\r\n      classBody: N.ClassBody,\r\n      member: any,\r\n      state: { hadConstructor: boolean },\r\n      constructorAllowsSuper: boolean,\r\n    ): void {\r\n      const accessibility = this.parseAccessModifier();\r\n      if (accessibility) member.accessibility = accessibility;\r\n\r\n      super.parseClassMember(classBody, member, state, constructorAllowsSuper);\r\n    }\r\n\r\n    parseClassMemberWithIsStatic(\r\n      classBody: N.ClassBody,\r\n      member: any,\r\n      state: { hadConstructor: boolean },\r\n      isStatic: boolean,\r\n      constructorAllowsSuper: boolean,\r\n    ): void {\r\n      const methodOrProp: N.ClassMethod | N.ClassProperty = member;\r\n      const prop: N.ClassProperty = member;\r\n      const propOrIdx: N.ClassProperty | N.TsIndexSignature = member;\r\n\r\n      let abstract = false,\r\n        readonly = false;\r\n\r\n      const mod = this.tsParseModifier([\"abstract\", \"readonly\"]);\r\n      switch (mod) {\r\n        case \"readonly\":\r\n          readonly = true;\r\n          abstract = !!this.tsParseModifier([\"abstract\"]);\r\n          break;\r\n        case \"abstract\":\r\n          abstract = true;\r\n          readonly = !!this.tsParseModifier([\"readonly\"]);\r\n          break;\r\n      }\r\n\r\n      if (abstract) methodOrProp.abstract = true;\r\n      if (readonly) propOrIdx.readonly = true;\r\n\r\n      if (!abstract && !isStatic && !methodOrProp.accessibility) {\r\n        const idx = this.tsTryParseIndexSignature(member);\r\n        if (idx) {\r\n          classBody.body.push(idx);\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (readonly) {\r\n        // Must be a property (if not an index signature).\r\n        methodOrProp.static = isStatic;\r\n        this.parseClassPropertyName(prop);\r\n        this.parsePostMemberNameModifiers(methodOrProp);\r\n        this.pushClassProperty(classBody, prop);\r\n        return;\r\n      }\r\n\r\n      super.parseClassMemberWithIsStatic(\r\n        classBody,\r\n        member,\r\n        state,\r\n        isStatic,\r\n        constructorAllowsSuper,\r\n      );\r\n    }\r\n\r\n    parsePostMemberNameModifiers(\r\n      methodOrProp: N.ClassMethod | N.ClassProperty,\r\n    ): void {\r\n      const optional = this.eat(tt.question);\r\n      if (optional) methodOrProp.optional = true;\r\n    }\r\n\r\n    // Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`\r\n    // is that e.g. `type()` is valid JS, so we must try parsing that first.\r\n    // If it's really a type, we will parse `type` as the statement, and can correct it here\r\n    // by parsing the rest.\r\n    parseExpressionStatement(\r\n      node: N.ExpressionStatement,\r\n      expr: N.Expression,\r\n    ): N.Statement {\r\n      const decl =\r\n        expr.type === \"Identifier\"\r\n          ? this.tsParseExpressionStatement(node, expr)\r\n          : undefined;\r\n      return decl || super.parseExpressionStatement(node, expr);\r\n    }\r\n\r\n    // export type\r\n    // Should be true for anything parsed by `tsTryParseExportDeclaration`.\r\n    shouldParseExportDeclaration(): boolean {\r\n      if (this.tsIsDeclarationStart()) return true;\r\n      return super.shouldParseExportDeclaration();\r\n    }\r\n\r\n    // An apparent conditional expression could actually be an optional parameter in an arrow function.\r\n    parseConditional(\r\n      expr: N.Expression,\r\n      noIn: ?boolean,\r\n      startPos: number,\r\n      startLoc: Position,\r\n      refNeedsArrowPos?: ?Pos,\r\n    ): N.Expression {\r\n      // only do the expensive clone if there is a question mark\r\n      // and if we come from inside parens\r\n      if (!refNeedsArrowPos || !this.match(tt.question)) {\r\n        return super.parseConditional(\r\n          expr,\r\n          noIn,\r\n          startPos,\r\n          startLoc,\r\n          refNeedsArrowPos,\r\n        );\r\n      }\r\n\r\n      const state = this.state.clone();\r\n      try {\r\n        return super.parseConditional(expr, noIn, startPos, startLoc);\r\n      } catch (err) {\r\n        if (!(err instanceof SyntaxError)) {\r\n          // istanbul ignore next: no such error is expected\r\n          throw err;\r\n        }\r\n\r\n        this.state = state;\r\n        refNeedsArrowPos.start = err.pos || this.state.start;\r\n        return expr;\r\n      }\r\n    }\r\n\r\n    // Note: These \"type casts\" are *not* valid TS expressions.\r\n    // But we parse them here and change them when completing the arrow function.\r\n    parseParenItem(\r\n      node: N.Expression,\r\n      startPos: number,\r\n      startLoc: Position,\r\n    ): N.Expression {\r\n      node = super.parseParenItem(node, startPos, startLoc);\r\n      if (this.eat(tt.question)) {\r\n        node.optional = true;\r\n        // Include questionmark in location of node\r\n        // Don't use this.finishNode() as otherwise we might process comments twice and\r\n        // include already consumed parens\r\n        this.resetEndLocation(node);\r\n      }\r\n\r\n      if (this.match(tt.colon)) {\r\n        const typeCastNode: N.TsTypeCastExpression = this.startNodeAt(\r\n          startPos,\r\n          startLoc,\r\n        );\r\n        typeCastNode.expression = node;\r\n        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\r\n\r\n        return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\r\n      }\r\n\r\n      return node;\r\n    }\r\n\r\n    parseExportDeclaration(node: N.ExportNamedDeclaration): ?N.Declaration {\r\n      // Store original location/position\r\n      const startPos = this.state.start;\r\n      const startLoc = this.state.startLoc;\r\n\r\n      // \"export declare\" is equivalent to just \"export\".\r\n      const isDeclare = this.eatContextual(\"declare\");\r\n\r\n      let declaration: ?N.Declaration;\r\n\r\n      if (this.match(tt.name)) {\r\n        declaration = this.tsTryParseExportDeclaration();\r\n      }\r\n      if (!declaration) {\r\n        declaration = super.parseExportDeclaration(node);\r\n      }\r\n\r\n      if (declaration && isDeclare) {\r\n        // Reset location to include `declare` in range\r\n        this.resetStartLocation(declaration, startPos, startLoc);\r\n\r\n        declaration.declare = true;\r\n      }\r\n\r\n      return declaration;\r\n    }\r\n\r\n    parseClassId(\r\n      node: N.Class,\r\n      isStatement: boolean,\r\n      optionalId: ?boolean,\r\n    ): void {\r\n      if ((!isStatement || optionalId) && this.isContextual(\"implements\")) {\r\n        return;\r\n      }\r\n\r\n      super.parseClassId(...arguments);\r\n      const typeParameters = this.tsTryParseTypeParameters();\r\n      if (typeParameters) node.typeParameters = typeParameters;\r\n    }\r\n\r\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\r\n      if (!node.optional && this.eat(tt.bang)) {\r\n        node.definite = true;\r\n      }\r\n\r\n      const type = this.tsTryParseTypeAnnotation();\r\n      if (type) node.typeAnnotation = type;\r\n      return super.parseClassProperty(node);\r\n    }\r\n\r\n    pushClassMethod(\r\n      classBody: N.ClassBody,\r\n      method: N.ClassMethod,\r\n      isGenerator: boolean,\r\n      isAsync: boolean,\r\n      isConstructor: boolean,\r\n      allowsDirectSuper: boolean,\r\n    ): void {\r\n      const typeParameters = this.tsTryParseTypeParameters();\r\n      if (typeParameters) method.typeParameters = typeParameters;\r\n      super.pushClassMethod(\r\n        classBody,\r\n        method,\r\n        isGenerator,\r\n        isAsync,\r\n        isConstructor,\r\n        allowsDirectSuper,\r\n      );\r\n    }\r\n\r\n    pushClassPrivateMethod(\r\n      classBody: N.ClassBody,\r\n      method: N.ClassPrivateMethod,\r\n      isGenerator: boolean,\r\n      isAsync: boolean,\r\n    ): void {\r\n      const typeParameters = this.tsTryParseTypeParameters();\r\n      if (typeParameters) method.typeParameters = typeParameters;\r\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\r\n    }\r\n\r\n    parseClassSuper(node: N.Class): void {\r\n      super.parseClassSuper(node);\r\n      if (node.superClass && this.isRelational(\"<\")) {\r\n        node.superTypeParameters = this.tsParseTypeArguments();\r\n      }\r\n      if (this.eatContextual(\"implements\")) {\r\n        node.implements = this.tsParseHeritageClause(\"implements\");\r\n      }\r\n    }\r\n\r\n    parseObjPropValue(prop: N.ObjectMember, ...args): void {\r\n      const typeParameters = this.tsTryParseTypeParameters();\r\n      if (typeParameters) prop.typeParameters = typeParameters;\r\n\r\n      super.parseObjPropValue(prop, ...args);\r\n    }\r\n\r\n    parseFunctionParams(node: N.Function, allowModifiers?: boolean): void {\r\n      const typeParameters = this.tsTryParseTypeParameters();\r\n      if (typeParameters) node.typeParameters = typeParameters;\r\n      super.parseFunctionParams(node, allowModifiers);\r\n    }\r\n\r\n    // `let x: number;`\r\n    parseVarId(\r\n      decl: N.VariableDeclarator,\r\n      kind: \"var\" | \"let\" | \"const\",\r\n    ): void {\r\n      super.parseVarId(decl, kind);\r\n      if (decl.id.type === \"Identifier\" && this.eat(tt.bang)) {\r\n        decl.definite = true;\r\n      }\r\n\r\n      const type = this.tsTryParseTypeAnnotation();\r\n      if (type) {\r\n        decl.id.typeAnnotation = type;\r\n        this.resetEndLocation(decl.id); // set end position to end of type\r\n      }\r\n    }\r\n\r\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\r\n    parseAsyncArrowFromCallExpression(\r\n      node: N.ArrowFunctionExpression,\r\n      call: N.CallExpression,\r\n    ): N.ArrowFunctionExpression {\r\n      if (this.match(tt.colon)) {\r\n        node.returnType = this.tsParseTypeAnnotation();\r\n      }\r\n      return super.parseAsyncArrowFromCallExpression(node, call);\r\n    }\r\n\r\n    parseMaybeAssign(...args): N.Expression {\r\n      // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.\r\n\r\n      let jsxError: ?SyntaxError;\r\n\r\n      if (this.match(tt.jsxTagStart)) {\r\n        const context = this.curContext();\r\n        assert(context === ct.j_oTag);\r\n        // Only time j_oTag is pushed is right after j_expr.\r\n        assert(this.state.context[this.state.context.length - 2] === ct.j_expr);\r\n\r\n        // Prefer to parse JSX if possible. But may be an arrow fn.\r\n        const state = this.state.clone();\r\n        try {\r\n          return super.parseMaybeAssign(...args);\r\n        } catch (err) {\r\n          if (!(err instanceof SyntaxError)) {\r\n            // istanbul ignore next: no such error is expected\r\n            throw err;\r\n          }\r\n\r\n          this.state = state;\r\n          // Pop the context added by the jsxTagStart.\r\n          assert(this.curContext() === ct.j_oTag);\r\n          this.state.context.pop();\r\n          assert(this.curContext() === ct.j_expr);\r\n          this.state.context.pop();\r\n          jsxError = err;\r\n        }\r\n      }\r\n\r\n      if (jsxError === undefined && !this.isRelational(\"<\")) {\r\n        return super.parseMaybeAssign(...args);\r\n      }\r\n\r\n      // Either way, we're looking at a '<': tt.jsxTagStart or relational.\r\n\r\n      let arrowExpression;\r\n      let typeParameters: N.TsTypeParameterDeclaration;\r\n      const state = this.state.clone();\r\n      try {\r\n        // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\r\n        typeParameters = this.tsParseTypeParameters();\r\n        arrowExpression = super.parseMaybeAssign(...args);\r\n        if (\r\n          arrowExpression.type !== \"ArrowFunctionExpression\" ||\r\n          (arrowExpression.extra && arrowExpression.extra.parenthesized)\r\n        ) {\r\n          this.unexpected(); // Go to the catch block (needs a SyntaxError).\r\n        }\r\n      } catch (err) {\r\n        if (!(err instanceof SyntaxError)) {\r\n          // istanbul ignore next: no such error is expected\r\n          throw err;\r\n        }\r\n\r\n        if (jsxError) {\r\n          throw jsxError;\r\n        }\r\n\r\n        // Try parsing a type cast instead of an arrow function.\r\n        // This will never happen outside of JSX.\r\n        // (Because in JSX the '<' should be a jsxTagStart and not a relational.\r\n        assert(!this.hasPlugin(\"jsx\"));\r\n        // Parsing an arrow function failed, so try a type cast.\r\n        this.state = state;\r\n        // This will start with a type assertion (via parseMaybeUnary).\r\n        // But don't directly call `this.tsParseTypeAssertion` because we want to handle any binary after it.\r\n        return super.parseMaybeAssign(...args);\r\n      }\r\n\r\n      // Correct TypeScript code should have at least 1 type parameter, but don't crash on bad code.\r\n      if (typeParameters && typeParameters.params.length !== 0) {\r\n        this.resetStartLocationFromNode(arrowExpression, typeParameters);\r\n      }\r\n      arrowExpression.typeParameters = typeParameters;\r\n      return arrowExpression;\r\n    }\r\n\r\n    // Handle type assertions\r\n    parseMaybeUnary(refShorthandDefaultPos?: ?Pos): N.Expression {\r\n      if (!this.hasPlugin(\"jsx\") && this.isRelational(\"<\")) {\r\n        return this.tsParseTypeAssertion();\r\n      } else {\r\n        return super.parseMaybeUnary(refShorthandDefaultPos);\r\n      }\r\n    }\r\n\r\n    parseArrow(node: N.ArrowFunctionExpression): ?N.ArrowFunctionExpression {\r\n      if (this.match(tt.colon)) {\r\n        // This is different from how the TS parser does it.\r\n        // TS uses lookahead. The Babel Parser parses it as a parenthesized expression and converts.\r\n        const state = this.state.clone();\r\n        try {\r\n          const returnType = this.tsParseTypeOrTypePredicateAnnotation(\r\n            tt.colon,\r\n          );\r\n          if (this.canInsertSemicolon() || !this.match(tt.arrow)) {\r\n            this.state = state;\r\n            return undefined;\r\n          }\r\n          node.returnType = returnType;\r\n        } catch (err) {\r\n          if (err instanceof SyntaxError) {\r\n            this.state = state;\r\n          } else {\r\n            // istanbul ignore next: no such error is expected\r\n            throw err;\r\n          }\r\n        }\r\n      }\r\n\r\n      return super.parseArrow(node);\r\n    }\r\n\r\n    // Allow type annotations inside of a parameter list.\r\n    parseAssignableListItemTypes(param: N.Pattern) {\r\n      if (this.eat(tt.question)) {\r\n        if (param.type !== \"Identifier\") {\r\n          throw this.raise(\r\n            param.start,\r\n            \"A binding pattern parameter cannot be optional in an implementation signature.\",\r\n          );\r\n        }\r\n\r\n        param.optional = true;\r\n      }\r\n      const type = this.tsTryParseTypeAnnotation();\r\n      if (type) param.typeAnnotation = type;\r\n      this.resetEndLocation(param);\r\n\r\n      return param;\r\n    }\r\n\r\n    toAssignable(\r\n      node: N.Node,\r\n      isBinding: ?boolean,\r\n      contextDescription: string,\r\n    ): N.Node {\r\n      switch (node.type) {\r\n        case \"TSTypeCastExpression\":\r\n          return super.toAssignable(\r\n            this.typeCastToParameter(node),\r\n            isBinding,\r\n            contextDescription,\r\n          );\r\n        case \"TSParameterProperty\":\r\n          return super.toAssignable(node, isBinding, contextDescription);\r\n        case \"TSAsExpression\":\r\n        case \"TSNonNullExpression\":\r\n        case \"TSTypeAssertion\":\r\n          node.expression = this.toAssignable(\r\n            node.expression,\r\n            isBinding,\r\n            contextDescription,\r\n          );\r\n          return node;\r\n        default:\r\n          return super.toAssignable(node, isBinding, contextDescription);\r\n      }\r\n    }\r\n\r\n    checkLVal(\r\n      expr: N.Expression,\r\n      bindingType: BindingTypes = BIND_NONE,\r\n      checkClashes: ?{ [key: string]: boolean },\r\n      contextDescription: string,\r\n    ): void {\r\n      switch (expr.type) {\r\n        case \"TSTypeCastExpression\":\r\n          // Allow \"typecasts\" to appear on the left of assignment expressions,\r\n          // because it may be in an arrow function.\r\n          // e.g. `const f = (foo: number = 0) => foo;`\r\n          return;\r\n        case \"TSParameterProperty\":\r\n          this.checkLVal(\r\n            expr.parameter,\r\n            bindingType,\r\n            checkClashes,\r\n            \"parameter property\",\r\n          );\r\n          return;\r\n        case \"TSAsExpression\":\r\n        case \"TSNonNullExpression\":\r\n        case \"TSTypeAssertion\":\r\n          this.checkLVal(\r\n            expr.expression,\r\n            bindingType,\r\n            checkClashes,\r\n            contextDescription,\r\n          );\r\n          return;\r\n        default:\r\n          super.checkLVal(expr, bindingType, checkClashes, contextDescription);\r\n          return;\r\n      }\r\n    }\r\n\r\n    parseBindingAtom(): N.Pattern {\r\n      switch (this.state.type) {\r\n        case tt._this:\r\n          // \"this\" may be the name of a parameter, so allow it.\r\n          return this.parseIdentifier(/* liberal */ true);\r\n        default:\r\n          return super.parseBindingAtom();\r\n      }\r\n    }\r\n\r\n    parseMaybeDecoratorArguments(expr: N.Expression): N.Expression {\r\n      if (this.isRelational(\"<\")) {\r\n        const typeArguments = this.tsParseTypeArguments();\r\n\r\n        if (this.match(tt.parenL)) {\r\n          const call = super.parseMaybeDecoratorArguments(expr);\r\n          call.typeParameters = typeArguments;\r\n          return call;\r\n        }\r\n\r\n        this.unexpected(this.state.start, tt.parenL);\r\n      }\r\n\r\n      return super.parseMaybeDecoratorArguments(expr);\r\n    }\r\n\r\n    // === === === === === === === === === === === === === === === ===\r\n    // Note: All below methods are duplicates of something in flow.js.\r\n    // Not sure what the best way to combine these is.\r\n    // === === === === === === === === === === === === === === === ===\r\n\r\n    isClassMethod(): boolean {\r\n      return this.isRelational(\"<\") || super.isClassMethod();\r\n    }\r\n\r\n    isClassProperty(): boolean {\r\n      return (\r\n        this.match(tt.bang) || this.match(tt.colon) || super.isClassProperty()\r\n      );\r\n    }\r\n\r\n    parseMaybeDefault(...args): N.Pattern {\r\n      const node = super.parseMaybeDefault(...args);\r\n\r\n      if (\r\n        node.type === \"AssignmentPattern\" &&\r\n        node.typeAnnotation &&\r\n        node.right.start < node.typeAnnotation.start\r\n      ) {\r\n        this.raise(\r\n          node.typeAnnotation.start,\r\n          \"Type annotations must come before default assignments, \" +\r\n            \"e.g. instead of `age = 25: number` use `age: number = 25`\",\r\n        );\r\n      }\r\n\r\n      return node;\r\n    }\r\n\r\n    // ensure that inside types, we bypass the jsx parser plugin\r\n    getTokenFromCode(code: number): void {\r\n      if (this.state.inType && (code === 62 || code === 60)) {\r\n        return this.finishOp(tt.relational, 1);\r\n      } else {\r\n        return super.getTokenFromCode(code);\r\n      }\r\n    }\r\n\r\n    toAssignableList(\r\n      exprList: N.Expression[],\r\n      isBinding: ?boolean,\r\n      contextDescription: string,\r\n    ): $ReadOnlyArray<N.Pattern> {\r\n      for (let i = 0; i < exprList.length; i++) {\r\n        const expr = exprList[i];\r\n        if (!expr) continue;\r\n        switch (expr.type) {\r\n          case \"TSTypeCastExpression\":\r\n            exprList[i] = this.typeCastToParameter(expr);\r\n            break;\r\n          case \"TSAsExpression\":\r\n          case \"TSTypeAssertion\":\r\n            this.raise(\r\n              expr.start,\r\n              \"Unexpected type cast in parameter position.\",\r\n            );\r\n            break;\r\n        }\r\n      }\r\n      return super.toAssignableList(exprList, isBinding, contextDescription);\r\n    }\r\n\r\n    typeCastToParameter(node: N.TsTypeCastExpression): N.Node {\r\n      node.expression.typeAnnotation = node.typeAnnotation;\r\n\r\n      this.resetEndLocation(\r\n        node.expression,\r\n        node.typeAnnotation.end,\r\n        node.typeAnnotation.loc.end,\r\n      );\r\n\r\n      return node.expression;\r\n    }\r\n\r\n    toReferencedList(\r\n      exprList: $ReadOnlyArray<?N.Expression>,\r\n      isInParens?: boolean, // eslint-disable-line no-unused-vars\r\n    ): $ReadOnlyArray<?N.Expression> {\r\n      for (let i = 0; i < exprList.length; i++) {\r\n        const expr = exprList[i];\r\n        if (\r\n          expr &&\r\n          expr._exprListItem &&\r\n          expr.type === \"TsTypeCastExpression\"\r\n        ) {\r\n          this.raise(expr.start, \"Did not expect a type annotation here.\");\r\n        }\r\n      }\r\n\r\n      return exprList;\r\n    }\r\n\r\n    shouldParseArrow() {\r\n      return this.match(tt.colon) || super.shouldParseArrow();\r\n    }\r\n\r\n    shouldParseAsyncArrow(): boolean {\r\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\r\n    }\r\n\r\n    canHaveLeadingDecorator() {\r\n      // Avoid unnecessary lookahead in checking for abstract class unless needed!\r\n      return super.canHaveLeadingDecorator() || this.isAbstractClass();\r\n    }\r\n\r\n    jsxParseOpeningElementAfterName(\r\n      node: N.JSXOpeningElement,\r\n    ): N.JSXOpeningElement {\r\n      if (this.isRelational(\"<\")) {\r\n        const typeArguments = this.tsTryParseAndCatch(() =>\r\n          this.tsParseTypeArguments(),\r\n        );\r\n        if (typeArguments) node.typeParameters = typeArguments;\r\n      }\r\n      return super.jsxParseOpeningElementAfterName(node);\r\n    }\r\n\r\n    getGetterSetterExpectedParamCount(\r\n      method: N.ObjectMethod | N.ClassMethod,\r\n    ): number {\r\n      const baseCount = super.getGetterSetterExpectedParamCount(method);\r\n      const firstParam = method.params[0];\r\n      const hasContextParam =\r\n        firstParam &&\r\n        firstParam.type === \"Identifier\" &&\r\n        firstParam.name === \"this\";\r\n\r\n      return hasContextParam ? baseCount + 1 : baseCount;\r\n    }\r\n  };\r\n","// @flow\r\n\r\nimport * as charCodes from \"charcodes\";\r\n\r\nimport { types as tt, TokenType } from \"../tokenizer/types\";\r\nimport type Parser from \"../parser\";\r\nimport * as N from \"../types\";\r\n\r\ntt.placeholder = new TokenType(\"%%\", { startsExpr: true });\r\n\r\nexport type PlaceholderTypes =\r\n  | \"Identifier\"\r\n  | \"StringLiteral\"\r\n  | \"Expression\"\r\n  | \"Statement\"\r\n  | \"Declaration\"\r\n  | \"BlockStatement\"\r\n  | \"ClassBody\"\r\n  | \"Pattern\";\r\n\r\n// $PropertyType doesn't support enums. Use a fake \"switch\" (GetPlaceholderNode)\r\n//type MaybePlaceholder<T: PlaceholderTypes> = $PropertyType<N, T> | N.Placeholder<T>;\r\n\r\ntype _Switch<Value, Cases, Index> = $Call<\r\n  (\r\n    $ElementType<$ElementType<Cases, Index>, 0>,\r\n  ) => $ElementType<$ElementType<Cases, Index>, 1>,\r\n  Value,\r\n>;\r\ntype $Switch<Value, Cases> = _Switch<Value, Cases, *>;\r\n\r\ntype NodeOf<T: PlaceholderTypes> = $Switch<\r\n  T,\r\n  [\r\n    [\"Identifier\", N.Identifier],\r\n    [\"StringLiteral\", N.StringLiteral],\r\n    [\"Expression\", N.Expression],\r\n    [\"Statement\", N.Statement],\r\n    [\"Declaration\", N.Declaration],\r\n    [\"BlockStatement\", N.BlockStatement],\r\n    [\"ClassBody\", N.ClassBody],\r\n    [\"Pattern\", N.Pattern],\r\n  ],\r\n>;\r\n\r\n// Placeholder<T> breaks everything, because its type is incompatible with\r\n// the substituted nodes.\r\ntype MaybePlaceholder<T: PlaceholderTypes> = NodeOf<T>; // | Placeholder<T>\r\n\r\nexport default (superClass: Class<Parser>): Class<Parser> =>\r\n  class extends superClass {\r\n    parsePlaceholder<T: PlaceholderTypes>(\r\n      expectedNode: T,\r\n    ): /*?N.Placeholder<T>*/ ?MaybePlaceholder<T> {\r\n      if (this.match(tt.placeholder)) {\r\n        const node = this.startNode();\r\n        this.next();\r\n        this.assertNoSpace(\"Unexpected space in placeholder.\");\r\n\r\n        // We can't use this.parseIdentifier because\r\n        // we don't want nested placeholders.\r\n        node.name = super.parseIdentifier(/* liberal */ true);\r\n\r\n        this.assertNoSpace(\"Unexpected space in placeholder.\");\r\n        this.expect(tt.placeholder);\r\n        return this.finishPlaceholder(node, expectedNode);\r\n      }\r\n    }\r\n\r\n    finishPlaceholder<T: PlaceholderTypes>(\r\n      node: N.Node,\r\n      expectedNode: T,\r\n    ): /*N.Placeholder<T>*/ MaybePlaceholder<T> {\r\n      const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\r\n      node.expectedNode = expectedNode;\r\n\r\n      return isFinished ? node : this.finishNode(node, \"Placeholder\");\r\n    }\r\n\r\n    /* ============================================================ *\r\n     * tokenizer/index.js                                           *\r\n     * ============================================================ */\r\n\r\n    getTokenFromCode(code: number) {\r\n      if (\r\n        code === charCodes.percentSign &&\r\n        this.input.charCodeAt(this.state.pos + 1) === charCodes.percentSign\r\n      ) {\r\n        return this.finishOp(tt.placeholder, 2);\r\n      }\r\n\r\n      return super.getTokenFromCode(...arguments);\r\n    }\r\n\r\n    /* ============================================================ *\r\n     * parser/expression.js                                         *\r\n     * ============================================================ */\r\n\r\n    parseExprAtom(): MaybePlaceholder<\"Expression\"> {\r\n      return (\r\n        this.parsePlaceholder(\"Expression\") || super.parseExprAtom(...arguments)\r\n      );\r\n    }\r\n\r\n    parseIdentifier(): MaybePlaceholder<\"Identifier\"> {\r\n      // NOTE: This function only handles identifiers outside of\r\n      // expressions and binding patterns, since they are already\r\n      // handled by the parseExprAtom and parseBindingAtom functions.\r\n      // This is needed, for example, to parse \"class %%NAME%% {}\".\r\n      return (\r\n        this.parsePlaceholder(\"Identifier\") ||\r\n        super.parseIdentifier(...arguments)\r\n      );\r\n    }\r\n\r\n    checkReservedWord(word: string): void {\r\n      // Sometimes we call #checkReservedWord(node.name), expecting\r\n      // that node is an Identifier. If it is a Placeholder, name\r\n      // will be undefined.\r\n      if (word !== undefined) super.checkReservedWord(...arguments);\r\n    }\r\n\r\n    /* ============================================================ *\r\n     * parser/lval.js                                               *\r\n     * ============================================================ */\r\n\r\n    parseBindingAtom(): MaybePlaceholder<\"Pattern\"> {\r\n      return (\r\n        this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom(...arguments)\r\n      );\r\n    }\r\n\r\n    checkLVal(expr: N.Expression): void {\r\n      if (expr.type !== \"Placeholder\") super.checkLVal(...arguments);\r\n    }\r\n\r\n    toAssignable(node: N.Node): N.Node {\r\n      if (\r\n        node &&\r\n        node.type === \"Placeholder\" &&\r\n        node.expectedNode === \"Expression\"\r\n      ) {\r\n        node.expectedNode = \"Pattern\";\r\n        return node;\r\n      }\r\n      return super.toAssignable(...arguments);\r\n    }\r\n\r\n    /* ============================================================ *\r\n     * parser/statement.js                                          *\r\n     * ============================================================ */\r\n\r\n    verifyBreakContinue(node: N.BreakStatement | N.ContinueStatement) {\r\n      if (node.label && node.label.type === \"Placeholder\") return;\r\n      super.verifyBreakContinue(...arguments);\r\n    }\r\n\r\n    parseExpressionStatement(\r\n      node: MaybePlaceholder<\"Statement\">,\r\n      expr: N.Expression,\r\n    ): MaybePlaceholder<\"Statement\"> {\r\n      if (\r\n        expr.type !== \"Placeholder\" ||\r\n        (expr.extra && expr.extra.parenthesized)\r\n      ) {\r\n        return super.parseExpressionStatement(...arguments);\r\n      }\r\n\r\n      if (this.match(tt.colon)) {\r\n        const stmt: N.LabeledStatement = node;\r\n        stmt.label = this.finishPlaceholder(expr, \"Identifier\");\r\n        this.next();\r\n        stmt.body = this.parseStatement(\"label\");\r\n        return this.finishNode(stmt, \"LabeledStatement\");\r\n      }\r\n\r\n      this.semicolon();\r\n\r\n      node.name = expr.name;\r\n      return this.finishPlaceholder(node, \"Statement\");\r\n    }\r\n\r\n    parseBlock(): MaybePlaceholder<\"BlockStatement\"> {\r\n      return (\r\n        this.parsePlaceholder(\"BlockStatement\") ||\r\n        super.parseBlock(...arguments)\r\n      );\r\n    }\r\n\r\n    parseFunctionId(): ?MaybePlaceholder<\"Identifier\"> {\r\n      return (\r\n        this.parsePlaceholder(\"Identifier\") ||\r\n        super.parseFunctionId(...arguments)\r\n      );\r\n    }\r\n\r\n    parseClass<T: N.Class>(\r\n      node: T,\r\n      isStatement: /* T === ClassDeclaration */ boolean,\r\n      optionalId?: boolean,\r\n    ): T {\r\n      const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\r\n\r\n      this.next();\r\n      this.takeDecorators(node);\r\n\r\n      const placeholder = this.parsePlaceholder(\"Identifier\");\r\n      if (placeholder) {\r\n        if (\r\n          this.match(tt._extends) ||\r\n          this.match(tt.placeholder) ||\r\n          this.match(tt.braceL)\r\n        ) {\r\n          node.id = placeholder;\r\n        } else if (optionalId || !isStatement) {\r\n          node.id = null;\r\n          node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\r\n          return this.finishNode(node, type);\r\n        } else {\r\n          this.unexpected(null, \"A class name is required\");\r\n        }\r\n      } else {\r\n        this.parseClassId(node, isStatement, optionalId);\r\n      }\r\n\r\n      this.parseClassSuper(node);\r\n      node.body =\r\n        this.parsePlaceholder(\"ClassBody\") ||\r\n        this.parseClassBody(!!node.superClass);\r\n      return this.finishNode(node, type);\r\n    }\r\n\r\n    parseExport(node: N.Node): N.Node {\r\n      const placeholder = this.parsePlaceholder(\"Identifier\");\r\n      if (!placeholder) return super.parseExport(...arguments);\r\n\r\n      if (!this.isContextual(\"from\") && !this.match(tt.comma)) {\r\n        // export %%DECL%%;\r\n        node.specifiers = [];\r\n        node.source = null;\r\n        node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\r\n        return this.finishNode(node, \"ExportNamedDeclaration\");\r\n      }\r\n\r\n      // export %%NAME%% from \"foo\";\r\n      this.expectPlugin(\"exportDefaultFrom\");\r\n      const specifier = this.startNode();\r\n      specifier.exported = placeholder;\r\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\r\n\r\n      return super.parseExport(node);\r\n    }\r\n\r\n    maybeParseExportDefaultSpecifier(node: N.Node): boolean {\r\n      if (node.specifiers && node.specifiers.length > 0) {\r\n        // \"export %%NAME%%\" has already been parsed by #parseExport.\r\n        return true;\r\n      }\r\n      return super.maybeParseExportDefaultSpecifier(...arguments);\r\n    }\r\n\r\n    checkExport(node: N.ExportNamedDeclaration): void {\r\n      const { specifiers } = node;\r\n      if (specifiers && specifiers.length) {\r\n        node.specifiers = specifiers.filter(\r\n          node => node.exported.type === \"Placeholder\",\r\n        );\r\n      }\r\n      super.checkExport(node);\r\n      node.specifiers = specifiers;\r\n    }\r\n\r\n    parseImport(\r\n      node: N.Node,\r\n    ): N.ImportDeclaration | N.TsImportEqualsDeclaration {\r\n      const placeholder = this.parsePlaceholder(\"Identifier\");\r\n      if (!placeholder) return super.parseImport(...arguments);\r\n\r\n      node.specifiers = [];\r\n\r\n      if (!this.isContextual(\"from\") && !this.match(tt.comma)) {\r\n        // import %%STRING%%;\r\n        node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\r\n        this.semicolon();\r\n        return this.finishNode(node, \"ImportDeclaration\");\r\n      }\r\n\r\n      // import %%DEFAULT%% ...\r\n      const specifier = this.startNodeAtNode(placeholder);\r\n      specifier.local = placeholder;\r\n      this.finishNode(specifier, \"ImportDefaultSpecifier\");\r\n      node.specifiers.push(specifier);\r\n\r\n      if (this.eat(tt.comma)) {\r\n        // import %%DEFAULT%%, * as ...\r\n        const hasStarImport = this.maybeParseStarImportSpecifier(node);\r\n\r\n        // import %%DEFAULT%%, { ...\r\n        if (!hasStarImport) this.parseNamedImportSpecifiers(node);\r\n      }\r\n\r\n      this.expectContextual(\"from\");\r\n      node.source = this.parseImportSource();\r\n      this.semicolon();\r\n      return this.finishNode(node, \"ImportDeclaration\");\r\n    }\r\n\r\n    parseImportSource(): MaybePlaceholder<\"StringLiteral\"> {\r\n      // import ... from %%STRING%%;\r\n\r\n      return (\r\n        this.parsePlaceholder(\"StringLiteral\") ||\r\n        super.parseImportSource(...arguments)\r\n      );\r\n    }\r\n  };\r\n","// @flow\r\n\r\nimport type Parser from \"./parser\";\r\n\r\nexport type Plugin = string | [string, Object];\r\n\r\nexport type PluginList = $ReadOnlyArray<Plugin>;\r\n\r\nexport type MixinPlugin = (superClass: Class<Parser>) => Class<Parser>;\r\n\r\nexport function hasPlugin(plugins: PluginList, name: string): boolean {\r\n  return plugins.some(plugin => {\r\n    if (Array.isArray(plugin)) {\r\n      return plugin[0] === name;\r\n    } else {\r\n      return plugin === name;\r\n    }\r\n  });\r\n}\r\n\r\nexport function getPluginOption(\r\n  plugins: PluginList,\r\n  name: string,\r\n  option: string,\r\n) {\r\n  const plugin = plugins.find(plugin => {\r\n    if (Array.isArray(plugin)) {\r\n      return plugin[0] === name;\r\n    } else {\r\n      return plugin === name;\r\n    }\r\n  });\r\n\r\n  if (plugin && Array.isArray(plugin)) {\r\n    return plugin[1][option];\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nconst PIPELINE_PROPOSALS = [\"minimal\", \"smart\"];\r\n\r\nexport function validatePlugins(plugins: PluginList) {\r\n  if (hasPlugin(plugins, \"decorators\")) {\r\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\r\n      throw new Error(\r\n        \"Cannot use the decorators and decorators-legacy plugin together\",\r\n      );\r\n    }\r\n\r\n    const decoratorsBeforeExport = getPluginOption(\r\n      plugins,\r\n      \"decorators\",\r\n      \"decoratorsBeforeExport\",\r\n    );\r\n    if (decoratorsBeforeExport == null) {\r\n      throw new Error(\r\n        \"The 'decorators' plugin requires a 'decoratorsBeforeExport' option,\" +\r\n          \" whose value must be a boolean. If you are migrating from\" +\r\n          \" Babylon/Babel 6 or want to use the old decorators proposal, you\" +\r\n          \" should use the 'decorators-legacy' plugin instead of 'decorators'.\",\r\n      );\r\n    } else if (typeof decoratorsBeforeExport !== \"boolean\") {\r\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\r\n    }\r\n  }\r\n\r\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\r\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\r\n  }\r\n\r\n  if (\r\n    hasPlugin(plugins, \"pipelineOperator\") &&\r\n    !PIPELINE_PROPOSALS.includes(\r\n      getPluginOption(plugins, \"pipelineOperator\", \"proposal\"),\r\n    )\r\n  ) {\r\n    throw new Error(\r\n      \"'pipelineOperator' requires 'proposal' option whose value should be one of: \" +\r\n        PIPELINE_PROPOSALS.map(p => `'${p}'`).join(\", \"),\r\n    );\r\n  }\r\n}\r\n\r\n// These plugins are defined using a mixin which extends the parser class.\r\n\r\nimport estree from \"./plugins/estree\";\r\nimport flow from \"./plugins/flow\";\r\nimport jsx from \"./plugins/jsx\";\r\nimport typescript from \"./plugins/typescript\";\r\nimport placeholders from \"./plugins/placeholders\";\r\n\r\n// NOTE: order is important. estree must come first; placeholders must come last.\r\nexport const mixinPlugins: { [name: string]: MixinPlugin } = {\r\n  estree,\r\n  jsx,\r\n  flow,\r\n  typescript,\r\n  placeholders,\r\n};\r\n\r\nexport const mixinPluginNames: $ReadOnlyArray<string> = Object.keys(\r\n  mixinPlugins,\r\n);\r\n","// @flow\r\n\r\nimport type { PluginList } from \"./plugin-utils\";\r\n\r\n// A second optional argument can be given to further configure\r\n// the parser process. These options are recognized:\r\n\r\nexport type SourceType = \"script\" | \"module\" | \"unambiguous\";\r\n\r\nexport type Options = {\r\n  sourceType: SourceType,\r\n  sourceFilename?: string,\r\n  startLine: number,\r\n  allowAwaitOutsideFunction: boolean,\r\n  allowReturnOutsideFunction: boolean,\r\n  allowImportExportEverywhere: boolean,\r\n  allowSuperOutsideMethod: boolean,\r\n  plugins: PluginList,\r\n  strictMode: ?boolean,\r\n  ranges: boolean,\r\n  tokens: boolean,\r\n  createParenthesizedExpressions: boolean,\r\n};\r\n\r\nexport const defaultOptions: Options = {\r\n  // Source type (\"script\" or \"module\") for different semantics\r\n  sourceType: \"script\",\r\n  // Source filename.\r\n  sourceFilename: undefined,\r\n  // Line from which to start counting source. Useful for\r\n  // integration with other tools.\r\n  startLine: 1,\r\n  // When enabled, await at the top level is not considered an\r\n  // error.\r\n  allowAwaitOutsideFunction: false,\r\n  // When enabled, a return at the top level is not considered an\r\n  // error.\r\n  allowReturnOutsideFunction: false,\r\n  // When enabled, import/export statements are not constrained to\r\n  // appearing at the top of the program.\r\n  allowImportExportEverywhere: false,\r\n  // TODO\r\n  allowSuperOutsideMethod: false,\r\n  // An array of plugins to enable\r\n  plugins: [],\r\n  // TODO\r\n  strictMode: null,\r\n  // Nodes have their start and end characters offsets recorded in\r\n  // `start` and `end` properties (directly on the node, rather than\r\n  // the `loc` object, which holds line/column data. To also add a\r\n  // [semi-standardized][range] `range` property holding a `[start,\r\n  // end]` array with the same numbers, set the `ranges` option to\r\n  // `true`.\r\n  //\r\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\r\n  ranges: false,\r\n  // Adds all parsed tokens to a `tokens` property on the `File` node\r\n  tokens: false,\r\n  // Whether to create ParenthesizedExpression AST nodes (if false\r\n  // the parser sets extra.parenthesized on the expression nodes instead).\r\n  createParenthesizedExpressions: false,\r\n};\r\n\r\n// Interpret and default an options object\r\n\r\nexport function getOptions(opts: ?Options): Options {\r\n  const options: any = {};\r\n  for (const key of Object.keys(defaultOptions)) {\r\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\r\n  }\r\n  return options;\r\n}\r\n","export const questionMark: 1567 = 1567; //؟\r\nexport const breakKeyword: \"خروج\" = \"خروج\"; //break","// @flow\r\n\r\nimport { lineBreakG } from \"./whitespace\";\r\n\r\nexport type Pos = {\r\n  start: number,\r\n};\r\n\r\n// These are used when `options.locations` is on, for the\r\n// `startLoc` and `endLoc` properties.\r\n\r\nexport class Position {\r\n  line: number;\r\n  column: number;\r\n\r\n  constructor(line: number, col: number) {\r\n    this.line = line;\r\n    this.column = col;\r\n  }\r\n}\r\n\r\nexport class SourceLocation {\r\n  start: Position;\r\n  end: Position;\r\n  filename: string;\r\n  identifierName: ?string;\r\n\r\n  constructor(start: Position, end?: Position) {\r\n    this.start = start;\r\n    // $FlowIgnore (may start as null, but initialized later)\r\n    this.end = end;\r\n  }\r\n}\r\n\r\n// The `getLineInfo` function is mostly useful when the\r\n// `locations` option is off (for performance reasons) and you\r\n// want to find the line/column position for a given character\r\n// offset. `input` should be the code string that the offset refers\r\n// into.\r\n\r\nexport function getLineInfo(input: string, offset: number): Position {\r\n  let line = 1;\r\n  let lineStart = 0;\r\n  let match;\r\n  lineBreakG.lastIndex = 0;\r\n  while ((match = lineBreakG.exec(input)) && match.index < offset) {\r\n    line++;\r\n    lineStart = lineBreakG.lastIndex;\r\n  }\r\n\r\n  return new Position(line, offset - lineStart);\r\n}\r\n","// @flow\r\n\r\nimport type { Options } from \"../options\";\r\nimport type State from \"../tokenizer/state\";\r\nimport type { PluginsMap } from \"./index\";\r\nimport type ScopeHandler from \"../util/scope\";\r\n\r\nexport default class BaseParser {\r\n  // Properties set by constructor in index.js\r\n  options: Options;\r\n  inModule: boolean;\r\n  scope: ScopeHandler<*>;\r\n  plugins: PluginsMap;\r\n  filename: ?string;\r\n  sawUnambiguousESM: boolean = false;\r\n\r\n  // Initialized by Tokenizer\r\n  state: State;\r\n  // input and length are not in state as they are constant and we do\r\n  // not want to ever copy them, which happens if state gets cloned\r\n  input: string;\r\n  length: number;\r\n\r\n  hasPlugin(name: string): boolean {\r\n    return this.plugins.has(name);\r\n  }\r\n\r\n  getPluginOption(plugin: string, name: string) {\r\n    // $FlowIssue\r\n    if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];\r\n  }\r\n}\r\n","// @flow\r\n\r\n/**\r\n * Based on the comment attachment algorithm used in espree and estraverse.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright\r\n *   notice, this list of conditions and the following disclaimer.\r\n * * Redistributions in binary form must reproduce the above copyright\r\n *   notice, this list of conditions and the following disclaimer in the\r\n *   documentation and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nimport BaseParser from \"./base\";\r\nimport type { Comment, Node } from \"../types\";\r\n\r\nfunction last<T>(stack: $ReadOnlyArray<T>): T {\r\n  return stack[stack.length - 1];\r\n}\r\n\r\nexport default class CommentsParser extends BaseParser {\r\n  addComment(comment: Comment): void {\r\n    if (this.filename) comment.loc.filename = this.filename;\r\n    this.state.trailingComments.push(comment);\r\n    this.state.leadingComments.push(comment);\r\n  }\r\n\r\n  processComment(node: Node): void {\r\n    if (node.type === \"Program\" && node.body.length > 0) return;\r\n\r\n    const stack = this.state.commentStack;\r\n\r\n    let firstChild, lastChild, trailingComments, i, j;\r\n\r\n    if (this.state.trailingComments.length > 0) {\r\n      // If the first comment in trailingComments comes after the\r\n      // current node, then we're good - all comments in the array will\r\n      // come after the node and so it's safe to add them as official\r\n      // trailingComments.\r\n      if (this.state.trailingComments[0].start >= node.end) {\r\n        trailingComments = this.state.trailingComments;\r\n        this.state.trailingComments = [];\r\n      } else {\r\n        // Otherwise, if the first comment doesn't come after the\r\n        // current node, that means we have a mix of leading and trailing\r\n        // comments in the array and that leadingComments contains the\r\n        // same items as trailingComments. Reset trailingComments to\r\n        // zero items and we'll handle this by evaluating leadingComments\r\n        // later.\r\n        this.state.trailingComments.length = 0;\r\n      }\r\n    } else if (stack.length > 0) {\r\n      const lastInStack = last(stack);\r\n      if (\r\n        lastInStack.trailingComments &&\r\n        lastInStack.trailingComments[0].start >= node.end\r\n      ) {\r\n        trailingComments = lastInStack.trailingComments;\r\n        delete lastInStack.trailingComments;\r\n      }\r\n    }\r\n\r\n    // Eating the stack.\r\n    if (stack.length > 0 && last(stack).start >= node.start) {\r\n      firstChild = stack.pop();\r\n    }\r\n\r\n    while (stack.length > 0 && last(stack).start >= node.start) {\r\n      lastChild = stack.pop();\r\n    }\r\n\r\n    if (!lastChild && firstChild) lastChild = firstChild;\r\n\r\n    // Attach comments that follow a trailing comma on the last\r\n    // property in an object literal or a trailing comma in function arguments\r\n    // as trailing comments\r\n    if (firstChild && this.state.leadingComments.length > 0) {\r\n      const lastComment = last(this.state.leadingComments);\r\n\r\n      if (firstChild.type === \"ObjectProperty\") {\r\n        if (lastComment.start >= node.start) {\r\n          if (this.state.commentPreviousNode) {\r\n            for (j = 0; j < this.state.leadingComments.length; j++) {\r\n              if (\r\n                this.state.leadingComments[j].end <\r\n                this.state.commentPreviousNode.end\r\n              ) {\r\n                this.state.leadingComments.splice(j, 1);\r\n                j--;\r\n              }\r\n            }\r\n\r\n            if (this.state.leadingComments.length > 0) {\r\n              firstChild.trailingComments = this.state.leadingComments;\r\n              this.state.leadingComments = [];\r\n            }\r\n          }\r\n        }\r\n      } else if (\r\n        node.type === \"CallExpression\" &&\r\n        node.arguments &&\r\n        node.arguments.length\r\n      ) {\r\n        const lastArg = last(node.arguments);\r\n\r\n        if (\r\n          lastArg &&\r\n          lastComment.start >= lastArg.start &&\r\n          lastComment.end <= node.end\r\n        ) {\r\n          if (this.state.commentPreviousNode) {\r\n            for (j = 0; j < this.state.leadingComments.length; j++) {\r\n              if (\r\n                this.state.leadingComments[j].end <\r\n                this.state.commentPreviousNode.end\r\n              ) {\r\n                this.state.leadingComments.splice(j, 1);\r\n                j--;\r\n              }\r\n            }\r\n            if (this.state.leadingComments.length > 0) {\r\n              lastArg.trailingComments = this.state.leadingComments;\r\n              this.state.leadingComments = [];\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (lastChild) {\r\n      if (lastChild.leadingComments) {\r\n        if (\r\n          lastChild !== node &&\r\n          lastChild.leadingComments.length > 0 &&\r\n          last(lastChild.leadingComments).end <= node.start\r\n        ) {\r\n          node.leadingComments = lastChild.leadingComments;\r\n          delete lastChild.leadingComments;\r\n        } else {\r\n          // A leading comment for an anonymous class had been stolen by its first ClassMethod,\r\n          // so this takes back the leading comment.\r\n          // See also: https://github.com/eslint/espree/issues/158\r\n          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {\r\n            if (lastChild.leadingComments[i].end <= node.start) {\r\n              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else if (this.state.leadingComments.length > 0) {\r\n      if (last(this.state.leadingComments).end <= node.start) {\r\n        if (this.state.commentPreviousNode) {\r\n          for (j = 0; j < this.state.leadingComments.length; j++) {\r\n            if (\r\n              this.state.leadingComments[j].end <\r\n              this.state.commentPreviousNode.end\r\n            ) {\r\n              this.state.leadingComments.splice(j, 1);\r\n              j--;\r\n            }\r\n          }\r\n        }\r\n        if (this.state.leadingComments.length > 0) {\r\n          node.leadingComments = this.state.leadingComments;\r\n          this.state.leadingComments = [];\r\n        }\r\n      } else {\r\n        // https://github.com/eslint/espree/issues/2\r\n        //\r\n        // In special cases, such as return (without a value) and\r\n        // debugger, all comments will end up as leadingComments and\r\n        // will otherwise be eliminated. This step runs when the\r\n        // commentStack is empty and there are comments left\r\n        // in leadingComments.\r\n        //\r\n        // This loop figures out the stopping point between the actual\r\n        // leading and trailing comments by finding the location of the\r\n        // first comment that comes after the given node.\r\n        for (i = 0; i < this.state.leadingComments.length; i++) {\r\n          if (this.state.leadingComments[i].end > node.start) {\r\n            break;\r\n          }\r\n        }\r\n\r\n        // Split the array based on the location of the first comment\r\n        // that comes after the node. Keep in mind that this could\r\n        // result in an empty array, and if so, the array must be\r\n        // deleted.\r\n        const leadingComments = this.state.leadingComments.slice(0, i);\r\n\r\n        if (leadingComments.length) {\r\n          node.leadingComments = leadingComments;\r\n        }\r\n\r\n        // Similarly, trailing comments are attached later. The variable\r\n        // must be reset to null if there are no trailing comments.\r\n        trailingComments = this.state.leadingComments.slice(i);\r\n        if (trailingComments.length === 0) {\r\n          trailingComments = null;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.state.commentPreviousNode = node;\r\n\r\n    if (trailingComments) {\r\n      if (\r\n        trailingComments.length &&\r\n        trailingComments[0].start >= node.start &&\r\n        last(trailingComments).end <= node.end\r\n      ) {\r\n        node.innerComments = trailingComments;\r\n      } else {\r\n        node.trailingComments = trailingComments;\r\n      }\r\n    }\r\n\r\n    stack.push(node);\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport { getLineInfo, type Position } from \"../util/location\";\r\nimport CommentsParser from \"./comments\";\r\n\r\n// This function is used to raise exceptions on parse errors. It\r\n// takes an offset integer (into the current `input`) to indicate\r\n// the location of the error, attaches the position to the end\r\n// of the error message, and then raises a `SyntaxError` with that\r\n// message.\r\n\r\nexport default class LocationParser extends CommentsParser {\r\n  getLocationForPosition(pos: number): Position {\r\n    let loc;\r\n    if (pos === this.state.start) loc = this.state.startLoc;\r\n    else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;\r\n    else if (pos === this.state.end) loc = this.state.endLoc;\r\n    else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;\r\n    else loc = getLineInfo(this.input, pos);\r\n\r\n    return loc;\r\n  }\r\n\r\n  raise(\r\n    pos: number,\r\n    message: string,\r\n    {\r\n      missingPluginNames,\r\n      code,\r\n    }: {\r\n      missingPluginNames?: Array<string>,\r\n      code?: string,\r\n    } = {},\r\n  ): empty {\r\n    const loc = this.getLocationForPosition(pos);\r\n\r\n    message += ` (${loc.line}:${loc.column})`;\r\n    // $FlowIgnore\r\n    const err: SyntaxError & { pos: number, loc: Position } = new SyntaxError(\r\n      message,\r\n    );\r\n    err.pos = pos;\r\n    err.loc = loc;\r\n    if (missingPluginNames) {\r\n      err.missingPlugin = missingPluginNames;\r\n    }\r\n    if (code !== undefined) {\r\n      err.code = code;\r\n    }\r\n    throw err;\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport type { Options } from \"../options\";\r\nimport * as N from \"../types\";\r\nimport { Position } from \"../util/location\";\r\n\r\nimport { types as ct, type TokContext } from \"./context\";\r\nimport type { Token } from \"./index\";\r\nimport { types as tt, type TokenType } from \"./types\";\r\n\r\ntype TopicContextState = {\r\n  // When a topic binding has been currently established,\r\n  // then this is 1. Otherwise, it is 0. This is forwards compatible\r\n  // with a future plugin for multiple lexical topics.\r\n  maxNumOfResolvableTopics: number,\r\n\r\n  // When a topic binding has been currently established, and if that binding\r\n  // has been used as a topic reference `#`, then this is 0. Otherwise, it is\r\n  // `null`. This is forwards compatible with a future plugin for multiple\r\n  // lexical topics.\r\n  maxTopicIndex: null | 0,\r\n};\r\n\r\nexport default class State {\r\n  strict: boolean;\r\n  curLine: number;\r\n\r\n  // And, if locations are used, the {line, column} object\r\n  // corresponding to those offsets\r\n  startLoc: Position;\r\n  endLoc: Position;\r\n\r\n  init(options: Options): void {\r\n    this.strict =\r\n      options.strictMode === false ? false : options.sourceType === \"module\";\r\n\r\n    this.curLine = options.startLine;\r\n    this.startLoc = this.endLoc = this.curPosition();\r\n  }\r\n\r\n  // Used to signify the start of a potential arrow function\r\n  potentialArrowAt: number = -1;\r\n\r\n  // Used to signify the start of an expression which looks like a\r\n  // typed arrow function, but it isn't\r\n  // e.g. a ? (b) : c => d\r\n  //          ^\r\n  noArrowAt: number[] = [];\r\n\r\n  // Used to signify the start of an expression whose params, if it looks like\r\n  // an arrow function, shouldn't be converted to assignable nodes.\r\n  // This is used to defer the validation of typed arrow functions inside\r\n  // conditional expressions.\r\n  // e.g. a ? (b) : c => d\r\n  //          ^\r\n  noArrowParamsConversionAt: number[] = [];\r\n\r\n  // A comma after \"...a\" is only allowed in spread, but not in rest.\r\n  // Since we parse destructuring patterns as array/object literals\r\n  // and then convert them, we need to track it.\r\n  commaAfterSpreadAt: number = -1;\r\n\r\n  // Flags to track\r\n  inParameters: boolean = false;\r\n  maybeInArrowParameters: boolean = false;\r\n  inPipeline: boolean = false;\r\n  inType: boolean = false;\r\n  noAnonFunctionType: boolean = false;\r\n  inPropertyName: boolean = false;\r\n  inClassProperty: boolean = false;\r\n  hasFlowComment: boolean = false;\r\n  isIterator: boolean = false;\r\n\r\n  // For the smartPipelines plugin:\r\n  topicContext: TopicContextState = {\r\n    maxNumOfResolvableTopics: 0,\r\n    maxTopicIndex: null,\r\n  };\r\n\r\n  // Check whether we are in a (nested) class or not.\r\n  classLevel: number = 0;\r\n\r\n  // Labels in scope.\r\n  labels: Array<{\r\n    kind: ?(\"loop\" | \"switch\"),\r\n    name?: ?string,\r\n    statementStart?: number,\r\n  }> = [];\r\n\r\n  // Leading decorators. Last element of the stack represents the decorators in current context.\r\n  // Supports nesting of decorators, e.g. @foo(@bar class inner {}) class outer {}\r\n  // where @foo belongs to the outer class and @bar to the inner\r\n  decoratorStack: Array<Array<N.Decorator>> = [[]];\r\n\r\n  // Positions to delayed-check that yield/await does not exist in default parameters.\r\n  yieldPos: number = 0;\r\n  awaitPos: number = 0;\r\n\r\n  // Token store.\r\n  tokens: Array<Token | N.Comment> = [];\r\n\r\n  // Comment store.\r\n  comments: Array<N.Comment> = [];\r\n\r\n  // Comment attachment store\r\n  trailingComments: Array<N.Comment> = [];\r\n  leadingComments: Array<N.Comment> = [];\r\n  commentStack: Array<{\r\n    start: number,\r\n    leadingComments: ?Array<N.Comment>,\r\n    trailingComments: ?Array<N.Comment>,\r\n    type: string,\r\n  }> = [];\r\n  // $FlowIgnore this is initialized when the parser starts.\r\n  commentPreviousNode: N.Node = null;\r\n\r\n  // The current position of the tokenizer in the input.\r\n  pos: number = 0;\r\n  lineStart: number = 0;\r\n\r\n  // Properties of the current token:\r\n  // Its type\r\n  type: TokenType = tt.eof;\r\n\r\n  // For tokens that include more information than their type, the value\r\n  value: any = null;\r\n\r\n  // Its start and end offset\r\n  start: number = 0;\r\n  end: number = 0;\r\n\r\n  // Position information for the previous token\r\n  // $FlowIgnore this is initialized when generating the second token.\r\n  lastTokEndLoc: Position = null;\r\n  // $FlowIgnore this is initialized when generating the second token.\r\n  lastTokStartLoc: Position = null;\r\n  lastTokStart: number = 0;\r\n  lastTokEnd: number = 0;\r\n\r\n  // The context stack is used to superficially track syntactic\r\n  // context to predict whether a regular expression is allowed in a\r\n  // given position.\r\n  context: Array<TokContext> = [ct.braceStatement];\r\n  exprAllowed: boolean = true;\r\n\r\n  // Used to signal to callers of `readWord1` whether the word\r\n  // contained any escape sequences. This is needed because words with\r\n  // escape sequences must not be interpreted as keywords.\r\n  containsEsc: boolean = false;\r\n\r\n  // TODO\r\n  containsOctal: boolean = false;\r\n  octalPosition: ?number = null;\r\n\r\n  // Names of exports store. `default` is stored as a name for both\r\n  // `export default foo;` and `export { foo as default };`.\r\n  exportedIdentifiers: Array<string> = [];\r\n\r\n  invalidTemplateEscapePosition: ?number = null;\r\n\r\n  curPosition(): Position {\r\n    return new Position(this.curLine, this.pos - this.lineStart);\r\n  }\r\n\r\n  clone(skipArrays?: boolean): State {\r\n    const state = new State();\r\n    const keys = Object.keys(this);\r\n    for (let i = 0, length = keys.length; i < length; i++) {\r\n      const key = keys[i];\r\n      // $FlowIgnore\r\n      let val = this[key];\r\n\r\n      if (!skipArrays && Array.isArray(val)) {\r\n        val = val.slice();\r\n      }\r\n\r\n      // $FlowIgnore\r\n      state[key] = val;\r\n    }\r\n\r\n    return state;\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport type { Options } from \"../options\";\r\nimport type { Position } from \"../util/location\";\r\nimport * as charCodes from \"charcodes\";\r\nimport * as arabic from \"../arabic\";\r\nimport { isIdentifierStart, isIdentifierChar } from \"../util/identifier\";\r\nimport { types as tt, keywords as keywordTypes, type TokenType } from \"./types\";\r\nimport { type TokContext, types as ct } from \"./context\";\r\nimport LocationParser from \"../parser/location\";\r\nimport { SourceLocation } from \"../util/location\";\r\nimport {\r\n  lineBreak,\r\n  lineBreakG,\r\n  isNewLine,\r\n  isWhitespace,\r\n} from \"../util/whitespace\";\r\nimport State from \"./state\";\r\n\r\nconst VALID_REGEX_FLAGS = new Set([\"g\", \"m\", \"s\", \"i\", \"y\", \"u\"]);\r\n\r\n// The following character codes are forbidden from being\r\n// an immediate sibling of NumericLiteralSeparator _\r\n\r\nconst forbiddenNumericSeparatorSiblings = {\r\n  decBinOct: [\r\n    charCodes.dot,\r\n    charCodes.uppercaseB,\r\n    charCodes.uppercaseE,\r\n    charCodes.uppercaseO,\r\n    charCodes.underscore, // multiple separators are not allowed\r\n    charCodes.lowercaseB,\r\n    charCodes.lowercaseE,\r\n    charCodes.lowercaseO,\r\n  ],\r\n  hex: [\r\n    charCodes.dot,\r\n    charCodes.uppercaseX,\r\n    charCodes.underscore, // multiple separators are not allowed\r\n    charCodes.lowercaseX,\r\n  ],\r\n};\r\n\r\nconst allowedNumericSeparatorSiblings = {};\r\nallowedNumericSeparatorSiblings.bin = [\r\n  // 0 - 1\r\n  charCodes.digit0,\r\n  charCodes.digit1,\r\n];\r\nallowedNumericSeparatorSiblings.oct = [\r\n  // 0 - 7\r\n  ...allowedNumericSeparatorSiblings.bin,\r\n\r\n  charCodes.digit2,\r\n  charCodes.digit3,\r\n  charCodes.digit4,\r\n  charCodes.digit5,\r\n  charCodes.digit6,\r\n  charCodes.digit7,\r\n];\r\nallowedNumericSeparatorSiblings.dec = [\r\n  // 0 - 9\r\n  ...allowedNumericSeparatorSiblings.oct,\r\n\r\n  charCodes.digit8,\r\n  charCodes.digit9,\r\n];\r\n\r\nallowedNumericSeparatorSiblings.hex = [\r\n  // 0 - 9, A - F, a - f,\r\n  ...allowedNumericSeparatorSiblings.dec,\r\n\r\n  charCodes.uppercaseA,\r\n  charCodes.uppercaseB,\r\n  charCodes.uppercaseC,\r\n  charCodes.uppercaseD,\r\n  charCodes.uppercaseE,\r\n  charCodes.uppercaseF,\r\n\r\n  charCodes.lowercaseA,\r\n  charCodes.lowercaseB,\r\n  charCodes.lowercaseC,\r\n  charCodes.lowercaseD,\r\n  charCodes.lowercaseE,\r\n  charCodes.lowercaseF,\r\n];\r\n\r\n// Object type used to represent tokens. Note that normally, tokens\r\n// simply exist as properties on the parser object. This is only\r\n// used for the onToken callback and the external tokenizer.\r\n\r\nexport class Token {\r\n  constructor(state: State) {\r\n    this.type = state.type;\r\n    this.value = state.value;\r\n    this.start = state.start;\r\n    this.end = state.end;\r\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\r\n  }\r\n\r\n  type: TokenType;\r\n  value: any;\r\n  start: number;\r\n  end: number;\r\n  loc: SourceLocation;\r\n}\r\n\r\n// ## Tokenizer\r\n\r\nexport default class Tokenizer extends LocationParser {\r\n  // Forward-declarations\r\n  // parser/util.js\r\n  +unexpected: (pos?: ?number, messageOrType?: string | TokenType) => empty;\r\n\r\n  isLookahead: boolean;\r\n\r\n  constructor(options: Options, input: string) {\r\n    super();\r\n    this.state = new State();\r\n    this.state.init(options);\r\n    this.input = input;\r\n    this.length = input.length;\r\n    this.isLookahead = false;\r\n  }\r\n\r\n  // Move to the next token\r\n\r\n  next(): void {\r\n    if (this.options.tokens && !this.isLookahead) {\r\n      this.state.tokens.push(new Token(this.state));\r\n    }\r\n\r\n    this.state.lastTokEnd = this.state.end;\r\n    this.state.lastTokStart = this.state.start;\r\n    this.state.lastTokEndLoc = this.state.endLoc;\r\n    this.state.lastTokStartLoc = this.state.startLoc;\r\n    this.nextToken();\r\n  }\r\n\r\n  // TODO\r\n\r\n  eat(type: TokenType): boolean {\r\n    if (this.match(type)) {\r\n      this.next();\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // TODO\r\n\r\n  match(type: TokenType): boolean {\r\n    return this.state.type === type;\r\n  }\r\n\r\n  // TODO\r\n\r\n  lookahead(): State {\r\n    const old = this.state;\r\n    this.state = old.clone(true);\r\n\r\n    this.isLookahead = true;\r\n    this.next();\r\n    this.isLookahead = false;\r\n\r\n    const curr = this.state;\r\n    this.state = old;\r\n    return curr;\r\n  }\r\n\r\n  // Toggle strict mode. Re-reads the next number or string to please\r\n  // pedantic tests (`\"use strict\"; 010;` should fail).\r\n\r\n  setStrict(strict: boolean): void {\r\n    this.state.strict = strict;\r\n    if (!this.match(tt.num) && !this.match(tt.string)) return;\r\n    this.state.pos = this.state.start;\r\n    while (this.state.pos < this.state.lineStart) {\r\n      this.state.lineStart =\r\n        this.input.lastIndexOf(\"\\n\", this.state.lineStart - 2) + 1;\r\n      --this.state.curLine;\r\n    }\r\n    this.nextToken();\r\n  }\r\n\r\n  curContext(): TokContext {\r\n    return this.state.context[this.state.context.length - 1];\r\n  }\r\n\r\n  // Read a single token, updating the parser object's token-related\r\n  // properties.\r\n\r\n  nextToken(): void {\r\n    const curContext = this.curContext();\r\n    if (!curContext || !curContext.preserveSpace) this.skipSpace();\r\n\r\n    this.state.containsOctal = false;\r\n    this.state.octalPosition = null;\r\n    this.state.start = this.state.pos;\r\n    this.state.startLoc = this.state.curPosition();\r\n    if (this.state.pos >= this.length) {\r\n      this.finishToken(tt.eof);\r\n      return;\r\n    }\r\n\r\n    if (curContext.override) {\r\n      curContext.override(this);\r\n    } else {\r\n      this.getTokenFromCode(this.input.codePointAt(this.state.pos));\r\n    }\r\n  }\r\n\r\n  pushComment(\r\n    block: boolean,\r\n    text: string,\r\n    start: number,\r\n    end: number,\r\n    startLoc: Position,\r\n    endLoc: Position,\r\n  ): void {\r\n    const comment = {\r\n      type: block ? \"CommentBlock\" : \"CommentLine\",\r\n      value: text,\r\n      start: start,\r\n      end: end,\r\n      loc: new SourceLocation(startLoc, endLoc),\r\n    };\r\n\r\n    if (this.options.tokens) this.state.tokens.push(comment);\r\n    this.state.comments.push(comment);\r\n    this.addComment(comment);\r\n  }\r\n\r\n  skipBlockComment(): void {\r\n    const startLoc = this.state.curPosition();\r\n    const start = this.state.pos;\r\n    const end = this.input.indexOf(\"*/\", (this.state.pos += 2));\r\n    if (end === -1) this.raise(this.state.pos - 2, \"Unterminated comment\");\r\n\r\n    this.state.pos = end + 2;\r\n    lineBreakG.lastIndex = start;\r\n    let match;\r\n    while (\r\n      (match = lineBreakG.exec(this.input)) &&\r\n      match.index < this.state.pos\r\n    ) {\r\n      ++this.state.curLine;\r\n      this.state.lineStart = match.index + match[0].length;\r\n    }\r\n\r\n    // If we are doing a lookahead right now we need to advance the position (above code)\r\n    // but we do not want to push the comment to the state.\r\n    if (this.isLookahead) return;\r\n\r\n    this.pushComment(\r\n      true,\r\n      this.input.slice(start + 2, end),\r\n      start,\r\n      this.state.pos,\r\n      startLoc,\r\n      this.state.curPosition(),\r\n    );\r\n  }\r\n\r\n  skipLineComment(startSkip: number): void {\r\n    const start = this.state.pos;\r\n    const startLoc = this.state.curPosition();\r\n    let ch = this.input.charCodeAt((this.state.pos += startSkip));\r\n    if (this.state.pos < this.length) {\r\n      while (\r\n        ch !== charCodes.lineFeed &&\r\n        ch !== charCodes.carriageReturn &&\r\n        ch !== charCodes.lineSeparator &&\r\n        ch !== charCodes.paragraphSeparator &&\r\n        ++this.state.pos < this.length\r\n      ) {\r\n        ch = this.input.charCodeAt(this.state.pos);\r\n      }\r\n    }\r\n\r\n    // If we are doing a lookahead right now we need to advance the position (above code)\r\n    // but we do not want to push the comment to the state.\r\n    if (this.isLookahead) return;\r\n\r\n    this.pushComment(\r\n      false,\r\n      this.input.slice(start + startSkip, this.state.pos),\r\n      start,\r\n      this.state.pos,\r\n      startLoc,\r\n      this.state.curPosition(),\r\n    );\r\n  }\r\n\r\n  // Called at the start of the parse and after every token. Skips\r\n  // whitespace and comments, and.\r\n\r\n  skipSpace(): void {\r\n    loop: while (this.state.pos < this.length) {\r\n      const ch = this.input.charCodeAt(this.state.pos);\r\n      switch (ch) {\r\n        case charCodes.space:\r\n        case charCodes.nonBreakingSpace:\r\n        case charCodes.tab:\r\n          ++this.state.pos;\r\n          break;\r\n        case charCodes.carriageReturn:\r\n          if (\r\n            this.input.charCodeAt(this.state.pos + 1) === charCodes.lineFeed\r\n          ) {\r\n            ++this.state.pos;\r\n          }\r\n\r\n        case charCodes.lineFeed:\r\n        case charCodes.lineSeparator:\r\n        case charCodes.paragraphSeparator:\r\n          ++this.state.pos;\r\n          ++this.state.curLine;\r\n          this.state.lineStart = this.state.pos;\r\n          break;\r\n\r\n        case charCodes.slash:\r\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\r\n            case charCodes.asterisk:\r\n              this.skipBlockComment();\r\n              break;\r\n\r\n            case charCodes.slash:\r\n              this.skipLineComment(2);\r\n              break;\r\n\r\n            default:\r\n              break loop;\r\n          }\r\n          break;\r\n\r\n        default:\r\n          if (isWhitespace(ch)) {\r\n            ++this.state.pos;\r\n          } else {\r\n            break loop;\r\n          }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Called at the end of every token. Sets `end`, `val`, and\r\n  // maintains `context` and `exprAllowed`, and skips the space after\r\n  // the token, so that the next one's `start` will point at the\r\n  // right position.\r\n\r\n  finishToken(type: TokenType, val: any): void {\r\n    this.state.end = this.state.pos;\r\n    this.state.endLoc = this.state.curPosition();\r\n    const prevType = this.state.type;\r\n    this.state.type = type;\r\n    this.state.value = val;\r\n\r\n    if (!this.isLookahead) this.updateContext(prevType);\r\n  }\r\n\r\n  // ### Token reading\r\n\r\n  // This is the function that is called to fetch the next token. It\r\n  // is somewhat obscure, because it works in character codes rather\r\n  // than characters, and because operator parsing has been inlined\r\n  // into it.\r\n  //\r\n  // All in the name of speed.\r\n\r\n  // number sign is \"#\"\r\n  readToken_numberSign(): void {\r\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\r\n      return;\r\n    }\r\n\r\n    const nextPos = this.state.pos + 1;\r\n    const next = this.input.charCodeAt(nextPos);\r\n    if (next >= charCodes.digit0 && next <= charCodes.digit9) {\r\n      this.raise(this.state.pos, \"Unexpected digit after hash token\");\r\n    }\r\n\r\n    if (\r\n      (this.hasPlugin(\"classPrivateProperties\") ||\r\n        this.hasPlugin(\"classPrivateMethods\")) &&\r\n      this.state.classLevel > 0\r\n    ) {\r\n      ++this.state.pos;\r\n      this.finishToken(tt.hash);\r\n      return;\r\n    } else if (\r\n      this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\"\r\n    ) {\r\n      this.finishOp(tt.hash, 1);\r\n    } else {\r\n      this.raise(this.state.pos, \"Unexpected character '#'\");\r\n    }\r\n  }\r\n\r\n  readToken_dot(): void {\r\n    const next = this.input.charCodeAt(this.state.pos + 1);\r\n    if (next >= charCodes.digit0 && next <= charCodes.digit9) {\r\n      this.readNumber(true);\r\n      return;\r\n    }\r\n\r\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\r\n    if (next === charCodes.dot && next2 === charCodes.dot) {\r\n      this.state.pos += 3;\r\n      this.finishToken(tt.ellipsis);\r\n    } else {\r\n      ++this.state.pos;\r\n      this.finishToken(tt.dot);\r\n    }\r\n  }\r\n\r\n  readToken_slash(): void {\r\n    // '/'\r\n    if (this.state.exprAllowed && !this.state.inType) {\r\n      ++this.state.pos;\r\n      this.readRegexp();\r\n      return;\r\n    }\r\n\r\n    const next = this.input.charCodeAt(this.state.pos + 1);\r\n    if (next === charCodes.equalsTo) {\r\n      this.finishOp(tt.assign, 2);\r\n    } else {\r\n      this.finishOp(tt.slash, 1);\r\n    }\r\n  }\r\n\r\n  readToken_interpreter(): boolean {\r\n    if (this.state.pos !== 0 || this.length < 2) return false;\r\n\r\n    const start = this.state.pos;\r\n    this.state.pos += 1;\r\n\r\n    let ch = this.input.charCodeAt(this.state.pos);\r\n    if (ch !== charCodes.exclamationMark) return false;\r\n\r\n    while (\r\n      ch !== charCodes.lineFeed &&\r\n      ch !== charCodes.carriageReturn &&\r\n      ch !== charCodes.lineSeparator &&\r\n      ch !== charCodes.paragraphSeparator &&\r\n      ++this.state.pos < this.length\r\n    ) {\r\n      ch = this.input.charCodeAt(this.state.pos);\r\n    }\r\n\r\n    const value = this.input.slice(start + 2, this.state.pos);\r\n\r\n    this.finishToken(tt.interpreterDirective, value);\r\n\r\n    return true;\r\n  }\r\n\r\n  readToken_mult_modulo(code: number): void {\r\n    // '%*'\r\n    let type = code === charCodes.asterisk ? tt.star : tt.modulo;\r\n    let width = 1;\r\n    let next = this.input.charCodeAt(this.state.pos + 1);\r\n    const exprAllowed = this.state.exprAllowed;\r\n\r\n    // Exponentiation operator **\r\n    if (code === charCodes.asterisk && next === charCodes.asterisk) {\r\n      width++;\r\n      next = this.input.charCodeAt(this.state.pos + 2);\r\n      type = tt.exponent;\r\n    }\r\n\r\n    if (next === charCodes.equalsTo && !exprAllowed) {\r\n      width++;\r\n      type = tt.assign;\r\n    }\r\n\r\n    this.finishOp(type, width);\r\n  }\r\n\r\n  readToken_pipe_amp(code: number): void {\r\n    // '||' '&&' '||=' '&&='\r\n    const next = this.input.charCodeAt(this.state.pos + 1);\r\n\r\n    if (next === code) {\r\n      if (this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo) {\r\n        this.finishOp(tt.assign, 3);\r\n      } else {\r\n        this.finishOp(\r\n          code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND,\r\n          2,\r\n        );\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (code === charCodes.verticalBar) {\r\n      // '|>'\r\n      if (next === charCodes.greaterThan) {\r\n        this.finishOp(tt.pipeline, 2);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (next === charCodes.equalsTo) {\r\n      this.finishOp(tt.assign, 2);\r\n      return;\r\n    }\r\n\r\n    this.finishOp(\r\n      code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND,\r\n      1,\r\n    );\r\n  }\r\n\r\n  readToken_caret(): void {\r\n    // '^'\r\n    const next = this.input.charCodeAt(this.state.pos + 1);\r\n    if (next === charCodes.equalsTo) {\r\n      this.finishOp(tt.assign, 2);\r\n    } else {\r\n      this.finishOp(tt.bitwiseXOR, 1);\r\n    }\r\n  }\r\n\r\n  readToken_plus_min(code: number): void {\r\n    // '+-'\r\n    const next = this.input.charCodeAt(this.state.pos + 1);\r\n\r\n    if (next === code) {\r\n      if (\r\n        next === charCodes.dash &&\r\n        !this.inModule &&\r\n        this.input.charCodeAt(this.state.pos + 2) === charCodes.greaterThan &&\r\n        (this.state.lastTokEnd === 0 ||\r\n          lineBreak.test(\r\n            this.input.slice(this.state.lastTokEnd, this.state.pos),\r\n          ))\r\n      ) {\r\n        // A `-->` line comment\r\n        this.skipLineComment(3);\r\n        this.skipSpace();\r\n        this.nextToken();\r\n        return;\r\n      }\r\n      this.finishOp(tt.incDec, 2);\r\n      return;\r\n    }\r\n\r\n    if (next === charCodes.equalsTo) {\r\n      this.finishOp(tt.assign, 2);\r\n    } else {\r\n      this.finishOp(tt.plusMin, 1);\r\n    }\r\n  }\r\n\r\n  readToken_lt_gt(code: number): void {\r\n    // '<>'\r\n    const next = this.input.charCodeAt(this.state.pos + 1);\r\n    let size = 1;\r\n\r\n    if (next === code) {\r\n      size =\r\n        code === charCodes.greaterThan &&\r\n        this.input.charCodeAt(this.state.pos + 2) === charCodes.greaterThan\r\n          ? 3\r\n          : 2;\r\n      if (this.input.charCodeAt(this.state.pos + size) === charCodes.equalsTo) {\r\n        this.finishOp(tt.assign, size + 1);\r\n        return;\r\n      }\r\n      this.finishOp(tt.bitShift, size);\r\n      return;\r\n    }\r\n\r\n    if (\r\n      next === charCodes.exclamationMark &&\r\n      code === charCodes.lessThan &&\r\n      !this.inModule &&\r\n      this.input.charCodeAt(this.state.pos + 2) === charCodes.dash &&\r\n      this.input.charCodeAt(this.state.pos + 3) === charCodes.dash\r\n    ) {\r\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\r\n      this.skipLineComment(4);\r\n      this.skipSpace();\r\n      this.nextToken();\r\n      return;\r\n    }\r\n\r\n    if (next === charCodes.equalsTo) {\r\n      // <= | >=\r\n      size = 2;\r\n    }\r\n\r\n    this.finishOp(tt.relational, size);\r\n  }\r\n\r\n  readToken_eq_excl(code: number): void {\r\n    // '=!'\r\n    const next = this.input.charCodeAt(this.state.pos + 1);\r\n    if (next === charCodes.equalsTo) {\r\n      this.finishOp(\r\n        tt.equality,\r\n        this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo\r\n          ? 3\r\n          : 2,\r\n      );\r\n      return;\r\n    }\r\n    if (code === charCodes.equalsTo && next === charCodes.greaterThan) {\r\n      // '=>'\r\n      this.state.pos += 2;\r\n      this.finishToken(tt.arrow);\r\n      return;\r\n    }\r\n    this.finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);\r\n  }\r\n\r\n  readToken_question(): void {\r\n    // '?'\r\n    const next = this.input.charCodeAt(this.state.pos + 1);\r\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\r\n    if (next === arabic.questionMark && !this.state.inType) {\r\n      if (next2 === charCodes.equalsTo) {\r\n        // '??='\r\n        this.finishOp(tt.assign, 3);\r\n      } else {\r\n        // '??'\r\n        this.finishOp(tt.nullishCoalescing, 2);\r\n      }\r\n    } else if (\r\n      next === charCodes.dot &&\r\n      !(next2 >= charCodes.digit0 && next2 <= charCodes.digit9)\r\n    ) {\r\n      // '.' not followed by a number\r\n      this.state.pos += 2;\r\n      this.finishToken(tt.questionDot);\r\n    } else {\r\n      ++this.state.pos;\r\n      this.finishToken(tt.question);\r\n    }\r\n  }\r\n\r\n  getTokenFromCode(code: number): void {\r\n    switch (code) {\r\n      // The interpretation of a dot depends on whether it is followed\r\n      // by a digit or another two dots.\r\n\r\n      case charCodes.dot:\r\n        this.readToken_dot();\r\n        return;\r\n\r\n      // Punctuation tokens.\r\n      case charCodes.leftParenthesis:\r\n        ++this.state.pos;\r\n        this.finishToken(tt.parenL);\r\n        return;\r\n      case charCodes.rightParenthesis:\r\n        ++this.state.pos;\r\n        this.finishToken(tt.parenR);\r\n        return;\r\n      case charCodes.semicolon:\r\n        ++this.state.pos;\r\n        this.finishToken(tt.semi);\r\n        return;\r\n      case charCodes.comma:\r\n        ++this.state.pos;\r\n        this.finishToken(tt.comma);\r\n        return;\r\n      case charCodes.leftSquareBracket:\r\n        ++this.state.pos;\r\n        this.finishToken(tt.bracketL);\r\n        return;\r\n      case charCodes.rightSquareBracket:\r\n        ++this.state.pos;\r\n        this.finishToken(tt.bracketR);\r\n        return;\r\n      case charCodes.leftCurlyBrace:\r\n        ++this.state.pos;\r\n        this.finishToken(tt.braceL);\r\n        return;\r\n      case charCodes.rightCurlyBrace:\r\n        ++this.state.pos;\r\n        this.finishToken(tt.braceR);\r\n        return;\r\n\r\n      case charCodes.colon:\r\n        if (\r\n          this.hasPlugin(\"functionBind\") &&\r\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.colon\r\n        ) {\r\n          this.finishOp(tt.doubleColon, 2);\r\n        } else {\r\n          ++this.state.pos;\r\n          this.finishToken(tt.colon);\r\n        }\r\n        return;\r\n\r\n      case arabic.questionMark:\r\n        this.readToken_question();\r\n        return;\r\n\r\n      case charCodes.graveAccent:\r\n        ++this.state.pos;\r\n        this.finishToken(tt.backQuote);\r\n        return;\r\n\r\n      case charCodes.digit0: {\r\n        const next = this.input.charCodeAt(this.state.pos + 1);\r\n        // '0x', '0X' - hex number\r\n        if (next === charCodes.lowercaseX || next === charCodes.uppercaseX) {\r\n          this.readRadixNumber(16);\r\n          return;\r\n        }\r\n        // '0o', '0O' - octal number\r\n        if (next === charCodes.lowercaseO || next === charCodes.uppercaseO) {\r\n          this.readRadixNumber(8);\r\n          return;\r\n        }\r\n        // '0b', '0B' - binary number\r\n        if (next === charCodes.lowercaseB || next === charCodes.uppercaseB) {\r\n          this.readRadixNumber(2);\r\n          return;\r\n        }\r\n      }\r\n      // Anything else beginning with a digit is an integer, octal\r\n      // number, or float.\r\n      case charCodes.digit1:\r\n      case charCodes.digit2:\r\n      case charCodes.digit3:\r\n      case charCodes.digit4:\r\n      case charCodes.digit5:\r\n      case charCodes.digit6:\r\n      case charCodes.digit7:\r\n      case charCodes.digit8:\r\n      case charCodes.digit9:\r\n        this.readNumber(false);\r\n        return;\r\n\r\n      // Quotes produce strings.\r\n      case charCodes.quotationMark:\r\n      case charCodes.apostrophe:\r\n        this.readString(code);\r\n        return;\r\n\r\n      // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is\r\n      // often referred to. `finishOp` simply skips the amount of\r\n      // characters it is given as second argument, and returns a token\r\n      // of the type given by its first argument.\r\n\r\n      case charCodes.slash:\r\n        this.readToken_slash();\r\n        return;\r\n\r\n      case charCodes.percentSign:\r\n      case charCodes.asterisk:\r\n        this.readToken_mult_modulo(code);\r\n        return;\r\n\r\n      case charCodes.verticalBar:\r\n      case charCodes.ampersand:\r\n        this.readToken_pipe_amp(code);\r\n        return;\r\n\r\n      case charCodes.caret:\r\n        this.readToken_caret();\r\n        return;\r\n\r\n      case charCodes.plusSign:\r\n      case charCodes.dash:\r\n        this.readToken_plus_min(code);\r\n        return;\r\n\r\n      case charCodes.lessThan:\r\n      case charCodes.greaterThan:\r\n        this.readToken_lt_gt(code);\r\n        return;\r\n\r\n      case charCodes.equalsTo:\r\n      case charCodes.exclamationMark:\r\n        this.readToken_eq_excl(code);\r\n        return;\r\n\r\n      case charCodes.tilde:\r\n        this.finishOp(tt.tilde, 1);\r\n        return;\r\n\r\n      case charCodes.atSign:\r\n        ++this.state.pos;\r\n        this.finishToken(tt.at);\r\n        return;\r\n\r\n      case charCodes.numberSign:\r\n        this.readToken_numberSign();\r\n        return;\r\n\r\n      case charCodes.backslash:\r\n        this.readWord();\r\n        return;\r\n\r\n      default:\r\n        if (isIdentifierStart(code)) {\r\n          this.readWord();\r\n          return;\r\n        }\r\n    }\r\n\r\n    this.raise(\r\n      this.state.pos,\r\n      `Unexpected character '${String.fromCodePoint(code)}' : Code: ${code}`,\r\n    );\r\n  }\r\n\r\n  finishOp(type: TokenType, size: number): void {\r\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\r\n    this.state.pos += size;\r\n    this.finishToken(type, str);\r\n  }\r\n\r\n  readRegexp(): void {\r\n    const start = this.state.pos;\r\n    let escaped, inClass;\r\n    for (;;) {\r\n      if (this.state.pos >= this.length) {\r\n        this.raise(start, \"Unterminated regular expression\");\r\n      }\r\n      const ch = this.input.charAt(this.state.pos);\r\n      if (lineBreak.test(ch)) {\r\n        this.raise(start, \"Unterminated regular expression\");\r\n      }\r\n      if (escaped) {\r\n        escaped = false;\r\n      } else {\r\n        if (ch === \"[\") {\r\n          inClass = true;\r\n        } else if (ch === \"]\" && inClass) {\r\n          inClass = false;\r\n        } else if (ch === \"/\" && !inClass) {\r\n          break;\r\n        }\r\n        escaped = ch === \"\\\\\";\r\n      }\r\n      ++this.state.pos;\r\n    }\r\n    const content = this.input.slice(start, this.state.pos);\r\n    ++this.state.pos;\r\n\r\n    let mods = \"\";\r\n\r\n    while (this.state.pos < this.length) {\r\n      const char = this.input[this.state.pos];\r\n      const charCode = this.input.codePointAt(this.state.pos);\r\n\r\n      if (VALID_REGEX_FLAGS.has(char)) {\r\n        if (mods.indexOf(char) > -1) {\r\n          this.raise(this.state.pos + 1, \"Duplicate regular expression flag\");\r\n        }\r\n\r\n        ++this.state.pos;\r\n        mods += char;\r\n      } else if (\r\n        isIdentifierChar(charCode) ||\r\n        charCode === charCodes.backslash\r\n      ) {\r\n        this.raise(this.state.pos + 1, \"Invalid regular expression flag\");\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.finishToken(tt.regexp, {\r\n      pattern: content,\r\n      flags: mods,\r\n    });\r\n  }\r\n\r\n  // Read an integer in the given radix. Return null if zero digits\r\n  // were read, the integer value otherwise. When `len` is given, this\r\n  // will return `null` unless the integer has exactly `len` digits.\r\n\r\n  readInt(radix: number, len?: number): number | null {\r\n    const start = this.state.pos;\r\n    const forbiddenSiblings =\r\n      radix === 16\r\n        ? forbiddenNumericSeparatorSiblings.hex\r\n        : forbiddenNumericSeparatorSiblings.decBinOct;\r\n    const allowedSiblings =\r\n      radix === 16\r\n        ? allowedNumericSeparatorSiblings.hex\r\n        : radix === 10\r\n        ? allowedNumericSeparatorSiblings.dec\r\n        : radix === 8\r\n        ? allowedNumericSeparatorSiblings.oct\r\n        : allowedNumericSeparatorSiblings.bin;\r\n\r\n    let total = 0;\r\n\r\n    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\r\n      const code = this.input.charCodeAt(this.state.pos);\r\n      let val;\r\n\r\n      if (this.hasPlugin(\"numericSeparator\")) {\r\n        const prev = this.input.charCodeAt(this.state.pos - 1);\r\n        const next = this.input.charCodeAt(this.state.pos + 1);\r\n        if (code === charCodes.underscore) {\r\n          if (allowedSiblings.indexOf(next) === -1) {\r\n            this.raise(this.state.pos, \"Invalid or unexpected token\");\r\n          }\r\n\r\n          if (\r\n            forbiddenSiblings.indexOf(prev) > -1 ||\r\n            forbiddenSiblings.indexOf(next) > -1 ||\r\n            Number.isNaN(next)\r\n          ) {\r\n            this.raise(this.state.pos, \"Invalid or unexpected token\");\r\n          }\r\n\r\n          // Ignore this _ character\r\n          ++this.state.pos;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      if (code >= charCodes.lowercaseA) {\r\n        val = code - charCodes.lowercaseA + charCodes.lineFeed;\r\n      } else if (code >= charCodes.uppercaseA) {\r\n        val = code - charCodes.uppercaseA + charCodes.lineFeed;\r\n      } else if (charCodes.isDigit(code)) {\r\n        val = code - charCodes.digit0; // 0-9\r\n      } else {\r\n        val = Infinity;\r\n      }\r\n      if (val >= radix) break;\r\n      ++this.state.pos;\r\n      total = total * radix + val;\r\n    }\r\n    if (\r\n      this.state.pos === start ||\r\n      (len != null && this.state.pos - start !== len)\r\n    ) {\r\n      return null;\r\n    }\r\n\r\n    return total;\r\n  }\r\n\r\n  readRadixNumber(radix: number): void {\r\n    const start = this.state.pos;\r\n    let isBigInt = false;\r\n\r\n    this.state.pos += 2; // 0x\r\n    const val = this.readInt(radix);\r\n    if (val == null) {\r\n      this.raise(this.state.start + 2, \"Expected number in radix \" + radix);\r\n    }\r\n\r\n    if (this.hasPlugin(\"bigInt\")) {\r\n      if (this.input.charCodeAt(this.state.pos) === charCodes.lowercaseN) {\r\n        ++this.state.pos;\r\n        isBigInt = true;\r\n      }\r\n    }\r\n\r\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\r\n      this.raise(this.state.pos, \"Identifier directly after number\");\r\n    }\r\n\r\n    if (isBigInt) {\r\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\r\n      this.finishToken(tt.bigint, str);\r\n      return;\r\n    }\r\n\r\n    this.finishToken(tt.num, val);\r\n  }\r\n\r\n  // Read an integer, octal integer, or floating-point number.\r\n\r\n  readNumber(startsWithDot: boolean): void {\r\n    const start = this.state.pos;\r\n    let isFloat = false;\r\n    let isBigInt = false;\r\n\r\n    if (!startsWithDot && this.readInt(10) === null) {\r\n      this.raise(start, \"Invalid number\");\r\n    }\r\n    let octal =\r\n      this.state.pos - start >= 2 &&\r\n      this.input.charCodeAt(start) === charCodes.digit0;\r\n    if (octal) {\r\n      if (this.state.strict) {\r\n        this.raise(\r\n          start,\r\n          \"Legacy octal literals are not allowed in strict mode\",\r\n        );\r\n      }\r\n      if (/[89]/.test(this.input.slice(start, this.state.pos))) {\r\n        octal = false;\r\n      }\r\n    }\r\n\r\n    let next = this.input.charCodeAt(this.state.pos);\r\n    if (next === charCodes.dot && !octal) {\r\n      ++this.state.pos;\r\n      this.readInt(10);\r\n      isFloat = true;\r\n      next = this.input.charCodeAt(this.state.pos);\r\n    }\r\n\r\n    if (\r\n      (next === charCodes.uppercaseE || next === charCodes.lowercaseE) &&\r\n      !octal\r\n    ) {\r\n      next = this.input.charCodeAt(++this.state.pos);\r\n      if (next === charCodes.plusSign || next === charCodes.dash) {\r\n        ++this.state.pos;\r\n      }\r\n      if (this.readInt(10) === null) this.raise(start, \"Invalid number\");\r\n      isFloat = true;\r\n      next = this.input.charCodeAt(this.state.pos);\r\n    }\r\n\r\n    if (this.hasPlugin(\"bigInt\")) {\r\n      if (next === charCodes.lowercaseN) {\r\n        // disallow floats and legacy octal syntax, new style octal (\"0o\") is handled in this.readRadixNumber\r\n        if (isFloat || octal) this.raise(start, \"Invalid BigIntLiteral\");\r\n        ++this.state.pos;\r\n        isBigInt = true;\r\n      }\r\n    }\r\n\r\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\r\n      this.raise(this.state.pos, \"Identifier directly after number\");\r\n    }\r\n\r\n    // remove \"_\" for numeric literal separator, and \"n\" for BigInts\r\n    const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\r\n\r\n    if (isBigInt) {\r\n      this.finishToken(tt.bigint, str);\r\n      return;\r\n    }\r\n\r\n    const val = octal ? parseInt(str, 8) : parseFloat(str);\r\n    this.finishToken(tt.num, val);\r\n  }\r\n\r\n  // Read a string value, interpreting backslash-escapes.\r\n\r\n  readCodePoint(throwOnInvalid: boolean): number | null {\r\n    const ch = this.input.charCodeAt(this.state.pos);\r\n    let code;\r\n\r\n    if (ch === charCodes.leftCurlyBrace) {\r\n      const codePos = ++this.state.pos;\r\n      code = this.readHexChar(\r\n        this.input.indexOf(\"}\", this.state.pos) - this.state.pos,\r\n        throwOnInvalid,\r\n      );\r\n      ++this.state.pos;\r\n      if (code === null) {\r\n        // $FlowFixMe (is this always non-null?)\r\n        --this.state.invalidTemplateEscapePosition; // to point to the '\\'' instead of the 'u'\r\n      } else if (code > 0x10ffff) {\r\n        if (throwOnInvalid) {\r\n          this.raise(codePos, \"Code point out of bounds\");\r\n        } else {\r\n          this.state.invalidTemplateEscapePosition = codePos - 2;\r\n          return null;\r\n        }\r\n      }\r\n    } else {\r\n      code = this.readHexChar(4, throwOnInvalid);\r\n    }\r\n    return code;\r\n  }\r\n\r\n  readString(quote: number): void {\r\n    let out = \"\",\r\n      chunkStart = ++this.state.pos;\r\n    for (;;) {\r\n      if (this.state.pos >= this.length) {\r\n        this.raise(this.state.start, \"Unterminated string constant\");\r\n      }\r\n      const ch = this.input.charCodeAt(this.state.pos);\r\n      if (ch === quote) break;\r\n      if (ch === charCodes.backslash) {\r\n        out += this.input.slice(chunkStart, this.state.pos);\r\n        // $FlowFixMe\r\n        out += this.readEscapedChar(false);\r\n        chunkStart = this.state.pos;\r\n      } else if (\r\n        ch === charCodes.lineSeparator ||\r\n        ch === charCodes.paragraphSeparator\r\n      ) {\r\n        ++this.state.pos;\r\n        ++this.state.curLine;\r\n      } else if (isNewLine(ch)) {\r\n        this.raise(this.state.start, \"Unterminated string constant\");\r\n      } else {\r\n        ++this.state.pos;\r\n      }\r\n    }\r\n    out += this.input.slice(chunkStart, this.state.pos++);\r\n    this.finishToken(tt.string, out);\r\n  }\r\n\r\n  // Reads template string tokens.\r\n\r\n  readTmplToken(): void {\r\n    let out = \"\",\r\n      chunkStart = this.state.pos,\r\n      containsInvalid = false;\r\n    for (;;) {\r\n      if (this.state.pos >= this.length) {\r\n        this.raise(this.state.start, \"Unterminated template\");\r\n      }\r\n      const ch = this.input.charCodeAt(this.state.pos);\r\n      if (\r\n        ch === charCodes.graveAccent ||\r\n        (ch === charCodes.dollarSign &&\r\n          this.input.charCodeAt(this.state.pos + 1) ===\r\n            charCodes.leftCurlyBrace)\r\n      ) {\r\n        if (this.state.pos === this.state.start && this.match(tt.template)) {\r\n          if (ch === charCodes.dollarSign) {\r\n            this.state.pos += 2;\r\n            this.finishToken(tt.dollarBraceL);\r\n            return;\r\n          } else {\r\n            ++this.state.pos;\r\n            this.finishToken(tt.backQuote);\r\n            return;\r\n          }\r\n        }\r\n        out += this.input.slice(chunkStart, this.state.pos);\r\n        this.finishToken(tt.template, containsInvalid ? null : out);\r\n        return;\r\n      }\r\n      if (ch === charCodes.backslash) {\r\n        out += this.input.slice(chunkStart, this.state.pos);\r\n        const escaped = this.readEscapedChar(true);\r\n        if (escaped === null) {\r\n          containsInvalid = true;\r\n        } else {\r\n          out += escaped;\r\n        }\r\n        chunkStart = this.state.pos;\r\n      } else if (isNewLine(ch)) {\r\n        out += this.input.slice(chunkStart, this.state.pos);\r\n        ++this.state.pos;\r\n        switch (ch) {\r\n          case charCodes.carriageReturn:\r\n            if (this.input.charCodeAt(this.state.pos) === charCodes.lineFeed) {\r\n              ++this.state.pos;\r\n            }\r\n          case charCodes.lineFeed:\r\n            out += \"\\n\";\r\n            break;\r\n          default:\r\n            out += String.fromCharCode(ch);\r\n            break;\r\n        }\r\n        ++this.state.curLine;\r\n        this.state.lineStart = this.state.pos;\r\n        chunkStart = this.state.pos;\r\n      } else {\r\n        ++this.state.pos;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Used to read escaped characters\r\n\r\n  readEscapedChar(inTemplate: boolean): string | null {\r\n    const throwOnInvalid = !inTemplate;\r\n    const ch = this.input.charCodeAt(++this.state.pos);\r\n    ++this.state.pos;\r\n    switch (ch) {\r\n      case charCodes.lowercaseN:\r\n        return \"\\n\";\r\n      case charCodes.lowercaseR:\r\n        return \"\\r\";\r\n      case charCodes.lowercaseX: {\r\n        const code = this.readHexChar(2, throwOnInvalid);\r\n        return code === null ? null : String.fromCharCode(code);\r\n      }\r\n      case charCodes.lowercaseU: {\r\n        const code = this.readCodePoint(throwOnInvalid);\r\n        return code === null ? null : String.fromCodePoint(code);\r\n      }\r\n      case charCodes.lowercaseT:\r\n        return \"\\t\";\r\n      case charCodes.lowercaseB:\r\n        return \"\\b\";\r\n      case charCodes.lowercaseV:\r\n        return \"\\u000b\";\r\n      case charCodes.lowercaseF:\r\n        return \"\\f\";\r\n      case charCodes.carriageReturn:\r\n        if (this.input.charCodeAt(this.state.pos) === charCodes.lineFeed) {\r\n          ++this.state.pos;\r\n        }\r\n      case charCodes.lineFeed:\r\n        this.state.lineStart = this.state.pos;\r\n        ++this.state.curLine;\r\n      case charCodes.lineSeparator:\r\n      case charCodes.paragraphSeparator:\r\n        return \"\";\r\n      default:\r\n        if (ch >= charCodes.digit0 && ch <= charCodes.digit7) {\r\n          const codePos = this.state.pos - 1;\r\n          // $FlowFixMe\r\n          let octalStr = this.input\r\n            .substr(this.state.pos - 1, 3)\r\n            .match(/^[0-7]+/)[0];\r\n          let octal = parseInt(octalStr, 8);\r\n          if (octal > 255) {\r\n            octalStr = octalStr.slice(0, -1);\r\n            octal = parseInt(octalStr, 8);\r\n          }\r\n          this.state.pos += octalStr.length - 1;\r\n          const next = this.input.charCodeAt(this.state.pos);\r\n          if (\r\n            octalStr !== \"0\" ||\r\n            next === charCodes.digit8 ||\r\n            next === charCodes.digit9\r\n          ) {\r\n            if (inTemplate) {\r\n              this.state.invalidTemplateEscapePosition = codePos;\r\n              return null;\r\n            } else if (this.state.strict) {\r\n              this.raise(codePos, \"Octal literal in strict mode\");\r\n            } else if (!this.state.containsOctal) {\r\n              // These properties are only used to throw an error for an octal which occurs\r\n              // in a directive which occurs prior to a \"use strict\" directive.\r\n              this.state.containsOctal = true;\r\n              this.state.octalPosition = codePos;\r\n            }\r\n          }\r\n\r\n          return String.fromCharCode(octal);\r\n        }\r\n\r\n        return String.fromCharCode(ch);\r\n    }\r\n  }\r\n\r\n  // Used to read character escape sequences ('\\x', '\\u').\r\n\r\n  readHexChar(len: number, throwOnInvalid: boolean): number | null {\r\n    const codePos = this.state.pos;\r\n    const n = this.readInt(16, len);\r\n    if (n === null) {\r\n      if (throwOnInvalid) {\r\n        this.raise(codePos, \"Bad character escape sequence\");\r\n      } else {\r\n        this.state.pos = codePos - 1;\r\n        this.state.invalidTemplateEscapePosition = codePos - 1;\r\n      }\r\n    }\r\n    return n;\r\n  }\r\n\r\n  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`\r\n  // to whether the word contained a '\\u' escape.\r\n  //\r\n  // Incrementally adds only escaped chars, adding other chunks as-is\r\n  // as a micro-optimization.\r\n\r\n  readWord1(): string {\r\n    let word = \"\";\r\n    this.state.containsEsc = false;\r\n    const start = this.state.pos;\r\n    let chunkStart = this.state.pos;\r\n\r\n    while (this.state.pos < this.length) {\r\n      const ch = this.input.codePointAt(this.state.pos);\r\n      if (isIdentifierChar(ch)) {\r\n        this.state.pos += ch <= 0xffff ? 1 : 2;\r\n      } else if (this.state.isIterator && ch === charCodes.atSign) {\r\n        ++this.state.pos;\r\n      } else if (ch === charCodes.backslash) {\r\n        this.state.containsEsc = true;\r\n\r\n        word += this.input.slice(chunkStart, this.state.pos);\r\n        const escStart = this.state.pos;\r\n        const identifierCheck =\r\n          this.state.pos === start ? isIdentifierStart : isIdentifierChar;\r\n\r\n        if (this.input.charCodeAt(++this.state.pos) !== charCodes.lowercaseU) {\r\n          this.raise(\r\n            this.state.pos,\r\n            \"Expecting Unicode escape sequence \\\\uXXXX\",\r\n          );\r\n        }\r\n\r\n        ++this.state.pos;\r\n        const esc = this.readCodePoint(true);\r\n\r\n        if (\r\n          // $FlowFixMe (thinks esc may be null, but throwOnInvalid is true)\r\n          !identifierCheck(esc, true)\r\n        ) {\r\n          this.raise(escStart, \"Invalid Unicode escape\");\r\n        }\r\n\r\n        // $FlowFixMe\r\n        word += String.fromCodePoint(esc);\r\n        chunkStart = this.state.pos;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    return word + this.input.slice(chunkStart, this.state.pos);\r\n  }\r\n\r\n  isIterator(word: string): boolean {\r\n    return word === \"@@iterator\" || word === \"@@asyncIterator\";\r\n  }\r\n\r\n  // Read an identifier or keyword token. Will check for reserved\r\n  // words when necessary.\r\n\r\n  readWord(): void {\r\n    const word = this.readWord1();\r\n    const type = keywordTypes.get(word) || tt.name;\r\n\r\n    if (type.keyword && this.state.containsEsc) {\r\n      this.raise(this.state.pos, `Escape sequence in keyword ${word}`);\r\n    }\r\n\r\n    // Allow @@iterator and @@asyncIterator as a identifier only inside type\r\n    if (\r\n      this.state.isIterator &&\r\n      (!this.isIterator(word) || !this.state.inType)\r\n    ) {\r\n      this.raise(this.state.pos, `Invalid identifier ${word}`);\r\n    }\r\n\r\n    this.finishToken(type, word);\r\n  }\r\n\r\n  braceIsBlock(prevType: TokenType): boolean {\r\n    const parent = this.curContext();\r\n    if (parent === ct.functionExpression || parent === ct.functionStatement) {\r\n      return true;\r\n    }\r\n    if (\r\n      prevType === tt.colon &&\r\n      (parent === ct.braceStatement || parent === ct.braceExpression)\r\n    ) {\r\n      return !parent.isExpr;\r\n    }\r\n\r\n    // The check for `tt.name && exprAllowed` detects whether we are\r\n    // after a `yield` or `of` construct. See the `updateContext` for\r\n    // `tt.name`.\r\n    if (\r\n      prevType === tt._return ||\r\n      (prevType === tt.name && this.state.exprAllowed)\r\n    ) {\r\n      return lineBreak.test(\r\n        this.input.slice(this.state.lastTokEnd, this.state.start),\r\n      );\r\n    }\r\n\r\n    if (\r\n      prevType === tt._else ||\r\n      prevType === tt.semi ||\r\n      prevType === tt.eof ||\r\n      prevType === tt.parenR ||\r\n      prevType === tt.arrow\r\n    ) {\r\n      return true;\r\n    }\r\n\r\n    if (prevType === tt.braceL) {\r\n      return parent === ct.braceStatement;\r\n    }\r\n\r\n    if (\r\n      prevType === tt._var ||\r\n      prevType === tt._const ||\r\n      prevType === tt.name\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    if (prevType === tt.relational) {\r\n      // `class C<T> { ... }`\r\n      return true;\r\n    }\r\n\r\n    return !this.state.exprAllowed;\r\n  }\r\n\r\n  updateContext(prevType: TokenType): void {\r\n    const type = this.state.type;\r\n    let update;\r\n\r\n    if (type.keyword && (prevType === tt.dot || prevType === tt.questionDot)) {\r\n      this.state.exprAllowed = false;\r\n    } else if ((update = type.updateContext)) {\r\n      update.call(this, prevType);\r\n    } else {\r\n      this.state.exprAllowed = type.beforeExpr;\r\n    }\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport { types as tt, type TokenType } from \"../tokenizer/types\";\r\nimport Tokenizer from \"../tokenizer\";\r\nimport type { Node } from \"../types\";\r\nimport { lineBreak, skipWhiteSpace } from \"../util/whitespace\";\r\n\r\nconst literal = /^('|\")((?:\\\\?.)*?)\\1/;\r\n\r\n// ## Parser utilities\r\n\r\nexport default class UtilParser extends Tokenizer {\r\n  // TODO\r\n\r\n  addExtra(node: Node, key: string, val: any): void {\r\n    if (!node) return;\r\n\r\n    const extra = (node.extra = node.extra || {});\r\n    extra[key] = val;\r\n  }\r\n\r\n  // TODO\r\n\r\n  isRelational(op: \"<\" | \">\"): boolean {\r\n    return this.match(tt.relational) && this.state.value === op;\r\n  }\r\n\r\n  isLookaheadRelational(op: \"<\" | \">\"): boolean {\r\n    const l = this.lookahead();\r\n    return l.type === tt.relational && l.value === op;\r\n  }\r\n\r\n  // TODO\r\n\r\n  expectRelational(op: \"<\" | \">\"): void {\r\n    if (this.isRelational(op)) {\r\n      this.next();\r\n    } else {\r\n      this.unexpected(null, tt.relational);\r\n    }\r\n  }\r\n\r\n  // eat() for relational operators.\r\n\r\n  eatRelational(op: \"<\" | \">\"): boolean {\r\n    if (this.isRelational(op)) {\r\n      this.next();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Tests whether parsed token is a contextual keyword.\r\n\r\n  isContextual(name: string): boolean {\r\n    return (\r\n      this.match(tt.name) &&\r\n      this.state.value === name &&\r\n      !this.state.containsEsc\r\n    );\r\n  }\r\n\r\n  isLookaheadContextual(name: string): boolean {\r\n    const l = this.lookahead();\r\n    return l.type === tt.name && l.value === name;\r\n  }\r\n\r\n  // Consumes contextual keyword if possible.\r\n\r\n  eatContextual(name: string): boolean {\r\n    return this.isContextual(name) && this.eat(tt.name);\r\n  }\r\n\r\n  // Asserts that following token is given contextual keyword.\r\n\r\n  expectContextual(name: string, message?: string): void {\r\n    if (!this.eatContextual(name)) this.unexpected(null, message);\r\n  }\r\n\r\n  // Test whether a semicolon can be inserted at the current position.\r\n\r\n  canInsertSemicolon(): boolean {\r\n    return (\r\n      this.match(tt.eof) ||\r\n      this.match(tt.braceR) ||\r\n      this.hasPrecedingLineBreak()\r\n    );\r\n  }\r\n\r\n  hasPrecedingLineBreak(): boolean {\r\n    return lineBreak.test(\r\n      this.input.slice(this.state.lastTokEnd, this.state.start),\r\n    );\r\n  }\r\n\r\n  // TODO\r\n\r\n  isLineTerminator(): boolean {\r\n    return this.eat(tt.semi) || this.canInsertSemicolon();\r\n  }\r\n\r\n  // Consume a semicolon, or, failing that, see if we are allowed to\r\n  // pretend that there is a semicolon at this position.\r\n\r\n  semicolon(): void {\r\n    if (!this.isLineTerminator()) this.unexpected(null, tt.semi);\r\n  }\r\n\r\n  // Expect a token of a given type. If found, consume it, otherwise,\r\n  // raise an unexpected token error at given pos.\r\n\r\n  expect(type: TokenType, pos?: ?number): void {\r\n    this.eat(type) || this.unexpected(pos, type);\r\n  }\r\n\r\n  // Throws if the current token and the prev one are separated by a space.\r\n  assertNoSpace(message: string = \"Unexpected space.\"): void {\r\n    if (this.state.start > this.state.lastTokEnd) {\r\n      this.raise(this.state.lastTokEnd, message);\r\n    }\r\n  }\r\n\r\n  // Raise an unexpected token error. Can take the expected token type\r\n  // instead of a message string.\r\n\r\n  unexpected(\r\n    pos: ?number,\r\n    messageOrType: string | TokenType = \"Unexpected token\",\r\n  ): empty {\r\n    if (typeof messageOrType !== \"string\") {\r\n      messageOrType = `Unexpected token, expected \"${messageOrType.label}\"`;\r\n    }\r\n    throw this.raise(pos != null ? pos : this.state.start, messageOrType);\r\n  }\r\n\r\n  expectPlugin(name: string, pos?: ?number): true {\r\n    if (!this.hasPlugin(name)) {\r\n      throw this.raise(\r\n        pos != null ? pos : this.state.start,\r\n        `This experimental syntax requires enabling the parser plugin: '${name}'`,\r\n        { missingPluginNames: [name] },\r\n      );\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  expectOnePlugin(names: Array<string>, pos?: ?number): void {\r\n    if (!names.some(n => this.hasPlugin(n))) {\r\n      throw this.raise(\r\n        pos != null ? pos : this.state.start,\r\n        `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(\r\n          \", \",\r\n        )}'`,\r\n        { missingPluginNames: names },\r\n      );\r\n    }\r\n  }\r\n\r\n  checkYieldAwaitInDefaultParams() {\r\n    if (\r\n      this.state.yieldPos &&\r\n      (!this.state.awaitPos || this.state.yieldPos < this.state.awaitPos)\r\n    ) {\r\n      this.raise(\r\n        this.state.yieldPos,\r\n        \"Yield cannot be used as name inside a generator function\",\r\n      );\r\n    }\r\n    if (this.state.awaitPos) {\r\n      this.raise(\r\n        this.state.awaitPos,\r\n        \"Await cannot be used as name inside an async function\",\r\n      );\r\n    }\r\n  }\r\n\r\n  strictDirective(start: number): boolean {\r\n    for (;;) {\r\n      // Try to find string literal.\r\n      skipWhiteSpace.lastIndex = start;\r\n      // $FlowIgnore\r\n      start += skipWhiteSpace.exec(this.input)[0].length;\r\n      const match = literal.exec(this.input.slice(start));\r\n      if (!match) break;\r\n      if (match[2] === \"use strict\") return true;\r\n      start += match[0].length;\r\n\r\n      // Skip semicolon, if any.\r\n      skipWhiteSpace.lastIndex = start;\r\n      // $FlowIgnore\r\n      start += skipWhiteSpace.exec(this.input)[0].length;\r\n      if (this.input[start] === \";\") {\r\n        start++;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport type Parser from \"./index\";\r\nimport UtilParser from \"./util\";\r\nimport { SourceLocation, type Position } from \"../util/location\";\r\nimport type { Comment, Node as NodeType, NodeBase } from \"../types\";\r\n\r\n// Start an AST node, attaching a start offset.\r\n\r\nclass Node implements NodeBase {\r\n  constructor(parser: Parser, pos: number, loc: Position) {\r\n    this.type = \"\";\r\n    this.start = pos;\r\n    this.end = 0;\r\n    this.loc = new SourceLocation(loc);\r\n    if (parser && parser.options.ranges) this.range = [pos, 0];\r\n    if (parser && parser.filename) this.loc.filename = parser.filename;\r\n  }\r\n\r\n  type: string;\r\n  start: number;\r\n  end: number;\r\n  loc: SourceLocation;\r\n  range: [number, number];\r\n  leadingComments: Array<Comment>;\r\n  trailingComments: Array<Comment>;\r\n  innerComments: Array<Comment>;\r\n  extra: { [key: string]: any };\r\n\r\n  __clone(): this {\r\n    // $FlowIgnore\r\n    const newNode: any = new Node();\r\n    const keys = Object.keys(this);\r\n    for (let i = 0, length = keys.length; i < length; i++) {\r\n      const key = keys[i];\r\n      // Do not clone comments that are already attached to the node\r\n      if (\r\n        key !== \"leadingComments\" &&\r\n        key !== \"trailingComments\" &&\r\n        key !== \"innerComments\"\r\n      ) {\r\n        // $FlowIgnore\r\n        newNode[key] = this[key];\r\n      }\r\n    }\r\n\r\n    return newNode;\r\n  }\r\n}\r\n\r\nexport class NodeUtils extends UtilParser {\r\n  startNode<T: NodeType>(): T {\r\n    // $FlowIgnore\r\n    return new Node(this, this.state.start, this.state.startLoc);\r\n  }\r\n\r\n  startNodeAt<T: NodeType>(pos: number, loc: Position): T {\r\n    // $FlowIgnore\r\n    return new Node(this, pos, loc);\r\n  }\r\n\r\n  /** Start a new node with a previous node's location. */\r\n  startNodeAtNode<T: NodeType>(type: NodeType): T {\r\n    return this.startNodeAt(type.start, type.loc.start);\r\n  }\r\n\r\n  // Finish an AST node, adding `type` and `end` properties.\r\n\r\n  finishNode<T: NodeType>(node: T, type: string): T {\r\n    return this.finishNodeAt(\r\n      node,\r\n      type,\r\n      this.state.lastTokEnd,\r\n      this.state.lastTokEndLoc,\r\n    );\r\n  }\r\n\r\n  // Finish node at given position\r\n\r\n  finishNodeAt<T: NodeType>(\r\n    node: T,\r\n    type: string,\r\n    pos: number,\r\n    loc: Position,\r\n  ): T {\r\n    if (process.env.NODE_ENV !== \"production\" && node.end > 0) {\r\n      throw new Error(\r\n        \"Do not call finishNode*() twice on the same node.\" +\r\n          \" Instead use resetEndLocation() or change type directly.\",\r\n      );\r\n    }\r\n    node.type = type;\r\n    node.end = pos;\r\n    node.loc.end = loc;\r\n    if (this.options.ranges) node.range[1] = pos;\r\n    this.processComment(node);\r\n    return node;\r\n  }\r\n\r\n  resetStartLocation(node: NodeBase, start: number, startLoc: Position): void {\r\n    node.start = start;\r\n    node.loc.start = startLoc;\r\n    if (this.options.ranges) node.range[0] = start;\r\n  }\r\n\r\n  resetEndLocation(\r\n    node: NodeBase,\r\n    end?: number = this.state.lastTokEnd,\r\n    endLoc?: Position = this.state.lastTokEndLoc,\r\n  ): void {\r\n    node.end = end;\r\n    node.loc.end = endLoc;\r\n    if (this.options.ranges) node.range[1] = end;\r\n  }\r\n\r\n  /**\r\n   * Reset the start location of node to the start location of locationNode\r\n   */\r\n  resetStartLocationFromNode(node: NodeBase, locationNode: NodeBase): void {\r\n    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport { types as tt, type TokenType } from \"../tokenizer/types\";\r\nimport type {\r\n  TSParameterProperty,\r\n  Decorator,\r\n  Expression,\r\n  Identifier,\r\n  Node,\r\n  ObjectExpression,\r\n  ObjectPattern,\r\n  Pattern,\r\n  RestElement,\r\n  SpreadElement,\r\n} from \"../types\";\r\nimport type { Pos, Position } from \"../util/location\";\r\nimport { isStrictBindReservedWord } from \"../util/identifier\";\r\nimport { NodeUtils } from \"./node\";\r\nimport { type BindingTypes, BIND_NONE } from \"../util/scopeflags\";\r\n\r\nexport default class LValParser extends NodeUtils {\r\n  // Forward-declaration: defined in expression.js\r\n  +parseIdentifier: (liberal?: boolean) => Identifier;\r\n  +parseMaybeAssign: (\r\n    noIn?: ?boolean,\r\n    refShorthandDefaultPos?: ?Pos,\r\n    afterLeftParse?: Function,\r\n    refNeedsArrowPos?: ?Pos,\r\n  ) => Expression;\r\n  +parseObj: <T: ObjectPattern | ObjectExpression>(\r\n    isPattern: boolean,\r\n    refShorthandDefaultPos?: ?Pos,\r\n  ) => T;\r\n  // Forward-declaration: defined in statement.js\r\n  +parseDecorator: () => Decorator;\r\n\r\n  // Convert existing expression atom to assignable pattern\r\n  // if possible.\r\n\r\n  toAssignable(\r\n    node: Node,\r\n    isBinding: ?boolean,\r\n    contextDescription: string,\r\n  ): Node {\r\n    if (node) {\r\n      switch (node.type) {\r\n        case \"Identifier\":\r\n        case \"ObjectPattern\":\r\n        case \"ArrayPattern\":\r\n        case \"AssignmentPattern\":\r\n          break;\r\n\r\n        case \"ObjectExpression\":\r\n          node.type = \"ObjectPattern\";\r\n          for (\r\n            let i = 0, length = node.properties.length, last = length - 1;\r\n            i < length;\r\n            i++\r\n          ) {\r\n            const prop = node.properties[i];\r\n            const isLast = i === last;\r\n            this.toAssignableObjectExpressionProp(prop, isBinding, isLast);\r\n          }\r\n          break;\r\n\r\n        case \"ObjectProperty\":\r\n          this.toAssignable(node.value, isBinding, contextDescription);\r\n          break;\r\n\r\n        case \"SpreadElement\": {\r\n          this.checkToRestConversion(node);\r\n\r\n          node.type = \"RestElement\";\r\n          const arg = node.argument;\r\n          this.toAssignable(arg, isBinding, contextDescription);\r\n          break;\r\n        }\r\n\r\n        case \"ArrayExpression\":\r\n          node.type = \"ArrayPattern\";\r\n          this.toAssignableList(node.elements, isBinding, contextDescription);\r\n          break;\r\n\r\n        case \"AssignmentExpression\":\r\n          if (node.operator === \"=\") {\r\n            node.type = \"AssignmentPattern\";\r\n            delete node.operator;\r\n          } else {\r\n            this.raise(\r\n              node.left.end,\r\n              \"Only '=' operator can be used for specifying default value.\",\r\n            );\r\n          }\r\n          break;\r\n\r\n        case \"ParenthesizedExpression\":\r\n          node.expression = this.toAssignable(\r\n            node.expression,\r\n            isBinding,\r\n            contextDescription,\r\n          );\r\n          break;\r\n\r\n        case \"MemberExpression\":\r\n          if (!isBinding) break;\r\n\r\n        default: {\r\n          const message =\r\n            \"Invalid left-hand side\" +\r\n            (contextDescription\r\n              ? \" in \" + contextDescription\r\n              : /* istanbul ignore next */ \"expression\");\r\n          this.raise(node.start, message);\r\n        }\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n\r\n  toAssignableObjectExpressionProp(\r\n    prop: Node,\r\n    isBinding: ?boolean,\r\n    isLast: boolean,\r\n  ) {\r\n    if (prop.type === \"ObjectMethod\") {\r\n      const error =\r\n        prop.kind === \"get\" || prop.kind === \"set\"\r\n          ? \"Object pattern can't contain getter or setter\"\r\n          : \"Object pattern can't contain methods\";\r\n\r\n      this.raise(prop.key.start, error);\r\n    } else if (prop.type === \"SpreadElement\" && !isLast) {\r\n      this.raiseRestNotLast(prop.start);\r\n    } else {\r\n      this.toAssignable(prop, isBinding, \"object destructuring pattern\");\r\n    }\r\n  }\r\n\r\n  // Convert list of expression atoms to binding list.\r\n\r\n  toAssignableList(\r\n    exprList: Expression[],\r\n    isBinding: ?boolean,\r\n    contextDescription: string,\r\n  ): $ReadOnlyArray<Pattern> {\r\n    let end = exprList.length;\r\n    if (end) {\r\n      const last = exprList[end - 1];\r\n      if (last && last.type === \"RestElement\") {\r\n        --end;\r\n      } else if (last && last.type === \"SpreadElement\") {\r\n        last.type = \"RestElement\";\r\n        const arg = last.argument;\r\n        this.toAssignable(arg, isBinding, contextDescription);\r\n        if (\r\n          arg.type !== \"Identifier\" &&\r\n          arg.type !== \"MemberExpression\" &&\r\n          arg.type !== \"ArrayPattern\" &&\r\n          arg.type !== \"ObjectPattern\"\r\n        ) {\r\n          this.unexpected(arg.start);\r\n        }\r\n        --end;\r\n      }\r\n    }\r\n    for (let i = 0; i < end; i++) {\r\n      const elt = exprList[i];\r\n      if (elt) {\r\n        this.toAssignable(elt, isBinding, contextDescription);\r\n        if (elt.type === \"RestElement\") {\r\n          this.raiseRestNotLast(elt.start);\r\n        }\r\n      }\r\n    }\r\n    return exprList;\r\n  }\r\n\r\n  // Convert list of expression atoms to a list of\r\n\r\n  toReferencedList(\r\n    exprList: $ReadOnlyArray<?Expression>,\r\n    isParenthesizedExpr?: boolean, // eslint-disable-line no-unused-vars\r\n  ): $ReadOnlyArray<?Expression> {\r\n    return exprList;\r\n  }\r\n\r\n  toReferencedListDeep(\r\n    exprList: $ReadOnlyArray<?Expression>,\r\n    isParenthesizedExpr?: boolean,\r\n  ): $ReadOnlyArray<?Expression> {\r\n    this.toReferencedList(exprList, isParenthesizedExpr);\r\n\r\n    for (const expr of exprList) {\r\n      if (expr && expr.type === \"ArrayExpression\") {\r\n        this.toReferencedListDeep(expr.elements);\r\n      }\r\n    }\r\n\r\n    return exprList;\r\n  }\r\n\r\n  // Parses spread element.\r\n\r\n  parseSpread(\r\n    refShorthandDefaultPos: ?Pos,\r\n    refNeedsArrowPos?: ?Pos,\r\n  ): SpreadElement {\r\n    const node = this.startNode();\r\n    this.next();\r\n    node.argument = this.parseMaybeAssign(\r\n      false,\r\n      refShorthandDefaultPos,\r\n      undefined,\r\n      refNeedsArrowPos,\r\n    );\r\n\r\n    if (this.state.commaAfterSpreadAt === -1 && this.match(tt.comma)) {\r\n      this.state.commaAfterSpreadAt = this.state.start;\r\n    }\r\n\r\n    return this.finishNode(node, \"SpreadElement\");\r\n  }\r\n\r\n  parseRestBinding(): RestElement {\r\n    const node = this.startNode();\r\n    this.next();\r\n    node.argument = this.parseBindingAtom();\r\n    return this.finishNode(node, \"RestElement\");\r\n  }\r\n\r\n  // Parses lvalue (assignable) atom.\r\n  parseBindingAtom(): Pattern {\r\n    switch (this.state.type) {\r\n      case tt.bracketL: {\r\n        const node = this.startNode();\r\n        this.next();\r\n        node.elements = this.parseBindingList(tt.bracketR, true);\r\n        return this.finishNode(node, \"ArrayPattern\");\r\n      }\r\n\r\n      case tt.braceL:\r\n        return this.parseObj(true);\r\n    }\r\n\r\n    return this.parseIdentifier();\r\n  }\r\n\r\n  parseBindingList(\r\n    close: TokenType,\r\n    allowEmpty?: boolean,\r\n    allowModifiers?: boolean,\r\n  ): $ReadOnlyArray<Pattern | TSParameterProperty> {\r\n    const elts: Array<Pattern | TSParameterProperty> = [];\r\n    let first = true;\r\n    while (!this.eat(close)) {\r\n      if (first) {\r\n        first = false;\r\n      } else {\r\n        this.expect(tt.comma);\r\n      }\r\n      if (allowEmpty && this.match(tt.comma)) {\r\n        // $FlowFixMe This method returns `$ReadOnlyArray<?Pattern>` if `allowEmpty` is set.\r\n        elts.push(null);\r\n      } else if (this.eat(close)) {\r\n        break;\r\n      } else if (this.match(tt.ellipsis)) {\r\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\r\n        this.checkCommaAfterRest();\r\n        this.expect(close);\r\n        break;\r\n      } else {\r\n        const decorators = [];\r\n        if (this.match(tt.at) && this.hasPlugin(\"decorators\")) {\r\n          this.raise(\r\n            this.state.start,\r\n            \"Stage 2 decorators cannot be used to decorate parameters\",\r\n          );\r\n        }\r\n        while (this.match(tt.at)) {\r\n          decorators.push(this.parseDecorator());\r\n        }\r\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\r\n      }\r\n    }\r\n    return elts;\r\n  }\r\n\r\n  parseAssignableListItem(\r\n    allowModifiers: ?boolean,\r\n    decorators: Decorator[],\r\n  ): Pattern | TSParameterProperty {\r\n    const left = this.parseMaybeDefault();\r\n    this.parseAssignableListItemTypes(left);\r\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\r\n    if (decorators.length) {\r\n      left.decorators = decorators;\r\n    }\r\n    return elt;\r\n  }\r\n\r\n  parseAssignableListItemTypes(param: Pattern): Pattern {\r\n    return param;\r\n  }\r\n\r\n  // Parses assignment pattern around given atom if possible.\r\n\r\n  parseMaybeDefault(\r\n    startPos?: ?number,\r\n    startLoc?: ?Position,\r\n    left?: ?Pattern,\r\n  ): Pattern {\r\n    startLoc = startLoc || this.state.startLoc;\r\n    startPos = startPos || this.state.start;\r\n    left = left || this.parseBindingAtom();\r\n    if (!this.eat(tt.eq)) return left;\r\n\r\n    const node = this.startNodeAt(startPos, startLoc);\r\n    node.left = left;\r\n    node.right = this.parseMaybeAssign();\r\n    return this.finishNode(node, \"AssignmentPattern\");\r\n  }\r\n\r\n  // Verify that a node is an lval — something that can be assigned\r\n  // to.\r\n\r\n  checkLVal(\r\n    expr: Expression,\r\n    bindingType: BindingTypes = BIND_NONE,\r\n    checkClashes: ?{ [key: string]: boolean },\r\n    contextDescription: string,\r\n  ): void {\r\n    switch (expr.type) {\r\n      case \"Identifier\":\r\n        if (\r\n          this.state.strict &&\r\n          isStrictBindReservedWord(expr.name, this.inModule)\r\n        ) {\r\n          this.raise(\r\n            expr.start,\r\n            `${bindingType === BIND_NONE ? \"Assigning to\" : \"Binding\"} '${\r\n              expr.name\r\n            }' in strict mode`,\r\n          );\r\n        }\r\n\r\n        if (checkClashes) {\r\n          // we need to prefix this with an underscore for the cases where we have a key of\r\n          // `__proto__`. there's a bug in old V8 where the following wouldn't work:\r\n          //\r\n          //   > var obj = Object.create(null);\r\n          //   undefined\r\n          //   > obj.__proto__\r\n          //   null\r\n          //   > obj.__proto__ = true;\r\n          //   true\r\n          //   > obj.__proto__\r\n          //   null\r\n          const key = `_${expr.name}`;\r\n\r\n          if (checkClashes[key]) {\r\n            this.raise(expr.start, \"Argument name clash\");\r\n          } else {\r\n            checkClashes[key] = true;\r\n          }\r\n        }\r\n        if (!(bindingType & BIND_NONE)) {\r\n          this.scope.declareName(expr.name, bindingType, expr.start);\r\n        }\r\n        break;\r\n\r\n      case \"MemberExpression\":\r\n        if (bindingType !== BIND_NONE) {\r\n          this.raise(expr.start, \"Binding member expression\");\r\n        }\r\n        break;\r\n\r\n      case \"ObjectPattern\":\r\n        for (let prop of expr.properties) {\r\n          if (prop.type === \"ObjectProperty\") prop = prop.value;\r\n          this.checkLVal(\r\n            prop,\r\n            bindingType,\r\n            checkClashes,\r\n            \"object destructuring pattern\",\r\n          );\r\n        }\r\n        break;\r\n\r\n      case \"ArrayPattern\":\r\n        for (const elem of expr.elements) {\r\n          if (elem) {\r\n            this.checkLVal(\r\n              elem,\r\n              bindingType,\r\n              checkClashes,\r\n              \"array destructuring pattern\",\r\n            );\r\n          }\r\n        }\r\n        break;\r\n\r\n      case \"AssignmentPattern\":\r\n        this.checkLVal(\r\n          expr.left,\r\n          bindingType,\r\n          checkClashes,\r\n          \"assignment pattern\",\r\n        );\r\n        break;\r\n\r\n      case \"RestElement\":\r\n        this.checkLVal(\r\n          expr.argument,\r\n          bindingType,\r\n          checkClashes,\r\n          \"rest element\",\r\n        );\r\n        break;\r\n\r\n      case \"ParenthesizedExpression\":\r\n        this.checkLVal(\r\n          expr.expression,\r\n          bindingType,\r\n          checkClashes,\r\n          \"parenthesized expression\",\r\n        );\r\n        break;\r\n\r\n      default: {\r\n        const message =\r\n          (bindingType === BIND_NONE\r\n            ? \"Invalid\"\r\n            : /* istanbul ignore next */ \"Binding invalid\") +\r\n          \" left-hand side\" +\r\n          (contextDescription\r\n            ? \" in \" + contextDescription\r\n            : /* istanbul ignore next */ \"expression\");\r\n        this.raise(expr.start, message);\r\n      }\r\n    }\r\n  }\r\n\r\n  checkToRestConversion(node: SpreadElement): void {\r\n    if (\r\n      node.argument.type !== \"Identifier\" &&\r\n      node.argument.type !== \"MemberExpression\"\r\n    ) {\r\n      this.raise(node.argument.start, \"Invalid rest operator's argument\");\r\n    }\r\n  }\r\n\r\n  checkCommaAfterRest(): void {\r\n    if (this.match(tt.comma)) {\r\n      this.raiseRestNotLast(this.state.start);\r\n    }\r\n  }\r\n\r\n  checkCommaAfterRestFromSpread(): void {\r\n    if (this.state.commaAfterSpreadAt > -1) {\r\n      this.raiseRestNotLast(this.state.commaAfterSpreadAt);\r\n    }\r\n  }\r\n\r\n  raiseRestNotLast(pos: number) {\r\n    this.raise(pos, `Rest element must be last element`);\r\n  }\r\n}\r\n","// @flow\r\n\r\n// A recursive descent parser operates by defining functions for all\r\n// syntactic elements, and recursively calling those, each function\r\n// advancing the input stream and returning an AST node. Precedence\r\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\r\n// instead of `(!x)[1]` is handled by the fact that the parser\r\n// function that parses unary prefix operators is called first, and\r\n// in turn calls the function that parses `[]` subscripts — that\r\n// way, it'll receive the node for `x[1]` already parsed, and wraps\r\n// *that* in the unary operator node.\r\n//\r\n// Acorn uses an [operator precedence parser][opp] to handle binary\r\n// operator precedence, because it is much more compact than using\r\n// the technique outlined above, which uses different, nesting\r\n// functions to specify precedence, for all of the ten binary\r\n// precedence levels that JavaScript defines.\r\n//\r\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\r\n\r\nimport { types as tt, type TokenType } from \"../tokenizer/types\";\r\nimport * as N from \"../types\";\r\nimport LValParser from \"./lval\";\r\nimport {\r\n  isKeyword,\r\n  isReservedWord,\r\n  isStrictReservedWord,\r\n  isStrictBindReservedWord,\r\n} from \"../util/identifier\";\r\nimport type { Pos, Position } from \"../util/location\";\r\nimport * as charCodes from \"charcodes\";\r\nimport {\r\n  BIND_OUTSIDE,\r\n  BIND_VAR,\r\n  functionFlags,\r\n  SCOPE_ARROW,\r\n  SCOPE_CLASS,\r\n  SCOPE_DIRECT_SUPER,\r\n  SCOPE_SUPER,\r\n  SCOPE_PROGRAM,\r\n} from \"../util/scopeflags\";\r\n\r\nconst unwrapParenthesizedExpression = node => {\r\n  return node.type === \"ParenthesizedExpression\"\r\n    ? unwrapParenthesizedExpression(node.expression)\r\n    : node;\r\n};\r\n\r\nexport default class ExpressionParser extends LValParser {\r\n  // Forward-declaration: defined in statement.js\r\n  +parseBlock: (\r\n    allowDirectives?: boolean,\r\n    createNewLexicalScope?: boolean,\r\n  ) => N.BlockStatement;\r\n  +parseClass: (\r\n    node: N.Class,\r\n    isStatement: boolean,\r\n    optionalId?: boolean,\r\n  ) => N.Class;\r\n  +parseDecorators: (allowExport?: boolean) => void;\r\n  +parseFunction: <T: N.NormalFunction>(\r\n    node: T,\r\n    statement?: number,\r\n    allowExpressionBody?: boolean,\r\n    isAsync?: boolean,\r\n  ) => T;\r\n  +parseFunctionParams: (node: N.Function, allowModifiers?: boolean) => void;\r\n  +takeDecorators: (node: N.HasDecorators) => void;\r\n\r\n  // Check if property name clashes with already added.\r\n  // Object/class getters and setters are not allowed to clash —\r\n  // either with each other or with an init property — and in\r\n  // strict mode, init properties are also not allowed to be repeated.\r\n\r\n  checkPropClash(\r\n    prop: N.ObjectMember | N.SpreadElement,\r\n    propHash: { [key: string]: boolean },\r\n  ): void {\r\n    if (\r\n      prop.type === \"SpreadElement\" ||\r\n      prop.computed ||\r\n      prop.kind ||\r\n      // $FlowIgnore\r\n      prop.shorthand\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const key = prop.key;\r\n    // It is either an Identifier or a String/NumericLiteral\r\n    const name = key.type === \"Identifier\" ? key.name : String(key.value);\r\n\r\n    if (name === \"__proto__\") {\r\n      if (propHash.proto) {\r\n        this.raise(key.start, \"Redefinition of __proto__ property\");\r\n      }\r\n      propHash.proto = true;\r\n    }\r\n  }\r\n\r\n  // Convenience method to parse an Expression only\r\n  getExpression(): N.Expression {\r\n    this.scope.enter(SCOPE_PROGRAM);\r\n    this.nextToken();\r\n    const expr = this.parseExpression();\r\n    if (!this.match(tt.eof)) {\r\n      this.unexpected();\r\n    }\r\n    expr.comments = this.state.comments;\r\n    return expr;\r\n  }\r\n\r\n  // ### Expression parsing\r\n\r\n  // These nest, from the most general expression type at the top to\r\n  // 'atomic', nondivisible expression types at the bottom. Most of\r\n  // the functions will simply let the function (s) below them parse,\r\n  // and, *if* the syntactic construct they handle is present, wrap\r\n  // the AST node that the inner parser gave them in another node.\r\n\r\n  // Parse a full expression. The optional arguments are used to\r\n  // forbid the `in` operator (in for loops initialization expressions)\r\n  // and provide reference for storing '=' operator inside shorthand\r\n  // property assignment in contexts where both object expression\r\n  // and object pattern might appear (so it's possible to raise\r\n  // delayed syntax error at correct position).\r\n\r\n  parseExpression(noIn?: boolean, refShorthandDefaultPos?: Pos): N.Expression {\r\n    const startPos = this.state.start;\r\n    const startLoc = this.state.startLoc;\r\n    const expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);\r\n    if (this.match(tt.comma)) {\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n      node.expressions = [expr];\r\n      while (this.eat(tt.comma)) {\r\n        node.expressions.push(\r\n          this.parseMaybeAssign(noIn, refShorthandDefaultPos),\r\n        );\r\n      }\r\n      this.toReferencedList(node.expressions);\r\n      return this.finishNode(node, \"SequenceExpression\");\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  // Parse an assignment expression. This includes applications of\r\n  // operators like `+=`.\r\n\r\n  parseMaybeAssign(\r\n    noIn?: ?boolean,\r\n    refShorthandDefaultPos?: ?Pos,\r\n    afterLeftParse?: Function,\r\n    refNeedsArrowPos?: ?Pos,\r\n  ): N.Expression {\r\n    const startPos = this.state.start;\r\n    const startLoc = this.state.startLoc;\r\n    if (this.isContextual(\"yield\")) {\r\n      if (this.scope.inGenerator) {\r\n        let left = this.parseYield(noIn);\r\n        if (afterLeftParse) {\r\n          left = afterLeftParse.call(this, left, startPos, startLoc);\r\n        }\r\n        return left;\r\n      } else {\r\n        // The tokenizer will assume an expression is allowed after\r\n        // `yield`, but this isn't that kind of yield\r\n        this.state.exprAllowed = false;\r\n      }\r\n    }\r\n\r\n    const oldCommaAfterSpreadAt = this.state.commaAfterSpreadAt;\r\n    this.state.commaAfterSpreadAt = -1;\r\n\r\n    let failOnShorthandAssign;\r\n    if (refShorthandDefaultPos) {\r\n      failOnShorthandAssign = false;\r\n    } else {\r\n      refShorthandDefaultPos = { start: 0 };\r\n      failOnShorthandAssign = true;\r\n    }\r\n\r\n    if (this.match(tt.parenL) || this.match(tt.name)) {\r\n      this.state.potentialArrowAt = this.state.start;\r\n    }\r\n\r\n    let left = this.parseMaybeConditional(\r\n      noIn,\r\n      refShorthandDefaultPos,\r\n      refNeedsArrowPos,\r\n    );\r\n    if (afterLeftParse) {\r\n      left = afterLeftParse.call(this, left, startPos, startLoc);\r\n    }\r\n    if (this.state.type.isAssign) {\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n      const operator = this.state.value;\r\n      node.operator = operator;\r\n\r\n      if (operator === \"??=\") {\r\n        this.expectPlugin(\"nullishCoalescingOperator\");\r\n        this.expectPlugin(\"logicalAssignment\");\r\n      }\r\n      if (operator === \"||=\" || operator === \"&&=\") {\r\n        this.expectPlugin(\"logicalAssignment\");\r\n      }\r\n      node.left = this.match(tt.eq)\r\n        ? this.toAssignable(left, undefined, \"assignment expression\")\r\n        : left;\r\n      refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly\r\n\r\n      this.checkLVal(left, undefined, undefined, \"assignment expression\");\r\n\r\n      const maybePattern = unwrapParenthesizedExpression(left);\r\n\r\n      let patternErrorMsg;\r\n      if (maybePattern.type === \"ObjectPattern\") {\r\n        patternErrorMsg = \"`({a}) = 0` use `({a} = 0)`\";\r\n      } else if (maybePattern.type === \"ArrayPattern\") {\r\n        patternErrorMsg = \"`([a]) = 0` use `([a] = 0)`\";\r\n      }\r\n\r\n      if (\r\n        patternErrorMsg &&\r\n        ((left.extra && left.extra.parenthesized) ||\r\n          left.type === \"ParenthesizedExpression\")\r\n      ) {\r\n        this.raise(\r\n          maybePattern.start,\r\n          `You're trying to assign to a parenthesized expression, eg. instead of ${patternErrorMsg}`,\r\n        );\r\n      }\r\n\r\n      if (patternErrorMsg) this.checkCommaAfterRestFromSpread();\r\n      this.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;\r\n\r\n      this.next();\r\n      node.right = this.parseMaybeAssign(noIn);\r\n      return this.finishNode(node, \"AssignmentExpression\");\r\n    } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {\r\n      this.unexpected(refShorthandDefaultPos.start);\r\n    }\r\n\r\n    this.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;\r\n\r\n    return left;\r\n  }\r\n\r\n  // Parse a ternary conditional (`?:`) operator.\r\n\r\n  parseMaybeConditional(\r\n    noIn: ?boolean,\r\n    refShorthandDefaultPos: Pos,\r\n    refNeedsArrowPos?: ?Pos,\r\n  ): N.Expression {\r\n    const startPos = this.state.start;\r\n    const startLoc = this.state.startLoc;\r\n    const potentialArrowAt = this.state.potentialArrowAt;\r\n    const expr = this.parseExprOps(noIn, refShorthandDefaultPos);\r\n\r\n    if (\r\n      expr.type === \"ArrowFunctionExpression\" &&\r\n      expr.start === potentialArrowAt\r\n    ) {\r\n      return expr;\r\n    }\r\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\r\n\r\n    return this.parseConditional(\r\n      expr,\r\n      noIn,\r\n      startPos,\r\n      startLoc,\r\n      refNeedsArrowPos,\r\n    );\r\n  }\r\n\r\n  parseConditional(\r\n    expr: N.Expression,\r\n    noIn: ?boolean,\r\n    startPos: number,\r\n    startLoc: Position,\r\n    // FIXME: Disabling this for now since can't seem to get it to play nicely\r\n    // eslint-disable-next-line no-unused-vars\r\n    refNeedsArrowPos?: ?Pos,\r\n  ): N.Expression {\r\n    if (this.eat(tt.question)) {\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n      node.test = expr;\r\n      node.consequent = this.parseMaybeAssign();\r\n      this.expect(tt.colon);\r\n      node.alternate = this.parseMaybeAssign(noIn);\r\n      return this.finishNode(node, \"ConditionalExpression\");\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  // Start the precedence parser.\r\n\r\n  parseExprOps(noIn: ?boolean, refShorthandDefaultPos: Pos): N.Expression {\r\n    const startPos = this.state.start;\r\n    const startLoc = this.state.startLoc;\r\n    const potentialArrowAt = this.state.potentialArrowAt;\r\n    const expr = this.parseMaybeUnary(refShorthandDefaultPos);\r\n\r\n    if (\r\n      expr.type === \"ArrowFunctionExpression\" &&\r\n      expr.start === potentialArrowAt\r\n    ) {\r\n      return expr;\r\n    }\r\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\r\n      return expr;\r\n    }\r\n\r\n    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);\r\n  }\r\n\r\n  // Parse binary operators with the operator precedence parsing\r\n  // algorithm. `left` is the left-hand side of the operator.\r\n  // `minPrec` provides context that allows the function to stop and\r\n  // defer further parser to one of its callers when it encounters an\r\n  // operator that has a lower precedence than the set it is parsing.\r\n\r\n  parseExprOp(\r\n    left: N.Expression,\r\n    leftStartPos: number,\r\n    leftStartLoc: Position,\r\n    minPrec: number,\r\n    noIn: ?boolean,\r\n  ): N.Expression {\r\n    const prec = this.state.type.binop;\r\n    if (prec != null && (!noIn || !this.match(tt._in))) {\r\n      if (prec > minPrec) {\r\n        const node = this.startNodeAt(leftStartPos, leftStartLoc);\r\n        const operator = this.state.value;\r\n        node.left = left;\r\n        node.operator = operator;\r\n        if (\r\n          operator === \"**\" &&\r\n          left.type === \"UnaryExpression\" &&\r\n          (this.options.createParenthesizedExpressions ||\r\n            !(left.extra && left.extra.parenthesized))\r\n        ) {\r\n          this.raise(\r\n            left.argument.start,\r\n            \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\r\n          );\r\n        }\r\n\r\n        const op = this.state.type;\r\n\r\n        if (op === tt.pipeline) {\r\n          this.expectPlugin(\"pipelineOperator\");\r\n          this.state.inPipeline = true;\r\n          this.checkPipelineAtInfixOperator(left, leftStartPos);\r\n        } else if (op === tt.nullishCoalescing) {\r\n          this.expectPlugin(\"nullishCoalescingOperator\");\r\n        }\r\n\r\n        this.next();\r\n\r\n        if (\r\n          op === tt.pipeline &&\r\n          this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"minimal\"\r\n        ) {\r\n          if (\r\n            this.match(tt.name) &&\r\n            this.state.value === \"انتظر\" &&\r\n            this.scope.inAsync\r\n          ) {\r\n            throw this.raise(\r\n              this.state.start,\r\n              `Unexpected \"انتظر\" after pipeline body; await must have parentheses in minimal proposal`,\r\n            );\r\n          }\r\n        }\r\n\r\n        node.right = this.parseExprOpRightExpr(op, prec, noIn);\r\n\r\n        this.finishNode(\r\n          node,\r\n          op === tt.logicalOR ||\r\n            op === tt.logicalAND ||\r\n            op === tt.nullishCoalescing\r\n            ? \"LogicalExpression\"\r\n            : \"BinaryExpression\",\r\n        );\r\n\r\n        return this.parseExprOp(\r\n          node,\r\n          leftStartPos,\r\n          leftStartLoc,\r\n          minPrec,\r\n          noIn,\r\n        );\r\n      }\r\n    }\r\n    return left;\r\n  }\r\n\r\n  // Helper function for `parseExprOp`. Parse the right-hand side of binary-\r\n  // operator expressions, then apply any operator-specific functions.\r\n\r\n  parseExprOpRightExpr(\r\n    op: TokenType,\r\n    prec: number,\r\n    noIn: ?boolean,\r\n  ): N.Expression {\r\n    switch (op) {\r\n      case tt.pipeline:\r\n        if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\r\n          const startPos = this.state.start;\r\n          const startLoc = this.state.startLoc;\r\n          return this.withTopicPermittingContext(() => {\r\n            return this.parseSmartPipelineBody(\r\n              this.parseExprOpBaseRightExpr(op, prec, noIn),\r\n              startPos,\r\n              startLoc,\r\n            );\r\n          });\r\n        }\r\n      // falls through\r\n\r\n      default:\r\n        return this.parseExprOpBaseRightExpr(op, prec, noIn);\r\n    }\r\n  }\r\n\r\n  // Helper function for `parseExprOpRightExpr`. Parse the right-hand side of\r\n  // binary-operator expressions without applying any operator-specific functions.\r\n\r\n  parseExprOpBaseRightExpr(\r\n    op: TokenType,\r\n    prec: number,\r\n    noIn: ?boolean,\r\n  ): N.Expression {\r\n    const startPos = this.state.start;\r\n    const startLoc = this.state.startLoc;\r\n\r\n    return this.parseExprOp(\r\n      this.parseMaybeUnary(),\r\n      startPos,\r\n      startLoc,\r\n      op.rightAssociative ? prec - 1 : prec,\r\n      noIn,\r\n    );\r\n  }\r\n\r\n  // Parse unary operators, both prefix and postfix.\r\n\r\n  parseMaybeUnary(refShorthandDefaultPos: ?Pos): N.Expression {\r\n    if (\r\n      this.isContextual(\"انتظر\") &&\r\n      (this.scope.inAsync ||\r\n        (!this.scope.inFunction && this.options.allowAwaitOutsideFunction))\r\n    ) {\r\n      return this.parseAwait();\r\n    } else if (this.state.type.prefix) {\r\n      const node = this.startNode();\r\n      const update = this.match(tt.incDec);\r\n      node.operator = this.state.value;\r\n      node.prefix = true;\r\n\r\n      if (node.operator === \"throw\") {\r\n        this.expectPlugin(\"throwExpressions\");\r\n      }\r\n      this.next();\r\n\r\n      node.argument = this.parseMaybeUnary();\r\n\r\n      if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\r\n        this.unexpected(refShorthandDefaultPos.start);\r\n      }\r\n\r\n      if (update) {\r\n        this.checkLVal(node.argument, undefined, undefined, \"prefix operation\");\r\n      } else if (this.state.strict && node.operator === \"delete\") {\r\n        const arg = node.argument;\r\n\r\n        if (arg.type === \"Identifier\") {\r\n          this.raise(node.start, \"Deleting local variable in strict mode\");\r\n        } else if (\r\n          arg.type === \"MemberExpression\" &&\r\n          arg.property.type === \"PrivateName\"\r\n        ) {\r\n          this.raise(node.start, \"Deleting a private field is not allowed\");\r\n        }\r\n      }\r\n\r\n      return this.finishNode(\r\n        node,\r\n        update ? \"UpdateExpression\" : \"UnaryExpression\",\r\n      );\r\n    }\r\n\r\n    const startPos = this.state.start;\r\n    const startLoc = this.state.startLoc;\r\n    let expr = this.parseExprSubscripts(refShorthandDefaultPos);\r\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\r\n    while (this.state.type.postfix && !this.canInsertSemicolon()) {\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n      node.operator = this.state.value;\r\n      node.prefix = false;\r\n      node.argument = expr;\r\n      this.checkLVal(expr, undefined, undefined, \"postfix operation\");\r\n      this.next();\r\n      expr = this.finishNode(node, \"UpdateExpression\");\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  // Parse call, dot, and `[]`-subscript expressions.\r\n\r\n  parseExprSubscripts(refShorthandDefaultPos: ?Pos): N.Expression {\r\n    const startPos = this.state.start;\r\n    const startLoc = this.state.startLoc;\r\n    const potentialArrowAt = this.state.potentialArrowAt;\r\n    const expr = this.parseExprAtom(refShorthandDefaultPos);\r\n\r\n    if (\r\n      expr.type === \"ArrowFunctionExpression\" &&\r\n      expr.start === potentialArrowAt\r\n    ) {\r\n      return expr;\r\n    }\r\n\r\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\r\n      return expr;\r\n    }\r\n\r\n    return this.parseSubscripts(expr, startPos, startLoc);\r\n  }\r\n\r\n  parseSubscripts(\r\n    base: N.Expression,\r\n    startPos: number,\r\n    startLoc: Position,\r\n    noCalls?: ?boolean,\r\n  ): N.Expression {\r\n    const maybeAsyncArrow = this.atPossibleAsync(base);\r\n\r\n    const state = {\r\n      optionalChainMember: false,\r\n      stop: false,\r\n    };\r\n    do {\r\n      base = this.parseSubscript(\r\n        base,\r\n        startPos,\r\n        startLoc,\r\n        noCalls,\r\n        state,\r\n        maybeAsyncArrow,\r\n      );\r\n    } while (!state.stop);\r\n    return base;\r\n  }\r\n\r\n  /**\r\n   * @param state Set 'state.stop = true' to indicate that we should stop parsing subscripts.\r\n   *   state.optionalChainMember to indicate that the member is currently in OptionalChain\r\n   */\r\n  parseSubscript(\r\n    base: N.Expression,\r\n    startPos: number,\r\n    startLoc: Position,\r\n    noCalls: ?boolean,\r\n    state: N.ParseSubscriptState,\r\n    maybeAsyncArrow: boolean,\r\n  ): N.Expression {\r\n    if (!noCalls && this.eat(tt.doubleColon)) {\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n      node.object = base;\r\n      node.callee = this.parseNoCallExpr();\r\n      state.stop = true;\r\n      return this.parseSubscripts(\r\n        this.finishNode(node, \"BindExpression\"),\r\n        startPos,\r\n        startLoc,\r\n        noCalls,\r\n      );\r\n    } else if (this.match(tt.questionDot)) {\r\n      this.expectPlugin(\"optionalChaining\");\r\n      state.optionalChainMember = true;\r\n      if (noCalls && this.lookahead().type === tt.parenL) {\r\n        state.stop = true;\r\n        return base;\r\n      }\r\n      this.next();\r\n\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n\r\n      if (this.eat(tt.bracketL)) {\r\n        node.object = base;\r\n        node.property = this.parseExpression();\r\n        node.computed = true;\r\n        node.optional = true;\r\n        this.expect(tt.bracketR);\r\n        return this.finishNode(node, \"OptionalMemberExpression\");\r\n      } else if (this.eat(tt.parenL)) {\r\n        node.callee = base;\r\n        node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\r\n        node.optional = true;\r\n        return this.finishNode(node, \"OptionalCallExpression\");\r\n      } else {\r\n        node.object = base;\r\n        node.property = this.parseIdentifier(true);\r\n        node.computed = false;\r\n        node.optional = true;\r\n        return this.finishNode(node, \"OptionalMemberExpression\");\r\n      }\r\n    } else if (this.eat(tt.dot)) {\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n      node.object = base;\r\n      node.property = this.parseMaybePrivateName();\r\n      node.computed = false;\r\n      if (state.optionalChainMember) {\r\n        node.optional = false;\r\n        return this.finishNode(node, \"OptionalMemberExpression\");\r\n      }\r\n      return this.finishNode(node, \"MemberExpression\");\r\n    } else if (this.eat(tt.bracketL)) {\r\n      const node = this.startNodeAt(startPos, startLoc);\r\n      node.object = base;\r\n      node.property = this.parseExpression();\r\n      node.computed = true;\r\n      this.expect(tt.bracketR);\r\n      if (state.optionalChainMember) {\r\n        node.optional = false;\r\n        return this.finishNode(node, \"OptionalMemberExpression\");\r\n      }\r\n      return this.finishNode(node, \"MemberExpression\");\r\n    } else if (!noCalls && this.match(tt.parenL)) {\r\n      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\r\n      const oldYieldPos = this.state.yieldPos;\r\n      const oldAwaitPos = this.state.awaitPos;\r\n      this.state.maybeInArrowParameters = true;\r\n      this.state.yieldPos = 0;\r\n      this.state.awaitPos = 0;\r\n\r\n      this.next();\r\n\r\n      let node = this.startNodeAt(startPos, startLoc);\r\n      node.callee = base;\r\n\r\n      const oldCommaAfterSpreadAt = this.state.commaAfterSpreadAt;\r\n      this.state.commaAfterSpreadAt = -1;\r\n\r\n      node.arguments = this.parseCallExpressionArguments(\r\n        tt.parenR,\r\n        maybeAsyncArrow,\r\n        base.type === \"Import\",\r\n        base.type !== \"Super\",\r\n      );\r\n      if (!state.optionalChainMember) {\r\n        this.finishCallExpression(node);\r\n      } else {\r\n        this.finishOptionalCallExpression(node);\r\n      }\r\n\r\n      if (maybeAsyncArrow && this.shouldParseAsyncArrow()) {\r\n        state.stop = true;\r\n\r\n        this.checkCommaAfterRestFromSpread();\r\n\r\n        node = this.parseAsyncArrowFromCallExpression(\r\n          this.startNodeAt(startPos, startLoc),\r\n          node,\r\n        );\r\n        this.checkYieldAwaitInDefaultParams();\r\n        this.state.yieldPos = oldYieldPos;\r\n        this.state.awaitPos = oldAwaitPos;\r\n      } else {\r\n        this.toReferencedListDeep(node.arguments);\r\n\r\n        // We keep the old value if it isn't null, for cases like\r\n        //   (x = async(yield)) => {}\r\n        this.state.yieldPos = oldYieldPos || this.state.yieldPos;\r\n        this.state.awaitPos = oldAwaitPos || this.state.awaitPos;\r\n      }\r\n\r\n      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\r\n      this.state.commaAfterSpreadAt = oldCommaAfterSpreadAt;\r\n\r\n      return node;\r\n    } else if (this.match(tt.backQuote)) {\r\n      return this.parseTaggedTemplateExpression(\r\n        startPos,\r\n        startLoc,\r\n        base,\r\n        state,\r\n      );\r\n    } else {\r\n      state.stop = true;\r\n      return base;\r\n    }\r\n  }\r\n\r\n  parseTaggedTemplateExpression(\r\n    startPos: number,\r\n    startLoc: Position,\r\n    base: N.Expression,\r\n    state: N.ParseSubscriptState,\r\n    typeArguments?: ?N.TsTypeParameterInstantiation,\r\n  ): N.TaggedTemplateExpression {\r\n    const node: N.TaggedTemplateExpression = this.startNodeAt(\r\n      startPos,\r\n      startLoc,\r\n    );\r\n    node.tag = base;\r\n    node.quasi = this.parseTemplate(true);\r\n    if (typeArguments) node.typeParameters = typeArguments;\r\n    if (state.optionalChainMember) {\r\n      this.raise(\r\n        startPos,\r\n        \"Tagged Template Literals are not allowed in optionalChain\",\r\n      );\r\n    }\r\n    return this.finishNode(node, \"TaggedTemplateExpression\");\r\n  }\r\n\r\n  atPossibleAsync(base: N.Expression): boolean {\r\n    return (\r\n      base.type === \"Identifier\" &&\r\n      base.name === \"غير_متزامن\" &&\r\n      this.state.lastTokEnd === base.end &&\r\n      !this.canInsertSemicolon() &&\r\n      this.input.slice(base.start, base.end) === \"غير_متزامن\"\r\n    );\r\n  }\r\n\r\n  finishCallExpression(node: N.CallExpression): N.CallExpression {\r\n    if (node.callee.type === \"Import\") {\r\n      if (node.arguments.length !== 1) {\r\n        this.raise(node.start, \"import() requires exactly one argument\");\r\n      }\r\n\r\n      const importArg = node.arguments[0];\r\n      if (importArg && importArg.type === \"SpreadElement\") {\r\n        this.raise(importArg.start, \"... is not allowed in import()\");\r\n      }\r\n    }\r\n    return this.finishNode(node, \"CallExpression\");\r\n  }\r\n\r\n  finishOptionalCallExpression(node: N.CallExpression): N.CallExpression {\r\n    if (node.callee.type === \"Import\") {\r\n      if (node.arguments.length !== 1) {\r\n        this.raise(node.start, \"import() requires exactly one argument\");\r\n      }\r\n\r\n      const importArg = node.arguments[0];\r\n      if (importArg && importArg.type === \"SpreadElement\") {\r\n        this.raise(importArg.start, \"... is not allowed in import()\");\r\n      }\r\n    }\r\n    return this.finishNode(node, \"OptionalCallExpression\");\r\n  }\r\n\r\n  parseCallExpressionArguments(\r\n    close: TokenType,\r\n    possibleAsyncArrow: boolean,\r\n    dynamicImport?: boolean,\r\n    allowPlaceholder?: boolean,\r\n  ): $ReadOnlyArray<?N.Expression> {\r\n    const elts = [];\r\n    let innerParenStart;\r\n    let first = true;\r\n\r\n    while (!this.eat(close)) {\r\n      if (first) {\r\n        first = false;\r\n      } else {\r\n        this.expect(tt.comma);\r\n        if (this.eat(close)) {\r\n          if (dynamicImport) {\r\n            this.raise(\r\n              this.state.lastTokStart,\r\n              \"Trailing comma is disallowed inside import(...) arguments\",\r\n            );\r\n          }\r\n          break;\r\n        }\r\n      }\r\n\r\n      // we need to make sure that if this is an async arrow functions,\r\n      // that we don't allow inner parens inside the params\r\n      if (this.match(tt.parenL) && !innerParenStart) {\r\n        innerParenStart = this.state.start;\r\n      }\r\n\r\n      elts.push(\r\n        this.parseExprListItem(\r\n          false,\r\n          possibleAsyncArrow ? { start: 0 } : undefined,\r\n          possibleAsyncArrow ? { start: 0 } : undefined,\r\n          allowPlaceholder,\r\n        ),\r\n      );\r\n    }\r\n\r\n    // we found an async arrow function so let's not allow any inner parens\r\n    if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {\r\n      this.unexpected();\r\n    }\r\n\r\n    return elts;\r\n  }\r\n\r\n  shouldParseAsyncArrow(): boolean {\r\n    return this.match(tt.arrow) && !this.canInsertSemicolon();\r\n  }\r\n\r\n  parseAsyncArrowFromCallExpression(\r\n    node: N.ArrowFunctionExpression,\r\n    call: N.CallExpression,\r\n  ): N.ArrowFunctionExpression {\r\n    this.expect(tt.arrow);\r\n    this.parseArrowExpression(node, call.arguments, true);\r\n    return node;\r\n  }\r\n\r\n  // Parse a no-call expression (like argument of `new` or `::` operators).\r\n\r\n  parseNoCallExpr(): N.Expression {\r\n    const startPos = this.state.start;\r\n    const startLoc = this.state.startLoc;\r\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\r\n  }\r\n\r\n  // Parse an atomic expression — either a single token that is an\r\n  // expression, an expression started by a keyword like `function` or\r\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\r\n  // or `{}`.\r\n\r\n  parseExprAtom(refShorthandDefaultPos?: ?Pos): N.Expression {\r\n    // If a division operator appears in an expression position, the\r\n    // tokenizer got confused, and we force it to read a regexp instead.\r\n    if (this.state.type === tt.slash) this.readRegexp();\r\n\r\n    const canBeArrow = this.state.potentialArrowAt === this.state.start;\r\n    let node;\r\n\r\n    switch (this.state.type) {\r\n      case tt._super:\r\n        if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\r\n          this.raise(\r\n            this.state.start,\r\n            \"super is only allowed in object methods and classes\",\r\n          );\r\n        }\r\n\r\n        node = this.startNode();\r\n        this.next();\r\n        if (\r\n          this.match(tt.parenL) &&\r\n          !this.scope.allowDirectSuper &&\r\n          !this.options.allowSuperOutsideMethod\r\n        ) {\r\n          this.raise(\r\n            node.start,\r\n            \"super() is only valid inside a class constructor of a subclass. \" +\r\n              \"Maybe a typo in the method name ('constructor') or not extending another class?\",\r\n          );\r\n        }\r\n\r\n        if (\r\n          !this.match(tt.parenL) &&\r\n          !this.match(tt.bracketL) &&\r\n          !this.match(tt.dot)\r\n        ) {\r\n          this.unexpected();\r\n        }\r\n\r\n        return this.finishNode(node, \"Super\");\r\n\r\n      case tt._import:\r\n        node = this.startNode();\r\n        this.next();\r\n\r\n        if (this.match(tt.dot)) {\r\n          return this.parseImportMetaProperty(node);\r\n        }\r\n\r\n        this.expectPlugin(\"dynamicImport\", node.start);\r\n\r\n        if (!this.match(tt.parenL)) {\r\n          this.unexpected(null, tt.parenL);\r\n        }\r\n        return this.finishNode(node, \"Import\");\r\n      case tt._this:\r\n        node = this.startNode();\r\n        this.next();\r\n        return this.finishNode(node, \"ThisExpression\");\r\n\r\n      case tt.name: {\r\n        node = this.startNode();\r\n        const containsEsc = this.state.containsEsc;\r\n        const id = this.parseIdentifier();\r\n\r\n        if (\r\n          !containsEsc &&\r\n          id.name === \"غير_متزامن\" &&\r\n          this.match(tt._function) &&\r\n          !this.canInsertSemicolon()\r\n        ) {\r\n          this.next();\r\n          return this.parseFunction(node, undefined, true);\r\n        } else if (\r\n          canBeArrow &&\r\n          !containsEsc &&\r\n          id.name === \"غير_متزامن\" &&\r\n          this.match(tt.name) &&\r\n          !this.canInsertSemicolon()\r\n        ) {\r\n          const params = [this.parseIdentifier()];\r\n          this.expect(tt.arrow);\r\n          // let foo = async bar => {};\r\n          this.parseArrowExpression(node, params, true);\r\n          return node;\r\n        }\r\n\r\n        if (canBeArrow && this.match(tt.arrow) && !this.canInsertSemicolon()) {\r\n          this.next();\r\n          this.parseArrowExpression(node, [id], false);\r\n          return node;\r\n        }\r\n\r\n        return id;\r\n      }\r\n\r\n      case tt._do: {\r\n        this.expectPlugin(\"doExpressions\");\r\n        const node = this.startNode();\r\n        this.next();\r\n        const oldLabels = this.state.labels;\r\n        this.state.labels = [];\r\n        node.body = this.parseBlock();\r\n        this.state.labels = oldLabels;\r\n        return this.finishNode(node, \"DoExpression\");\r\n      }\r\n\r\n      case tt.regexp: {\r\n        const value = this.state.value;\r\n        node = this.parseLiteral(value.value, \"RegExpLiteral\");\r\n        node.pattern = value.pattern;\r\n        node.flags = value.flags;\r\n        return node;\r\n      }\r\n\r\n      case tt.num:\r\n        return this.parseLiteral(this.state.value, \"NumericLiteral\");\r\n\r\n      case tt.bigint:\r\n        return this.parseLiteral(this.state.value, \"BigIntLiteral\");\r\n\r\n      case tt.string:\r\n        return this.parseLiteral(this.state.value, \"StringLiteral\");\r\n\r\n      case tt._null:\r\n        node = this.startNode();\r\n        this.next();\r\n        return this.finishNode(node, \"NullLiteral\");\r\n\r\n      case tt._true:\r\n      case tt._false:\r\n        return this.parseBooleanLiteral();\r\n\r\n      case tt.parenL:\r\n        return this.parseParenAndDistinguishExpression(canBeArrow);\r\n\r\n      case tt.bracketL:\r\n        node = this.startNode();\r\n        this.next();\r\n        node.elements = this.parseExprList(\r\n          tt.bracketR,\r\n          true,\r\n          refShorthandDefaultPos,\r\n        );\r\n        if (!this.state.maybeInArrowParameters) {\r\n          // This could be an array pattern:\r\n          //   ([a: string, b: string]) => {}\r\n          // In this case, we don't have to call toReferencedList. We will\r\n          // call it, if needed, when we are sure that it is a parenthesized\r\n          // expression by calling toReferencedListDeep.\r\n          this.toReferencedList(node.elements);\r\n        }\r\n        return this.finishNode(node, \"ArrayExpression\");\r\n\r\n      case tt.braceL:\r\n        return this.parseObj(false, refShorthandDefaultPos);\r\n\r\n      case tt._function:\r\n        return this.parseFunctionExpression();\r\n\r\n      case tt.at:\r\n        this.parseDecorators();\r\n\r\n      case tt._class:\r\n        node = this.startNode();\r\n        this.takeDecorators(node);\r\n        return this.parseClass(node, false);\r\n\r\n      case tt._new:\r\n        return this.parseNew();\r\n\r\n      case tt.backQuote:\r\n        return this.parseTemplate(false);\r\n\r\n      case tt.doubleColon: {\r\n        node = this.startNode();\r\n        this.next();\r\n        node.object = null;\r\n        const callee = (node.callee = this.parseNoCallExpr());\r\n        if (callee.type === \"MemberExpression\") {\r\n          return this.finishNode(node, \"BindExpression\");\r\n        } else {\r\n          throw this.raise(\r\n            callee.start,\r\n            \"Binding should be performed on object property.\",\r\n          );\r\n        }\r\n      }\r\n\r\n      case tt.hash: {\r\n        if (this.state.inPipeline) {\r\n          node = this.startNode();\r\n\r\n          if (\r\n            this.getPluginOption(\"pipelineOperator\", \"proposal\") !== \"smart\"\r\n          ) {\r\n            this.raise(\r\n              node.start,\r\n              \"Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.\",\r\n            );\r\n          }\r\n\r\n          this.next();\r\n          if (this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {\r\n            this.registerTopicReference();\r\n            return this.finishNode(node, \"PipelinePrimaryTopicReference\");\r\n          } else {\r\n            throw this.raise(\r\n              node.start,\r\n              `Topic reference was used in a lexical context without topic binding`,\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      default:\r\n        throw this.unexpected();\r\n    }\r\n  }\r\n\r\n  parseBooleanLiteral(): N.BooleanLiteral {\r\n    const node = this.startNode();\r\n    node.value = this.match(tt._true);\r\n    this.next();\r\n    return this.finishNode(node, \"BooleanLiteral\");\r\n  }\r\n\r\n  parseMaybePrivateName(): N.PrivateName | N.Identifier {\r\n    const isPrivate = this.match(tt.hash);\r\n\r\n    if (isPrivate) {\r\n      this.expectOnePlugin([\"classPrivateProperties\", \"classPrivateMethods\"]);\r\n      const node = this.startNode();\r\n      this.next();\r\n      this.assertNoSpace(\"Unexpected space between # and identifier\");\r\n      node.id = this.parseIdentifier(true);\r\n      return this.finishNode(node, \"PrivateName\");\r\n    } else {\r\n      return this.parseIdentifier(true);\r\n    }\r\n  }\r\n\r\n  parseFunctionExpression(): N.FunctionExpression | N.MetaProperty {\r\n    const node = this.startNode();\r\n\r\n    // We do not do parseIdentifier here because when parseFunctionExpression\r\n    // is called we already know that the current token is a \"name\" with the value \"مهمة\"\r\n    // This will improve perf a tiny little bit as we do not do validation but more importantly\r\n    // here is that parseIdentifier will remove an item from the expression stack\r\n    // if \"مهمة\" or \"class\" is parsed as identifier (in objects e.g.), which should not happen here.\r\n    let meta = this.startNode();\r\n    this.next();\r\n    meta = this.createIdentifier(meta, \"مهمة\");\r\n\r\n    if (this.scope.inGenerator && this.eat(tt.dot)) {\r\n      return this.parseMetaProperty(node, meta, \"sent\");\r\n    }\r\n    return this.parseFunction(node);\r\n  }\r\n\r\n  parseMetaProperty(\r\n    node: N.MetaProperty,\r\n    meta: N.Identifier,\r\n    propertyName: string,\r\n  ): N.MetaProperty {\r\n    node.meta = meta;\r\n\r\n    if (meta.name === \"مهمة\" && propertyName === \"sent\") {\r\n      if (this.isContextual(propertyName)) {\r\n        this.expectPlugin(\"functionSent\");\r\n      } else if (!this.hasPlugin(\"functionSent\")) {\r\n        // The code wasn't `function.sent` but just `function.`, so a simple error is less confusing.\r\n        this.unexpected();\r\n      }\r\n    }\r\n\r\n    const containsEsc = this.state.containsEsc;\r\n\r\n    node.property = this.parseIdentifier(true);\r\n\r\n    if (node.property.name !== propertyName || containsEsc) {\r\n      this.raise(\r\n        node.property.start,\r\n        `The only valid meta property for ${meta.name} is ${\r\n          meta.name\r\n        }.${propertyName}`,\r\n      );\r\n    }\r\n\r\n    return this.finishNode(node, \"MetaProperty\");\r\n  }\r\n\r\n  parseImportMetaProperty(node: N.MetaProperty): N.MetaProperty {\r\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\r\n    this.expect(tt.dot);\r\n\r\n    if (this.isContextual(\"meta\")) {\r\n      this.expectPlugin(\"importMeta\");\r\n    } else if (!this.hasPlugin(\"importMeta\")) {\r\n      this.raise(\r\n        id.start,\r\n        `Dynamic imports require a parameter: import('a.js')`,\r\n      );\r\n    }\r\n\r\n    if (!this.inModule) {\r\n      this.raise(\r\n        id.start,\r\n        `import.meta may appear only with 'sourceType: \"module\"'`,\r\n        { code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\" },\r\n      );\r\n    }\r\n    this.sawUnambiguousESM = true;\r\n\r\n    return this.parseMetaProperty(node, id, \"meta\");\r\n  }\r\n\r\n  parseLiteral<T: N.Literal>(\r\n    value: any,\r\n    type: /*T[\"kind\"]*/ string,\r\n    startPos?: number,\r\n    startLoc?: Position,\r\n  ): T {\r\n    startPos = startPos || this.state.start;\r\n    startLoc = startLoc || this.state.startLoc;\r\n\r\n    const node = this.startNodeAt(startPos, startLoc);\r\n    this.addExtra(node, \"rawValue\", value);\r\n    this.addExtra(node, \"raw\", this.input.slice(startPos, this.state.end));\r\n    node.value = value;\r\n    this.next();\r\n    return this.finishNode(node, type);\r\n  }\r\n\r\n  parseParenAndDistinguishExpression(canBeArrow: boolean): N.Expression {\r\n    const startPos = this.state.start;\r\n    const startLoc = this.state.startLoc;\r\n\r\n    let val;\r\n    this.expect(tt.parenL);\r\n\r\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\r\n    const oldYieldPos = this.state.yieldPos;\r\n    const oldAwaitPos = this.state.awaitPos;\r\n    this.state.maybeInArrowParameters = true;\r\n    this.state.yieldPos = 0;\r\n    this.state.awaitPos = 0;\r\n\r\n    const innerStartPos = this.state.start;\r\n    const innerStartLoc = this.state.startLoc;\r\n    const exprList = [];\r\n    const refShorthandDefaultPos = { start: 0 };\r\n    const refNeedsArrowPos = { start: 0 };\r\n    let first = true;\r\n    let spreadStart;\r\n    let optionalCommaStart;\r\n\r\n    while (!this.match(tt.parenR)) {\r\n      if (first) {\r\n        first = false;\r\n      } else {\r\n        this.expect(tt.comma, refNeedsArrowPos.start || null);\r\n        if (this.match(tt.parenR)) {\r\n          optionalCommaStart = this.state.start;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (this.match(tt.ellipsis)) {\r\n        const spreadNodeStartPos = this.state.start;\r\n        const spreadNodeStartLoc = this.state.startLoc;\r\n        spreadStart = this.state.start;\r\n        exprList.push(\r\n          this.parseParenItem(\r\n            this.parseRestBinding(),\r\n            spreadNodeStartPos,\r\n            spreadNodeStartLoc,\r\n          ),\r\n        );\r\n\r\n        this.checkCommaAfterRest();\r\n\r\n        break;\r\n      } else {\r\n        exprList.push(\r\n          this.parseMaybeAssign(\r\n            false,\r\n            refShorthandDefaultPos,\r\n            this.parseParenItem,\r\n            refNeedsArrowPos,\r\n          ),\r\n        );\r\n      }\r\n    }\r\n\r\n    const innerEndPos = this.state.start;\r\n    const innerEndLoc = this.state.startLoc;\r\n    this.expect(tt.parenR);\r\n\r\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\r\n\r\n    let arrowNode = this.startNodeAt(startPos, startLoc);\r\n    if (\r\n      canBeArrow &&\r\n      this.shouldParseArrow() &&\r\n      (arrowNode = this.parseArrow(arrowNode))\r\n    ) {\r\n      this.checkYieldAwaitInDefaultParams();\r\n      this.state.yieldPos = oldYieldPos;\r\n      this.state.awaitPos = oldAwaitPos;\r\n      for (const param of exprList) {\r\n        if (param.extra && param.extra.parenthesized) {\r\n          this.unexpected(param.extra.parenStart);\r\n        }\r\n      }\r\n\r\n      this.parseArrowExpression(arrowNode, exprList, false);\r\n      return arrowNode;\r\n    }\r\n\r\n    // We keep the old value if it isn't null, for cases like\r\n    //   (x = (yield)) => {}\r\n    this.state.yieldPos = oldYieldPos || this.state.yieldPos;\r\n    this.state.awaitPos = oldAwaitPos || this.state.awaitPos;\r\n\r\n    if (!exprList.length) {\r\n      this.unexpected(this.state.lastTokStart);\r\n    }\r\n    if (optionalCommaStart) this.unexpected(optionalCommaStart);\r\n    if (spreadStart) this.unexpected(spreadStart);\r\n    if (refShorthandDefaultPos.start) {\r\n      this.unexpected(refShorthandDefaultPos.start);\r\n    }\r\n    if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);\r\n\r\n    this.toReferencedListDeep(exprList, /* isParenthesizedExpr */ true);\r\n    if (exprList.length > 1) {\r\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\r\n      val.expressions = exprList;\r\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\r\n    } else {\r\n      val = exprList[0];\r\n    }\r\n\r\n    if (!this.options.createParenthesizedExpressions) {\r\n      this.addExtra(val, \"parenthesized\", true);\r\n      this.addExtra(val, \"parenStart\", startPos);\r\n      return val;\r\n    }\r\n\r\n    const parenExpression = this.startNodeAt(startPos, startLoc);\r\n    parenExpression.expression = val;\r\n    this.finishNode(parenExpression, \"ParenthesizedExpression\");\r\n    return parenExpression;\r\n  }\r\n\r\n  shouldParseArrow(): boolean {\r\n    return !this.canInsertSemicolon();\r\n  }\r\n\r\n  parseArrow(node: N.ArrowFunctionExpression): ?N.ArrowFunctionExpression {\r\n    if (this.eat(tt.arrow)) {\r\n      return node;\r\n    }\r\n  }\r\n\r\n  parseParenItem(\r\n    node: N.Expression,\r\n    startPos: number, // eslint-disable-line no-unused-vars\r\n    startLoc: Position, // eslint-disable-line no-unused-vars\r\n  ): N.Expression {\r\n    return node;\r\n  }\r\n\r\n  // New's precedence is slightly tricky. It must allow its argument to\r\n  // be a `[]` or dot subscript expression, but not a call — at least,\r\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\r\n  // argument to parseSubscripts to prevent it from consuming the\r\n  // argument list.\r\n\r\n  parseNew(): N.NewExpression | N.MetaProperty {\r\n    const node = this.startNode();\r\n    const meta = this.parseIdentifier(true);\r\n\r\n    if (this.eat(tt.dot)) {\r\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\r\n\r\n      if (!this.scope.inNonArrowFunction && !this.state.inClassProperty) {\r\n        let error = \"new.target can only be used in functions\";\r\n\r\n        if (this.hasPlugin(\"classProperties\")) {\r\n          error += \" or class properties\";\r\n        }\r\n\r\n        this.raise(metaProp.start, error);\r\n      }\r\n\r\n      return metaProp;\r\n    }\r\n\r\n    node.callee = this.parseNoCallExpr();\r\n\r\n    if (node.callee.type === \"Import\") {\r\n      this.raise(node.callee.start, \"Cannot use new with import(...)\");\r\n    } else if (\r\n      node.callee.type === \"OptionalMemberExpression\" ||\r\n      node.callee.type === \"OptionalCallExpression\"\r\n    ) {\r\n      this.raise(\r\n        this.state.lastTokEnd,\r\n        \"constructors in/after an Optional Chain are not allowed\",\r\n      );\r\n    } else if (this.eat(tt.questionDot)) {\r\n      this.raise(\r\n        this.state.start,\r\n        \"constructors in/after an Optional Chain are not allowed\",\r\n      );\r\n    }\r\n\r\n    this.parseNewArguments(node);\r\n    return this.finishNode(node, \"NewExpression\");\r\n  }\r\n\r\n  parseNewArguments(node: N.NewExpression): void {\r\n    if (this.eat(tt.parenL)) {\r\n      const args = this.parseExprList(tt.parenR);\r\n      this.toReferencedList(args);\r\n      // $FlowFixMe (parseExprList should be all non-null in this case)\r\n      node.arguments = args;\r\n    } else {\r\n      node.arguments = [];\r\n    }\r\n  }\r\n\r\n  // Parse template expression.\r\n\r\n  parseTemplateElement(isTagged: boolean): N.TemplateElement {\r\n    const elem = this.startNode();\r\n    if (this.state.value === null) {\r\n      if (!isTagged) {\r\n        // TODO: fix this\r\n        this.raise(\r\n          this.state.invalidTemplateEscapePosition || 0,\r\n          \"Invalid escape sequence in template\",\r\n        );\r\n      } else {\r\n        this.state.invalidTemplateEscapePosition = null;\r\n      }\r\n    }\r\n    elem.value = {\r\n      raw: this.input\r\n        .slice(this.state.start, this.state.end)\r\n        .replace(/\\r\\n?/g, \"\\n\"),\r\n      cooked: this.state.value,\r\n    };\r\n    this.next();\r\n    elem.tail = this.match(tt.backQuote);\r\n    return this.finishNode(elem, \"TemplateElement\");\r\n  }\r\n\r\n  parseTemplate(isTagged: boolean): N.TemplateLiteral {\r\n    const node = this.startNode();\r\n    this.next();\r\n    node.expressions = [];\r\n    let curElt = this.parseTemplateElement(isTagged);\r\n    node.quasis = [curElt];\r\n    while (!curElt.tail) {\r\n      this.expect(tt.dollarBraceL);\r\n      node.expressions.push(this.parseExpression());\r\n      this.expect(tt.braceR);\r\n      node.quasis.push((curElt = this.parseTemplateElement(isTagged)));\r\n    }\r\n    this.next();\r\n    return this.finishNode(node, \"TemplateLiteral\");\r\n  }\r\n\r\n  // Parse an object literal or binding pattern.\r\n\r\n  parseObj<T: N.ObjectPattern | N.ObjectExpression>(\r\n    isPattern: boolean,\r\n    refShorthandDefaultPos?: ?Pos,\r\n  ): T {\r\n    const propHash: any = Object.create(null);\r\n    let first = true;\r\n    const node = this.startNode();\r\n\r\n    node.properties = [];\r\n    this.next();\r\n\r\n    while (!this.eat(tt.braceR)) {\r\n      if (first) {\r\n        first = false;\r\n      } else {\r\n        this.expect(tt.comma);\r\n        if (this.eat(tt.braceR)) break;\r\n      }\r\n\r\n      const prop = this.parseObjectMember(isPattern, refShorthandDefaultPos);\r\n      // $FlowIgnore RestElement will never be returned if !isPattern\r\n      if (!isPattern) this.checkPropClash(prop, propHash);\r\n\r\n      // $FlowIgnore\r\n      if (prop.shorthand) {\r\n        this.addExtra(prop, \"shorthand\", true);\r\n      }\r\n\r\n      node.properties.push(prop);\r\n    }\r\n\r\n    return this.finishNode(\r\n      node,\r\n      isPattern ? \"ObjectPattern\" : \"ObjectExpression\",\r\n    );\r\n  }\r\n\r\n  isAsyncProp(prop: N.ObjectProperty): boolean {\r\n    return (\r\n      !prop.computed &&\r\n      prop.key.type === \"Identifier\" &&\r\n      prop.key.name === \"غير_متزامن\" &&\r\n      (this.match(tt.name) ||\r\n        this.match(tt.num) ||\r\n        this.match(tt.string) ||\r\n        this.match(tt.bracketL) ||\r\n        this.state.type.keyword ||\r\n        this.match(tt.star)) &&\r\n      !this.hasPrecedingLineBreak()\r\n    );\r\n  }\r\n\r\n  parseObjectMember(\r\n    isPattern: boolean,\r\n    refShorthandDefaultPos: ?Pos,\r\n  ): N.ObjectMember | N.SpreadElement | N.RestElement {\r\n    let decorators = [];\r\n    if (this.match(tt.at)) {\r\n      if (this.hasPlugin(\"decorators\")) {\r\n        this.raise(\r\n          this.state.start,\r\n          \"Stage 2 decorators disallow object literal property decorators\",\r\n        );\r\n      } else {\r\n        // we needn't check if decorators (stage 0) plugin is enabled since it's checked by\r\n        // the call to this.parseDecorator\r\n        while (this.match(tt.at)) {\r\n          decorators.push(this.parseDecorator());\r\n        }\r\n      }\r\n    }\r\n\r\n    const prop = this.startNode();\r\n    let isGenerator = false;\r\n    let isAsync = false;\r\n    let startPos;\r\n    let startLoc;\r\n\r\n    if (this.match(tt.ellipsis)) {\r\n      if (decorators.length) this.unexpected();\r\n      if (isPattern) {\r\n        this.next();\r\n        // Don't use parseRestBinding() as we only allow Identifier here.\r\n        prop.argument = this.parseIdentifier();\r\n        this.checkCommaAfterRest();\r\n        return this.finishNode(prop, \"RestElement\");\r\n      }\r\n\r\n      return this.parseSpread();\r\n    }\r\n\r\n    if (decorators.length) {\r\n      prop.decorators = decorators;\r\n      decorators = [];\r\n    }\r\n\r\n    prop.method = false;\r\n\r\n    if (isPattern || refShorthandDefaultPos) {\r\n      startPos = this.state.start;\r\n      startLoc = this.state.startLoc;\r\n    }\r\n\r\n    if (!isPattern) {\r\n      isGenerator = this.eat(tt.star);\r\n    }\r\n\r\n    const containsEsc = this.state.containsEsc;\r\n    this.parsePropertyName(prop);\r\n\r\n    if (!isPattern && !containsEsc && !isGenerator && this.isAsyncProp(prop)) {\r\n      isAsync = true;\r\n      isGenerator = this.eat(tt.star);\r\n      this.parsePropertyName(prop);\r\n    } else {\r\n      isAsync = false;\r\n    }\r\n\r\n    this.parseObjPropValue(\r\n      prop,\r\n      startPos,\r\n      startLoc,\r\n      isGenerator,\r\n      isAsync,\r\n      isPattern,\r\n      refShorthandDefaultPos,\r\n      containsEsc,\r\n    );\r\n\r\n    return prop;\r\n  }\r\n\r\n  isGetterOrSetterMethod(prop: N.ObjectMethod, isPattern: boolean): boolean {\r\n    return (\r\n      !isPattern &&\r\n      !prop.computed &&\r\n      prop.key.type === \"Identifier\" &&\r\n      (prop.key.name === \"get\" || prop.key.name === \"set\") &&\r\n      (this.match(tt.string) || // get \"string\"() {}\r\n      this.match(tt.num) || // get 1() {}\r\n      this.match(tt.bracketL) || // get [\"string\"]() {}\r\n      this.match(tt.name) || // get foo() {}\r\n        !!this.state.type.keyword) // get debugger() {}\r\n    );\r\n  }\r\n\r\n  getGetterSetterExpectedParamCount(\r\n    method: N.ObjectMethod | N.ClassMethod,\r\n  ): number {\r\n    return method.kind === \"get\" ? 0 : 1;\r\n  }\r\n\r\n  // get methods aren't allowed to have any parameters\r\n  // set methods must have exactly 1 parameter which is not a rest parameter\r\n  checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\r\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\r\n    const start = method.start;\r\n    if (method.params.length !== paramCount) {\r\n      if (method.kind === \"get\") {\r\n        this.raise(start, \"getter must not have any formal parameters\");\r\n      } else {\r\n        this.raise(start, \"setter must have exactly one formal parameter\");\r\n      }\r\n    }\r\n\r\n    if (\r\n      method.kind === \"set\" &&\r\n      method.params[method.params.length - 1].type === \"RestElement\"\r\n    ) {\r\n      this.raise(\r\n        start,\r\n        \"setter function argument must not be a rest parameter\",\r\n      );\r\n    }\r\n  }\r\n\r\n  parseObjectMethod(\r\n    prop: N.ObjectMethod,\r\n    isGenerator: boolean,\r\n    isAsync: boolean,\r\n    isPattern: boolean,\r\n    containsEsc: boolean,\r\n  ): ?N.ObjectMethod {\r\n    if (isAsync || isGenerator || this.match(tt.parenL)) {\r\n      if (isPattern) this.unexpected();\r\n      prop.kind = \"method\";\r\n      prop.method = true;\r\n      return this.parseMethod(\r\n        prop,\r\n        isGenerator,\r\n        isAsync,\r\n        /* isConstructor */ false,\r\n        false,\r\n        \"ObjectMethod\",\r\n      );\r\n    }\r\n\r\n    if (!containsEsc && this.isGetterOrSetterMethod(prop, isPattern)) {\r\n      if (isGenerator || isAsync) this.unexpected();\r\n      prop.kind = prop.key.name;\r\n      this.parsePropertyName(prop);\r\n      this.parseMethod(\r\n        prop,\r\n        /* isGenerator */ false,\r\n        /* isAsync */ false,\r\n        /* isConstructor */ false,\r\n        false,\r\n        \"ObjectMethod\",\r\n      );\r\n      this.checkGetterSetterParams(prop);\r\n      return prop;\r\n    }\r\n  }\r\n\r\n  parseObjectProperty(\r\n    prop: N.ObjectProperty,\r\n    startPos: ?number,\r\n    startLoc: ?Position,\r\n    isPattern: boolean,\r\n    refShorthandDefaultPos: ?Pos,\r\n  ): ?N.ObjectProperty {\r\n    prop.shorthand = false;\r\n\r\n    if (this.eat(tt.colon)) {\r\n      prop.value = isPattern\r\n        ? this.parseMaybeDefault(this.state.start, this.state.startLoc)\r\n        : this.parseMaybeAssign(false, refShorthandDefaultPos);\r\n\r\n      return this.finishNode(prop, \"ObjectProperty\");\r\n    }\r\n\r\n    if (!prop.computed && prop.key.type === \"Identifier\") {\r\n      this.checkReservedWord(prop.key.name, prop.key.start, true, true);\r\n\r\n      if (isPattern) {\r\n        prop.value = this.parseMaybeDefault(\r\n          startPos,\r\n          startLoc,\r\n          prop.key.__clone(),\r\n        );\r\n      } else if (this.match(tt.eq) && refShorthandDefaultPos) {\r\n        if (!refShorthandDefaultPos.start) {\r\n          refShorthandDefaultPos.start = this.state.start;\r\n        }\r\n        prop.value = this.parseMaybeDefault(\r\n          startPos,\r\n          startLoc,\r\n          prop.key.__clone(),\r\n        );\r\n      } else {\r\n        prop.value = prop.key.__clone();\r\n      }\r\n      prop.shorthand = true;\r\n\r\n      return this.finishNode(prop, \"ObjectProperty\");\r\n    }\r\n  }\r\n\r\n  parseObjPropValue(\r\n    prop: any,\r\n    startPos: ?number,\r\n    startLoc: ?Position,\r\n    isGenerator: boolean,\r\n    isAsync: boolean,\r\n    isPattern: boolean,\r\n    refShorthandDefaultPos: ?Pos,\r\n    containsEsc: boolean,\r\n  ): void {\r\n    const node =\r\n      this.parseObjectMethod(\r\n        prop,\r\n        isGenerator,\r\n        isAsync,\r\n        isPattern,\r\n        containsEsc,\r\n      ) ||\r\n      this.parseObjectProperty(\r\n        prop,\r\n        startPos,\r\n        startLoc,\r\n        isPattern,\r\n        refShorthandDefaultPos,\r\n      );\r\n\r\n    if (!node) this.unexpected();\r\n\r\n    // $FlowFixMe\r\n    return node;\r\n  }\r\n\r\n  parsePropertyName(\r\n    prop: N.ObjectOrClassMember | N.ClassMember | N.TsNamedTypeElementBase,\r\n  ): N.Expression | N.Identifier {\r\n    if (this.eat(tt.bracketL)) {\r\n      (prop: $FlowSubtype<N.ObjectOrClassMember>).computed = true;\r\n      prop.key = this.parseMaybeAssign();\r\n      this.expect(tt.bracketR);\r\n    } else {\r\n      const oldInPropertyName = this.state.inPropertyName;\r\n      this.state.inPropertyName = true;\r\n      // We check if it's valid for it to be a private name when we push it.\r\n      (prop: $FlowFixMe).key =\r\n        this.match(tt.num) || this.match(tt.string)\r\n          ? this.parseExprAtom()\r\n          : this.parseMaybePrivateName();\r\n\r\n      if (prop.key.type !== \"PrivateName\") {\r\n        // ClassPrivateProperty is never computed, so we don't assign in that case.\r\n        prop.computed = false;\r\n      }\r\n\r\n      this.state.inPropertyName = oldInPropertyName;\r\n    }\r\n\r\n    return prop.key;\r\n  }\r\n\r\n  // Initialize empty function node.\r\n\r\n  initFunction(node: N.BodilessFunctionOrMethodBase, isAsync: ?boolean): void {\r\n    node.id = null;\r\n    node.generator = false;\r\n    node.async = !!isAsync;\r\n  }\r\n\r\n  // Parse object or class method.\r\n\r\n  parseMethod<T: N.MethodLike>(\r\n    node: T,\r\n    isGenerator: boolean,\r\n    isAsync: boolean,\r\n    isConstructor: boolean,\r\n    allowDirectSuper: boolean,\r\n    type: string,\r\n    inClassScope: boolean = false,\r\n  ): T {\r\n    const oldYieldPos = this.state.yieldPos;\r\n    const oldAwaitPos = this.state.awaitPos;\r\n    this.state.yieldPos = 0;\r\n    this.state.awaitPos = 0;\r\n\r\n    this.initFunction(node, isAsync);\r\n    node.generator = !!isGenerator;\r\n    const allowModifiers = isConstructor; // For TypeScript parameter properties\r\n    this.scope.enter(\r\n      functionFlags(isAsync, node.generator) |\r\n        SCOPE_SUPER |\r\n        (inClassScope ? SCOPE_CLASS : 0) |\r\n        (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0),\r\n    );\r\n    this.parseFunctionParams((node: any), allowModifiers);\r\n    this.checkYieldAwaitInDefaultParams();\r\n    this.parseFunctionBodyAndFinish(node, type, true);\r\n    this.scope.exit();\r\n\r\n    this.state.yieldPos = oldYieldPos;\r\n    this.state.awaitPos = oldAwaitPos;\r\n\r\n    return node;\r\n  }\r\n\r\n  // Parse arrow function expression.\r\n  // If the parameters are provided, they will be converted to an\r\n  // assignable list.\r\n  parseArrowExpression(\r\n    node: N.ArrowFunctionExpression,\r\n    params: ?(N.Expression[]),\r\n    isAsync: boolean,\r\n  ): N.ArrowFunctionExpression {\r\n    this.scope.enter(functionFlags(isAsync, false) | SCOPE_ARROW);\r\n    this.initFunction(node, isAsync);\r\n\r\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\r\n    const oldYieldPos = this.state.yieldPos;\r\n    const oldAwaitPos = this.state.awaitPos;\r\n    this.state.maybeInArrowParameters = false;\r\n    this.state.yieldPos = 0;\r\n    this.state.awaitPos = 0;\r\n\r\n    if (params) this.setArrowFunctionParameters(node, params);\r\n    this.parseFunctionBody(node, true);\r\n\r\n    this.scope.exit();\r\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\r\n    this.state.yieldPos = oldYieldPos;\r\n    this.state.awaitPos = oldAwaitPos;\r\n\r\n    return this.finishNode(node, \"ArrowFunctionExpression\");\r\n  }\r\n\r\n  setArrowFunctionParameters(\r\n    node: N.ArrowFunctionExpression,\r\n    params: N.Expression[],\r\n  ): void {\r\n    node.params = this.toAssignableList(\r\n      params,\r\n      true,\r\n      \"arrow function parameters\",\r\n    );\r\n  }\r\n\r\n  isStrictBody(node: { body: N.BlockStatement }): boolean {\r\n    const isBlockStatement = node.body.type === \"BlockStatement\";\r\n\r\n    if (isBlockStatement && node.body.directives.length) {\r\n      for (const directive of node.body.directives) {\r\n        if (directive.value.value === \"use strict\") {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  parseFunctionBodyAndFinish(\r\n    node: N.BodilessFunctionOrMethodBase,\r\n    type: string,\r\n    isMethod?: boolean = false,\r\n  ): void {\r\n    // $FlowIgnore (node is not bodiless if we get here)\r\n    this.parseFunctionBody(node, false, isMethod);\r\n    this.finishNode(node, type);\r\n  }\r\n\r\n  // Parse function body and check parameters.\r\n  parseFunctionBody(\r\n    node: N.Function,\r\n    allowExpression: ?boolean,\r\n    isMethod?: boolean = false,\r\n  ): void {\r\n    const isExpression = allowExpression && !this.match(tt.braceL);\r\n    const oldStrict = this.state.strict;\r\n    let useStrict = false;\r\n\r\n    const oldInParameters = this.state.inParameters;\r\n    this.state.inParameters = false;\r\n\r\n    if (isExpression) {\r\n      node.body = this.parseMaybeAssign();\r\n      this.checkParams(node, false, allowExpression);\r\n    } else {\r\n      const nonSimple = !this.isSimpleParamList(node.params);\r\n      if (!oldStrict || nonSimple) {\r\n        useStrict = this.strictDirective(this.state.end);\r\n        // If this is a strict mode function, verify that argument names\r\n        // are not repeated, and it does not try to bind the words `eval`\r\n        // or `arguments`.\r\n        if (useStrict && nonSimple) {\r\n          // This logic is here to align the error location with the estree plugin\r\n          const errorPos =\r\n            // $FlowIgnore\r\n            (node.kind === \"method\" || node.kind === \"constructor\") &&\r\n            // $FlowIgnore\r\n            !!node.key\r\n              ? node.key.end\r\n              : node.start;\r\n          this.raise(\r\n            errorPos,\r\n            \"Illegal 'use strict' directive in function with non-simple parameter list\",\r\n          );\r\n        }\r\n      }\r\n      // Start a new scope with regard to labels\r\n      // flag (restore them to their old value afterwards).\r\n      const oldLabels = this.state.labels;\r\n      this.state.labels = [];\r\n      if (useStrict) this.state.strict = true;\r\n      // Add the params to varDeclaredNames to ensure that an error is thrown\r\n      // if a let/const declaration in the function clashes with one of the params.\r\n      this.checkParams(\r\n        node,\r\n        !oldStrict && !useStrict && !allowExpression && !isMethod && !nonSimple,\r\n        allowExpression,\r\n      );\r\n      node.body = this.parseBlock(true, false);\r\n      this.state.labels = oldLabels;\r\n    }\r\n\r\n    this.state.inParameters = oldInParameters;\r\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\r\n    if (this.state.strict && node.id) {\r\n      this.checkLVal(node.id, BIND_OUTSIDE, undefined, \"function name\");\r\n    }\r\n    this.state.strict = oldStrict;\r\n  }\r\n\r\n  isSimpleParamList(\r\n    params: $ReadOnlyArray<N.Pattern | N.TSParameterProperty>,\r\n  ): boolean {\r\n    for (let i = 0, len = params.length; i < len; i++) {\r\n      if (params[i].type !== \"Identifier\") return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  checkParams(\r\n    node: N.Function,\r\n    allowDuplicates: boolean,\r\n    // eslint-disable-next-line no-unused-vars\r\n    isArrowFunction: ?boolean,\r\n  ): void {\r\n    // $FlowIssue\r\n    const nameHash: {} = Object.create(null);\r\n    for (let i = 0; i < node.params.length; i++) {\r\n      this.checkLVal(\r\n        node.params[i],\r\n        BIND_VAR,\r\n        allowDuplicates ? null : nameHash,\r\n        \"function paramter list\",\r\n      );\r\n    }\r\n  }\r\n\r\n  // Parses a comma-separated list of expressions, and returns them as\r\n  // an array. `close` is the token type that ends the list, and\r\n  // `allowEmpty` can be turned on to allow subsequent commas with\r\n  // nothing in between them to be parsed as `null` (which is needed\r\n  // for array literals).\r\n\r\n  parseExprList(\r\n    close: TokenType,\r\n    allowEmpty?: boolean,\r\n    refShorthandDefaultPos?: ?Pos,\r\n  ): $ReadOnlyArray<?N.Expression> {\r\n    const elts = [];\r\n    let first = true;\r\n\r\n    while (!this.eat(close)) {\r\n      if (first) {\r\n        first = false;\r\n      } else {\r\n        this.expect(tt.comma);\r\n        if (this.eat(close)) break;\r\n      }\r\n\r\n      elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));\r\n    }\r\n    return elts;\r\n  }\r\n\r\n  parseExprListItem(\r\n    allowEmpty: ?boolean,\r\n    refShorthandDefaultPos: ?Pos,\r\n    refNeedsArrowPos: ?Pos,\r\n    allowPlaceholder: ?boolean,\r\n  ): ?N.Expression {\r\n    let elt;\r\n    if (allowEmpty && this.match(tt.comma)) {\r\n      elt = null;\r\n    } else if (this.match(tt.ellipsis)) {\r\n      const spreadNodeStartPos = this.state.start;\r\n      const spreadNodeStartLoc = this.state.startLoc;\r\n      elt = this.parseParenItem(\r\n        this.parseSpread(refShorthandDefaultPos, refNeedsArrowPos),\r\n        spreadNodeStartPos,\r\n        spreadNodeStartLoc,\r\n      );\r\n    } else if (this.match(tt.question)) {\r\n      this.expectPlugin(\"partialApplication\");\r\n      if (!allowPlaceholder) {\r\n        this.raise(this.state.start, \"Unexpected argument placeholder\");\r\n      }\r\n      const node = this.startNode();\r\n      this.next();\r\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\r\n    } else {\r\n      elt = this.parseMaybeAssign(\r\n        false,\r\n        refShorthandDefaultPos,\r\n        this.parseParenItem,\r\n        refNeedsArrowPos,\r\n      );\r\n    }\r\n    return elt;\r\n  }\r\n\r\n  // Parse the next token as an identifier. If `liberal` is true (used\r\n  // when parsing properties), it will also convert keywords into\r\n  // identifiers.\r\n\r\n  parseIdentifier(liberal?: boolean): N.Identifier {\r\n    const node = this.startNode();\r\n    const name = this.parseIdentifierName(node.start, liberal);\r\n\r\n    return this.createIdentifier(node, name);\r\n  }\r\n\r\n  createIdentifier(node: N.Identifier, name: string): N.Identifier {\r\n    node.name = name;\r\n    node.loc.identifierName = name;\r\n\r\n    return this.finishNode(node, \"Identifier\");\r\n  }\r\n\r\n  parseIdentifierName(pos: number, liberal?: boolean): string {\r\n    let name: string;\r\n\r\n    if (this.match(tt.name)) {\r\n      name = this.state.value;\r\n    } else if (this.state.type.keyword) {\r\n      name = this.state.type.keyword;\r\n\r\n      // `class` and `function` keywords push new context into this.context.\r\n      // But there is no chance to pop the context if the keyword is consumed\r\n      // as an identifier such as a property name.\r\n      // If the previous token is a dot, this does not apply because the\r\n      // context-managing code already ignored the keyword\r\n      if (\r\n        (name === \"class\" || name === \"مهمة\") &&\r\n        (this.state.lastTokEnd !== this.state.lastTokStart + 1 ||\r\n          this.input.charCodeAt(this.state.lastTokStart) !== charCodes.dot)\r\n      ) {\r\n        this.state.context.pop();\r\n      }\r\n    } else {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    if (!liberal) {\r\n      this.checkReservedWord(\r\n        name,\r\n        this.state.start,\r\n        !!this.state.type.keyword,\r\n        false,\r\n      );\r\n    }\r\n\r\n    this.next();\r\n\r\n    return name;\r\n  }\r\n\r\n  checkReservedWord(\r\n    word: string,\r\n    startLoc: number,\r\n    checkKeywords: boolean,\r\n    isBinding: boolean,\r\n  ): void {\r\n    if (this.scope.inGenerator && word === \"yield\") {\r\n      this.raise(\r\n        startLoc,\r\n        \"Can not use 'yield' as identifier inside a generator\",\r\n      );\r\n    }\r\n\r\n    if (this.scope.inAsync && word === \"انتظر\") {\r\n      this.raise(\r\n        startLoc,\r\n        \"Can not use 'await' as identifier inside an async function\",\r\n      );\r\n    }\r\n\r\n    if (this.state.inClassProperty && word === \"arguments\") {\r\n      this.raise(\r\n        startLoc,\r\n        \"'arguments' is not allowed in class field initializer\",\r\n      );\r\n    }\r\n    if (checkKeywords && isKeyword(word)) {\r\n      this.raise(startLoc, `Unexpected keyword '${word}'`);\r\n    }\r\n\r\n    const reservedTest = !this.state.strict\r\n      ? isReservedWord\r\n      : isBinding\r\n      ? isStrictBindReservedWord\r\n      : isStrictReservedWord;\r\n\r\n    if (reservedTest(word, this.inModule)) {\r\n      if (!this.scope.inAsync && word === \"انتظر\") {\r\n        this.raise(\r\n          startLoc,\r\n          \"Can not use keyword 'await' outside an async function\",\r\n        );\r\n      }\r\n      this.raise(startLoc, `Unexpected reserved word '${word}'`);\r\n    }\r\n  }\r\n\r\n  // Parses await expression inside async function.\r\n\r\n  parseAwait(): N.AwaitExpression {\r\n    if (!this.state.awaitPos) {\r\n      this.state.awaitPos = this.state.start;\r\n    }\r\n    const node = this.startNode();\r\n\r\n    this.next();\r\n\r\n    if (this.state.inParameters) {\r\n      this.raise(\r\n        node.start,\r\n        \"await is not allowed in async function parameters\",\r\n      );\r\n    }\r\n    if (this.match(tt.star)) {\r\n      this.raise(\r\n        node.start,\r\n        \"await* has been removed from the async functions proposal. Use Promise.all() instead.\",\r\n      );\r\n    }\r\n\r\n    node.argument = this.parseMaybeUnary();\r\n    return this.finishNode(node, \"AwaitExpression\");\r\n  }\r\n\r\n  // Parses yield expression inside generator.\r\n\r\n  parseYield(noIn?: ?boolean): N.YieldExpression {\r\n    if (!this.state.yieldPos) {\r\n      this.state.yieldPos = this.state.start;\r\n    }\r\n    const node = this.startNode();\r\n\r\n    if (this.state.inParameters) {\r\n      this.raise(node.start, \"yield is not allowed in generator parameters\");\r\n    }\r\n\r\n    this.next();\r\n    if (\r\n      this.match(tt.semi) ||\r\n      (!this.match(tt.star) && !this.state.type.startsExpr) ||\r\n      this.canInsertSemicolon()\r\n    ) {\r\n      node.delegate = false;\r\n      node.argument = null;\r\n    } else {\r\n      node.delegate = this.eat(tt.star);\r\n      node.argument = this.parseMaybeAssign(noIn);\r\n    }\r\n    return this.finishNode(node, \"YieldExpression\");\r\n  }\r\n\r\n  // Validates a pipeline (for any of the pipeline Babylon plugins) at the point\r\n  // of the infix operator `|>`.\r\n\r\n  checkPipelineAtInfixOperator(left: N.Expression, leftStartPos: number) {\r\n    if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\r\n      if (left.type === \"SequenceExpression\") {\r\n        // Ensure that the pipeline head is not a comma-delimited\r\n        // sequence expression.\r\n        throw this.raise(\r\n          leftStartPos,\r\n          `Pipeline head should not be a comma-separated sequence expression`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  parseSmartPipelineBody(\r\n    childExpression: N.Expression,\r\n    startPos: number,\r\n    startLoc: Position,\r\n  ): N.PipelineBody {\r\n    const pipelineStyle = this.checkSmartPipelineBodyStyle(childExpression);\r\n\r\n    this.checkSmartPipelineBodyEarlyErrors(\r\n      childExpression,\r\n      pipelineStyle,\r\n      startPos,\r\n    );\r\n\r\n    return this.parseSmartPipelineBodyInStyle(\r\n      childExpression,\r\n      pipelineStyle,\r\n      startPos,\r\n      startLoc,\r\n    );\r\n  }\r\n\r\n  checkSmartPipelineBodyEarlyErrors(\r\n    childExpression: N.Expression,\r\n    pipelineStyle: N.PipelineStyle,\r\n    startPos: number,\r\n  ): void {\r\n    if (this.match(tt.arrow)) {\r\n      // If the following token is invalidly `=>`, then throw a human-friendly error\r\n      // instead of something like 'Unexpected token, expected \";\"'.\r\n      throw this.raise(\r\n        this.state.start,\r\n        `Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized`,\r\n      );\r\n    } else if (\r\n      pipelineStyle === \"PipelineTopicExpression\" &&\r\n      childExpression.type === \"SequenceExpression\"\r\n    ) {\r\n      throw this.raise(\r\n        startPos,\r\n        `Pipeline body may not be a comma-separated sequence expression`,\r\n      );\r\n    }\r\n  }\r\n\r\n  parseSmartPipelineBodyInStyle(\r\n    childExpression: N.Expression,\r\n    pipelineStyle: N.PipelineStyle,\r\n    startPos: number,\r\n    startLoc: Position,\r\n  ): N.PipelineBody {\r\n    const bodyNode = this.startNodeAt(startPos, startLoc);\r\n    switch (pipelineStyle) {\r\n      case \"PipelineBareFunction\":\r\n        bodyNode.callee = childExpression;\r\n        break;\r\n      case \"PipelineBareConstructor\":\r\n        bodyNode.callee = childExpression.callee;\r\n        break;\r\n      case \"PipelineBareAwaitedFunction\":\r\n        bodyNode.callee = childExpression.argument;\r\n        break;\r\n      case \"PipelineTopicExpression\":\r\n        if (!this.topicReferenceWasUsedInCurrentTopicContext()) {\r\n          throw this.raise(\r\n            startPos,\r\n            `Pipeline is in topic style but does not use topic reference`,\r\n          );\r\n        }\r\n        bodyNode.expression = childExpression;\r\n        break;\r\n      default:\r\n        throw this.raise(startPos, `Unknown pipeline style ${pipelineStyle}`);\r\n    }\r\n    return this.finishNode(bodyNode, pipelineStyle);\r\n  }\r\n\r\n  checkSmartPipelineBodyStyle(expression: N.Expression): N.PipelineStyle {\r\n    switch (expression.type) {\r\n      default:\r\n        return this.isSimpleReference(expression)\r\n          ? \"PipelineBareFunction\"\r\n          : \"PipelineTopicExpression\";\r\n    }\r\n  }\r\n\r\n  isSimpleReference(expression: N.Expression): boolean {\r\n    switch (expression.type) {\r\n      case \"MemberExpression\":\r\n        return (\r\n          !expression.computed && this.isSimpleReference(expression.object)\r\n        );\r\n      case \"Identifier\":\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  // Enable topic references from outer contexts within smart pipeline bodies.\r\n  // The function modifies the parser's topic-context state to enable or disable\r\n  // the use of topic references with the smartPipelines plugin. They then run a\r\n  // callback, then they reset the parser to the old topic-context state that it\r\n  // had before the function was called.\r\n\r\n  withTopicPermittingContext<T>(callback: () => T): T {\r\n    const outerContextTopicState = this.state.topicContext;\r\n    this.state.topicContext = {\r\n      // Enable the use of the primary topic reference.\r\n      maxNumOfResolvableTopics: 1,\r\n      // Hide the use of any topic references from outer contexts.\r\n      maxTopicIndex: null,\r\n    };\r\n\r\n    try {\r\n      return callback();\r\n    } finally {\r\n      this.state.topicContext = outerContextTopicState;\r\n    }\r\n  }\r\n\r\n  // Disable topic references from outer contexts within syntax constructs\r\n  // such as the bodies of iteration statements.\r\n  // The function modifies the parser's topic-context state to enable or disable\r\n  // the use of topic references with the smartPipelines plugin. They then run a\r\n  // callback, then they reset the parser to the old topic-context state that it\r\n  // had before the function was called.\r\n\r\n  withTopicForbiddingContext<T>(callback: () => T): T {\r\n    const outerContextTopicState = this.state.topicContext;\r\n    this.state.topicContext = {\r\n      // Disable the use of the primary topic reference.\r\n      maxNumOfResolvableTopics: 0,\r\n      // Hide the use of any topic references from outer contexts.\r\n      maxTopicIndex: null,\r\n    };\r\n\r\n    try {\r\n      return callback();\r\n    } finally {\r\n      this.state.topicContext = outerContextTopicState;\r\n    }\r\n  }\r\n\r\n  // Register the use of a primary topic reference (`#`) within the current\r\n  // topic context.\r\n  registerTopicReference(): void {\r\n    this.state.topicContext.maxTopicIndex = 0;\r\n  }\r\n\r\n  primaryTopicReferenceIsAllowedInCurrentTopicContext(): boolean {\r\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\r\n  }\r\n\r\n  topicReferenceWasUsedInCurrentTopicContext(): boolean {\r\n    return (\r\n      this.state.topicContext.maxTopicIndex != null &&\r\n      this.state.topicContext.maxTopicIndex >= 0\r\n    );\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport * as N from \"../types\";\r\nimport { types as tt, type TokenType } from \"../tokenizer/types\";\r\nimport ExpressionParser from \"./expression\";\r\nimport {\r\n  isIdentifierChar,\r\n  isIdentifierStart,\r\n  keywordRelationalOperator,\r\n} from \"../util/identifier\";\r\nimport { lineBreak, skipWhiteSpace } from \"../util/whitespace\";\r\nimport * as charCodes from \"charcodes\";\r\nimport * as arabic from \"../arabic\";\r\nimport {\r\n  BIND_CLASS,\r\n  BIND_LEXICAL,\r\n  BIND_VAR,\r\n  BIND_FUNCTION,\r\n  functionFlags,\r\n  SCOPE_CLASS,\r\n  SCOPE_OTHER,\r\n  SCOPE_SIMPLE_CATCH,\r\n  SCOPE_SUPER,\r\n} from \"../util/scopeflags\";\r\n\r\nconst loopLabel = { kind: \"loop\" },\r\n  switchLabel = { kind: \"switch\" };\r\n\r\nconst FUNC_NO_FLAGS = 0b000,\r\n  FUNC_STATEMENT = 0b001,\r\n  FUNC_HANGING_STATEMENT = 0b010,\r\n  FUNC_NULLABLE_ID = 0b100;\r\n\r\nexport default class StatementParser extends ExpressionParser {\r\n  // ### Statement parsing\r\n\r\n  // Parse a program. Initializes the parser, reads any number of\r\n  // statements, and wraps them in a Program node.  Optionally takes a\r\n  // `program` argument.  If present, the statements will be appended\r\n  // to its body instead of creating a new node.\r\n\r\n  parseTopLevel(file: N.File, program: N.Program): N.File {\r\n    program.sourceType = this.options.sourceType;\r\n\r\n    program.interpreter = this.parseInterpreterDirective();\r\n\r\n    this.parseBlockBody(program, true, true, tt.eof);\r\n\r\n    if (this.inModule && this.scope.undefinedExports.size > 0) {\r\n      for (const [name] of Array.from(this.scope.undefinedExports)) {\r\n        const pos = this.scope.undefinedExports.get(name);\r\n        // $FlowIssue\r\n        this.raise(pos, `Export '${name}' is not defined`);\r\n      }\r\n    }\r\n\r\n    file.program = this.finishNode(program, \"Program\");\r\n    file.comments = this.state.comments;\r\n\r\n    if (this.options.tokens) file.tokens = this.state.tokens;\r\n\r\n    return this.finishNode(file, \"File\");\r\n  }\r\n\r\n  // TODO\r\n\r\n  stmtToDirective(stmt: N.Statement): N.Directive {\r\n    const expr = stmt.expression;\r\n\r\n    const directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);\r\n    const directive = this.startNodeAt(stmt.start, stmt.loc.start);\r\n\r\n    const raw = this.input.slice(expr.start, expr.end);\r\n    const val = (directiveLiteral.value = raw.slice(1, -1)); // remove quotes\r\n\r\n    this.addExtra(directiveLiteral, \"raw\", raw);\r\n    this.addExtra(directiveLiteral, \"rawValue\", val);\r\n\r\n    directive.value = this.finishNodeAt(\r\n      directiveLiteral,\r\n      \"DirectiveLiteral\",\r\n      expr.end,\r\n      expr.loc.end,\r\n    );\r\n\r\n    return this.finishNodeAt(directive, \"Directive\", stmt.end, stmt.loc.end);\r\n  }\r\n\r\n  parseInterpreterDirective(): N.InterpreterDirective | null {\r\n    if (!this.match(tt.interpreterDirective)) {\r\n      return null;\r\n    }\r\n\r\n    const node = this.startNode();\r\n    node.value = this.state.value;\r\n    this.next();\r\n    return this.finishNode(node, \"InterpreterDirective\");\r\n  }\r\n\r\n  isLet(context: ?string): boolean {\r\n    if (!this.isContextual(\"let\")) {\r\n      return false;\r\n    }\r\n    skipWhiteSpace.lastIndex = this.state.pos;\r\n    const skip = skipWhiteSpace.exec(this.input);\r\n    // $FlowIgnore\r\n    const next = this.state.pos + skip[0].length;\r\n    const nextCh = this.input.charCodeAt(next);\r\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\r\n    // Statement) is allowed here. If context is not empty then only a Statement\r\n    // is allowed. However, `let [` is an explicit negative lookahead for\r\n    // ExpressionStatement, so special-case it first.\r\n    if (nextCh === charCodes.leftSquareBracket) return true;\r\n    if (context) return false;\r\n\r\n    if (nextCh === charCodes.leftCurlyBrace) return true;\r\n\r\n    if (isIdentifierStart(nextCh)) {\r\n      let pos = next + 1;\r\n      while (isIdentifierChar(this.input.charCodeAt(pos))) {\r\n        ++pos;\r\n      }\r\n      const ident = this.input.slice(next, pos);\r\n      if (!keywordRelationalOperator.test(ident)) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Parse a single statement.\r\n  //\r\n  // If expecting a statement and finding a slash operator, parse a\r\n  // regular expression literal. This is to handle cases like\r\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\r\n  // does not help.\r\n\r\n  parseStatement(context: ?string, topLevel?: boolean): N.Statement {\r\n    if (this.match(tt.at)) {\r\n      this.parseDecorators(true);\r\n    }\r\n    return this.parseStatementContent(context, topLevel);\r\n  }\r\n\r\n  parseStatementContent(context: ?string, topLevel: ?boolean): N.Statement {\r\n    let starttype = this.state.type;\r\n    const node = this.startNode();\r\n    let kind;\r\n\r\n    if (this.isLet(context)) {\r\n      starttype = tt._var;\r\n      kind = \"let\";\r\n    }\r\n\r\n    // Most types of statements are recognized by the keyword they\r\n    // start with. Many are trivial to parse, some require a bit of\r\n    // complexity.\r\n\r\n    switch (starttype) {\r\n      case tt._break:\r\n      case tt._continue:\r\n        // $FlowFixMe\r\n        return this.parseBreakContinueStatement(node, starttype.keyword);\r\n      case tt._debugger:\r\n        return this.parseDebuggerStatement(node);\r\n      case tt._do:\r\n        return this.parseDoStatement(node);\r\n      case tt._for:\r\n        return this.parseForStatement(node);\r\n      case tt._function:\r\n        if (this.lookahead().type === tt.dot) break;\r\n        if (context) {\r\n          if (this.state.strict) {\r\n            this.raise(\r\n              this.state.start,\r\n              \"In strict mode code, functions can only be declared at top level or inside a block\",\r\n            );\r\n          } else if (context !== \"if\" && context !== \"label\") {\r\n            this.raise(\r\n              this.state.start,\r\n              \"In non-strict mode code, functions can only be declared at top level, \" +\r\n                \"inside a block, or as the body of an if statement\",\r\n            );\r\n          }\r\n        }\r\n        return this.parseFunctionStatement(node, false, !context);\r\n\r\n      case tt._class:\r\n        if (context) this.unexpected();\r\n        return this.parseClass(node, true);\r\n\r\n      case tt._if:\r\n        return this.parseIfStatement(node);\r\n      case tt._return:\r\n        return this.parseReturnStatement(node);\r\n      case tt._switch:\r\n        return this.parseSwitchStatement(node);\r\n      case tt._throw:\r\n        return this.parseThrowStatement(node);\r\n      case tt._try:\r\n        return this.parseTryStatement(node);\r\n\r\n      case tt._const:\r\n      case tt._var:\r\n        kind = kind || this.state.value;\r\n        if (context && kind !== \"var\") {\r\n          this.unexpected(\r\n            this.state.start,\r\n            \"Lexical declaration cannot appear in a single-statement context\",\r\n          );\r\n        }\r\n        return this.parseVarStatement(node, kind);\r\n\r\n      case tt._while:\r\n        return this.parseWhileStatement(node);\r\n      case tt._with:\r\n        return this.parseWithStatement(node);\r\n      case tt.braceL:\r\n        return this.parseBlock();\r\n      case tt.semi:\r\n        return this.parseEmptyStatement(node);\r\n      case tt._export:\r\n      case tt._import: {\r\n        const nextToken = this.lookahead();\r\n        if (nextToken.type === tt.parenL || nextToken.type === tt.dot) {\r\n          break;\r\n        }\r\n\r\n        if (!this.options.allowImportExportEverywhere && !topLevel) {\r\n          this.raise(\r\n            this.state.start,\r\n            \"'import' and 'export' may only appear at the top level\",\r\n          );\r\n        }\r\n\r\n        this.next();\r\n\r\n        let result;\r\n        if (starttype === tt._import) {\r\n          result = this.parseImport(node);\r\n\r\n          if (\r\n            result.type === \"ImportDeclaration\" &&\r\n            (!result.importKind || result.importKind === \"value\")\r\n          ) {\r\n            this.sawUnambiguousESM = true;\r\n          }\r\n        } else {\r\n          result = this.parseExport(node);\r\n\r\n          if (\r\n            (result.type === \"ExportNamedDeclaration\" &&\r\n              (!result.exportKind || result.exportKind === \"value\")) ||\r\n            (result.type === \"ExportAllDeclaration\" &&\r\n              (!result.exportKind || result.exportKind === \"value\")) ||\r\n            result.type === \"ExportDefaultDeclaration\"\r\n          ) {\r\n            this.sawUnambiguousESM = true;\r\n          }\r\n        }\r\n\r\n        this.assertModuleNodeAllowed(node);\r\n\r\n        return result;\r\n      }\r\n\r\n      default: {\r\n        if (this.isAsyncFunction()) {\r\n          if (context) {\r\n            this.unexpected(\r\n              null,\r\n              \"Async functions can only be declared at the top level or inside a block\",\r\n            );\r\n          }\r\n          this.next();\r\n          return this.parseFunctionStatement(node, true, !context);\r\n        }\r\n      }\r\n    }\r\n\r\n    // If the statement does not start with a statement keyword or a\r\n    // brace, it's an ExpressionStatement or LabeledStatement. We\r\n    // simply start parsing an expression, and afterwards, if the\r\n    // next token is a colon and the expression was a simple\r\n    // Identifier node, we switch to interpreting it as a label.\r\n    const maybeName = this.state.value;\r\n    const expr = this.parseExpression();\r\n\r\n    if (\r\n      starttype === tt.name &&\r\n      expr.type === \"Identifier\" &&\r\n      this.eat(tt.colon)\r\n    ) {\r\n      return this.parseLabeledStatement(node, maybeName, expr, context);\r\n    } else {\r\n      return this.parseExpressionStatement(node, expr);\r\n    }\r\n  }\r\n\r\n  assertModuleNodeAllowed(node: N.Node): void {\r\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\r\n      this.raise(\r\n        node.start,\r\n        `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\r\n        {\r\n          code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\",\r\n        },\r\n      );\r\n    }\r\n  }\r\n\r\n  takeDecorators(node: N.HasDecorators): void {\r\n    const decorators = this.state.decoratorStack[\r\n      this.state.decoratorStack.length - 1\r\n    ];\r\n    if (decorators.length) {\r\n      node.decorators = decorators;\r\n      this.resetStartLocationFromNode(node, decorators[0]);\r\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\r\n    }\r\n  }\r\n\r\n  canHaveLeadingDecorator(): boolean {\r\n    return this.match(tt._class);\r\n  }\r\n\r\n  parseDecorators(allowExport?: boolean): void {\r\n    const currentContextDecorators = this.state.decoratorStack[\r\n      this.state.decoratorStack.length - 1\r\n    ];\r\n    while (this.match(tt.at)) {\r\n      const decorator = this.parseDecorator();\r\n      currentContextDecorators.push(decorator);\r\n    }\r\n\r\n    if (this.match(tt._export)) {\r\n      if (!allowExport) {\r\n        this.unexpected();\r\n      }\r\n\r\n      if (\r\n        this.hasPlugin(\"decorators\") &&\r\n        !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")\r\n      ) {\r\n        this.raise(\r\n          this.state.start,\r\n          \"Using the export keyword between a decorator and a class is not allowed. \" +\r\n            \"Please use `export @dec class` instead.\",\r\n        );\r\n      }\r\n    } else if (!this.canHaveLeadingDecorator()) {\r\n      this.raise(\r\n        this.state.start,\r\n        \"Leading decorators must be attached to a class declaration\",\r\n      );\r\n    }\r\n  }\r\n\r\n  parseDecorator(): N.Decorator {\r\n    this.expectOnePlugin([\"decorators-legacy\", \"decorators\"]);\r\n\r\n    const node = this.startNode();\r\n    this.next();\r\n\r\n    if (this.hasPlugin(\"decorators\")) {\r\n      // Every time a decorator class expression is evaluated, a new empty array is pushed onto the stack\r\n      // So that the decorators of any nested class expressions will be dealt with separately\r\n      this.state.decoratorStack.push([]);\r\n\r\n      const startPos = this.state.start;\r\n      const startLoc = this.state.startLoc;\r\n      let expr: N.Expression;\r\n\r\n      if (this.eat(tt.parenL)) {\r\n        expr = this.parseExpression();\r\n        this.expect(tt.parenR);\r\n      } else {\r\n        expr = this.parseIdentifier(false);\r\n\r\n        while (this.eat(tt.dot)) {\r\n          const node = this.startNodeAt(startPos, startLoc);\r\n          node.object = expr;\r\n          node.property = this.parseIdentifier(true);\r\n          node.computed = false;\r\n          expr = this.finishNode(node, \"MemberExpression\");\r\n        }\r\n      }\r\n\r\n      node.expression = this.parseMaybeDecoratorArguments(expr);\r\n      this.state.decoratorStack.pop();\r\n    } else {\r\n      node.expression = this.parseMaybeAssign();\r\n    }\r\n    return this.finishNode(node, \"Decorator\");\r\n  }\r\n\r\n  parseMaybeDecoratorArguments(expr: N.Expression): N.Expression {\r\n    if (this.eat(tt.parenL)) {\r\n      const node = this.startNodeAtNode(expr);\r\n      node.callee = expr;\r\n      node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\r\n      this.toReferencedList(node.arguments);\r\n      return this.finishNode(node, \"CallExpression\");\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n  parseBreakContinueStatement(\r\n    node: N.BreakStatement | N.ContinueStatement,\r\n    keyword: string,\r\n  ): N.BreakStatement | N.ContinueStatement {\r\n    const isBreak = keyword === arabic.breakKeyword;\r\n    this.next();\r\n\r\n    if (this.isLineTerminator()) {\r\n      node.label = null;\r\n    } else {\r\n      node.label = this.parseIdentifier();\r\n      this.semicolon();\r\n    }\r\n\r\n    this.verifyBreakContinue(node, keyword);\r\n\r\n    return this.finishNode(\r\n      node,\r\n      isBreak ? \"BreakStatement\" : \"ContinueStatement\",\r\n    );\r\n  }\r\n\r\n  verifyBreakContinue(\r\n    node: N.BreakStatement | N.ContinueStatement,\r\n    keyword: string,\r\n  ) {\r\n    const isBreak = keyword === arabic.breakKeyword;\r\n    let i;\r\n    for (i = 0; i < this.state.labels.length; ++i) {\r\n      const lab = this.state.labels[i];\r\n      if (node.label == null || lab.name === node.label.name) {\r\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\r\n        if (node.label && isBreak) break;\r\n      }\r\n    }\r\n    if (i === this.state.labels.length) {\r\n      this.raise(node.start, \"Unsyntactic \" + keyword);\r\n    }\r\n  }\r\n\r\n  parseDebuggerStatement(node: N.DebuggerStatement): N.DebuggerStatement {\r\n    this.next();\r\n    this.semicolon();\r\n    return this.finishNode(node, \"DebuggerStatement\");\r\n  }\r\n\r\n  parseHeaderExpression(): N.Expression {\r\n    this.expect(tt.parenL);\r\n    const val = this.parseExpression();\r\n    this.expect(tt.parenR);\r\n    return val;\r\n  }\r\n\r\n  parseDoStatement(node: N.DoWhileStatement): N.DoWhileStatement {\r\n    this.next();\r\n    this.state.labels.push(loopLabel);\r\n\r\n    node.body =\r\n      // For the smartPipelines plugin: Disable topic references from outer\r\n      // contexts within the loop body. They are permitted in test expressions,\r\n      // outside of the loop body.\r\n      this.withTopicForbiddingContext(() =>\r\n        // Parse the loop body's body.\r\n        this.parseStatement(\"do\"),\r\n      );\r\n\r\n    this.state.labels.pop();\r\n\r\n    this.expect(tt._while);\r\n    node.test = this.parseHeaderExpression();\r\n    this.eat(tt.semi);\r\n    return this.finishNode(node, \"DoWhileStatement\");\r\n  }\r\n\r\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\r\n  // loop is non-trivial. Basically, we have to parse the init `var`\r\n  // statement or expression, disallowing the `in` operator (see\r\n  // the second parameter to `parseExpression`), and then check\r\n  // whether the next token is `in` or `of`. When there is no init\r\n  // part (semicolon immediately after the opening parenthesis), it\r\n  // is a regular `for` loop.\r\n\r\n  parseForStatement(node: N.Node): N.ForLike {\r\n    this.next();\r\n    this.state.labels.push(loopLabel);\r\n\r\n    let awaitAt = -1;\r\n    if (\r\n      (this.scope.inAsync ||\r\n        (!this.scope.inFunction && this.options.allowAwaitOutsideFunction)) &&\r\n      this.eatContextual(\"انتظر\")\r\n    ) {\r\n      awaitAt = this.state.lastTokStart;\r\n    }\r\n    this.scope.enter(SCOPE_OTHER);\r\n    this.expect(tt.parenL);\r\n\r\n    if (this.match(tt.semi)) {\r\n      if (awaitAt > -1) {\r\n        this.unexpected(awaitAt);\r\n      }\r\n      return this.parseFor(node, null);\r\n    }\r\n\r\n    const isLet = this.isLet();\r\n    if (this.match(tt._var) || this.match(tt._const) || isLet) {\r\n      const init = this.startNode();\r\n      const kind = isLet ? \"let\" : this.state.value;\r\n      this.next();\r\n      this.parseVar(init, true, kind);\r\n      this.finishNode(init, \"VariableDeclaration\");\r\n\r\n      if (\r\n        (this.match(tt._in) || this.isContextual(\"of\")) &&\r\n        init.declarations.length === 1\r\n      ) {\r\n        return this.parseForIn(node, init, awaitAt);\r\n      }\r\n      if (awaitAt > -1) {\r\n        this.unexpected(awaitAt);\r\n      }\r\n      return this.parseFor(node, init);\r\n    }\r\n\r\n    const refShorthandDefaultPos = { start: 0 };\r\n    const init = this.parseExpression(true, refShorthandDefaultPos);\r\n    if (this.match(tt._in) || this.isContextual(\"of\")) {\r\n      const description = this.isContextual(\"of\")\r\n        ? \"for-of statement\"\r\n        : \"for-in statement\";\r\n      this.toAssignable(init, undefined, description);\r\n      this.checkLVal(init, undefined, undefined, description);\r\n      return this.parseForIn(node, init, awaitAt);\r\n    } else if (refShorthandDefaultPos.start) {\r\n      this.unexpected(refShorthandDefaultPos.start);\r\n    }\r\n    if (awaitAt > -1) {\r\n      this.unexpected(awaitAt);\r\n    }\r\n    return this.parseFor(node, init);\r\n  }\r\n\r\n  parseFunctionStatement(\r\n    node: N.FunctionDeclaration,\r\n    isAsync?: boolean,\r\n    declarationPosition?: boolean,\r\n  ): N.FunctionDeclaration {\r\n    this.next();\r\n    return this.parseFunction(\r\n      node,\r\n      FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT),\r\n      isAsync,\r\n    );\r\n  }\r\n\r\n  parseIfStatement(node: N.IfStatement): N.IfStatement {\r\n    this.next();\r\n    node.test = this.parseHeaderExpression();\r\n    node.consequent = this.parseStatement(\"if\");\r\n    node.alternate = this.eat(tt._else) ? this.parseStatement(\"if\") : null;\r\n    return this.finishNode(node, \"IfStatement\");\r\n  }\r\n\r\n  parseReturnStatement(node: N.ReturnStatement): N.ReturnStatement {\r\n    if (!this.scope.inFunction && !this.options.allowReturnOutsideFunction) {\r\n      this.raise(this.state.start, \"'return' outside of function\");\r\n    }\r\n\r\n    this.next();\r\n\r\n    // In `return` (and `break`/`continue`), the keywords with\r\n    // optional arguments, we eagerly look for a semicolon or the\r\n    // possibility to insert one.\r\n\r\n    if (this.isLineTerminator()) {\r\n      node.argument = null;\r\n    } else {\r\n      node.argument = this.parseExpression();\r\n      this.semicolon();\r\n    }\r\n\r\n    return this.finishNode(node, \"ReturnStatement\");\r\n  }\r\n\r\n  parseSwitchStatement(node: N.SwitchStatement): N.SwitchStatement {\r\n    this.next();\r\n    node.discriminant = this.parseHeaderExpression();\r\n    const cases = (node.cases = []);\r\n    this.expect(tt.braceL);\r\n    this.state.labels.push(switchLabel);\r\n    this.scope.enter(SCOPE_OTHER);\r\n\r\n    // Statements under must be grouped (by label) in SwitchCase\r\n    // nodes. `cur` is used to keep the node that we are currently\r\n    // adding statements to.\r\n\r\n    let cur;\r\n    for (let sawDefault; !this.match(tt.braceR); ) {\r\n      if (this.match(tt._case) || this.match(tt._default)) {\r\n        const isCase = this.match(tt._case);\r\n        if (cur) this.finishNode(cur, \"SwitchCase\");\r\n        cases.push((cur = this.startNode()));\r\n        cur.consequent = [];\r\n        this.next();\r\n        if (isCase) {\r\n          cur.test = this.parseExpression();\r\n        } else {\r\n          if (sawDefault) {\r\n            this.raise(this.state.lastTokStart, \"Multiple default clauses\");\r\n          }\r\n          sawDefault = true;\r\n          cur.test = null;\r\n        }\r\n        this.expect(tt.colon);\r\n      } else {\r\n        if (cur) {\r\n          cur.consequent.push(this.parseStatement(null));\r\n        } else {\r\n          this.unexpected();\r\n        }\r\n      }\r\n    }\r\n    this.scope.exit();\r\n    if (cur) this.finishNode(cur, \"SwitchCase\");\r\n    this.next(); // Closing brace\r\n    this.state.labels.pop();\r\n    return this.finishNode(node, \"SwitchStatement\");\r\n  }\r\n\r\n  parseThrowStatement(node: N.ThrowStatement): N.ThrowStatement {\r\n    this.next();\r\n    if (\r\n      lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))\r\n    ) {\r\n      this.raise(this.state.lastTokEnd, \"Illegal newline after throw\");\r\n    }\r\n    node.argument = this.parseExpression();\r\n    this.semicolon();\r\n    return this.finishNode(node, \"ThrowStatement\");\r\n  }\r\n\r\n  parseTryStatement(node: N.TryStatement): N.TryStatement {\r\n    this.next();\r\n\r\n    node.block = this.parseBlock();\r\n    node.handler = null;\r\n\r\n    if (this.match(tt._catch)) {\r\n      const clause = this.startNode();\r\n      this.next();\r\n      if (this.match(tt.parenL)) {\r\n        this.expect(tt.parenL);\r\n        clause.param = this.parseBindingAtom();\r\n        const simple = clause.param.type === \"Identifier\";\r\n        this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\r\n        this.checkLVal(clause.param, BIND_LEXICAL, null, \"catch clause\");\r\n        this.expect(tt.parenR);\r\n      } else {\r\n        clause.param = null;\r\n        this.scope.enter(SCOPE_OTHER);\r\n      }\r\n\r\n      clause.body =\r\n        // For the smartPipelines plugin: Disable topic references from outer\r\n        // contexts within the function body. They are permitted in function\r\n        // default-parameter expressions, which are part of the outer context,\r\n        // outside of the function body.\r\n        this.withTopicForbiddingContext(() =>\r\n          // Parse the catch clause's body.\r\n          this.parseBlock(false, false),\r\n        );\r\n      this.scope.exit();\r\n\r\n      node.handler = this.finishNode(clause, \"CatchClause\");\r\n    }\r\n\r\n    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;\r\n\r\n    if (!node.handler && !node.finalizer) {\r\n      this.raise(node.start, \"Missing catch or finally clause\");\r\n    }\r\n\r\n    return this.finishNode(node, \"TryStatement\");\r\n  }\r\n\r\n  parseVarStatement(\r\n    node: N.VariableDeclaration,\r\n    kind: \"var\" | \"let\" | \"const\",\r\n  ): N.VariableDeclaration {\r\n    this.next();\r\n    this.parseVar(node, false, kind);\r\n    this.semicolon();\r\n    return this.finishNode(node, \"VariableDeclaration\");\r\n  }\r\n\r\n  parseWhileStatement(node: N.WhileStatement): N.WhileStatement {\r\n    this.next();\r\n    node.test = this.parseHeaderExpression();\r\n    this.state.labels.push(loopLabel);\r\n\r\n    node.body =\r\n      // For the smartPipelines plugin:\r\n      // Disable topic references from outer contexts within the loop body.\r\n      // They are permitted in test expressions, outside of the loop body.\r\n      this.withTopicForbiddingContext(() =>\r\n        // Parse loop body.\r\n        this.parseStatement(\"while\"),\r\n      );\r\n\r\n    this.state.labels.pop();\r\n\r\n    return this.finishNode(node, \"WhileStatement\");\r\n  }\r\n\r\n  parseWithStatement(node: N.WithStatement): N.WithStatement {\r\n    if (this.state.strict) {\r\n      this.raise(this.state.start, \"'with' in strict mode\");\r\n    }\r\n    this.next();\r\n    node.object = this.parseHeaderExpression();\r\n\r\n    node.body =\r\n      // For the smartPipelines plugin:\r\n      // Disable topic references from outer contexts within the function body.\r\n      // They are permitted in function default-parameter expressions, which are\r\n      // part of the outer context, outside of the function body.\r\n      this.withTopicForbiddingContext(() =>\r\n        // Parse the statement body.\r\n        this.parseStatement(\"with\"),\r\n      );\r\n\r\n    return this.finishNode(node, \"WithStatement\");\r\n  }\r\n\r\n  parseEmptyStatement(node: N.EmptyStatement): N.EmptyStatement {\r\n    this.next();\r\n    return this.finishNode(node, \"EmptyStatement\");\r\n  }\r\n\r\n  parseLabeledStatement(\r\n    node: N.LabeledStatement,\r\n    maybeName: string,\r\n    expr: N.Identifier,\r\n    context: ?string,\r\n  ): N.LabeledStatement {\r\n    for (const label of this.state.labels) {\r\n      if (label.name === maybeName) {\r\n        this.raise(expr.start, `Label '${maybeName}' is already declared`);\r\n      }\r\n    }\r\n\r\n    const kind = this.state.type.isLoop\r\n      ? \"loop\"\r\n      : this.match(tt._switch)\r\n      ? \"switch\"\r\n      : null;\r\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\r\n      const label = this.state.labels[i];\r\n      if (label.statementStart === node.start) {\r\n        label.statementStart = this.state.start;\r\n        label.kind = kind;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.state.labels.push({\r\n      name: maybeName,\r\n      kind: kind,\r\n      statementStart: this.state.start,\r\n    });\r\n    node.body = this.parseStatement(\r\n      context\r\n        ? context.indexOf(\"label\") === -1\r\n          ? context + \"label\"\r\n          : context\r\n        : \"label\",\r\n    );\r\n\r\n    this.state.labels.pop();\r\n    node.label = expr;\r\n    return this.finishNode(node, \"LabeledStatement\");\r\n  }\r\n\r\n  parseExpressionStatement(\r\n    node: N.ExpressionStatement,\r\n    expr: N.Expression,\r\n  ): N.Statement {\r\n    node.expression = expr;\r\n    this.semicolon();\r\n    return this.finishNode(node, \"ExpressionStatement\");\r\n  }\r\n\r\n  // Parse a semicolon-enclosed block of statements, handling `\"use\r\n  // strict\"` declarations when `allowStrict` is true (used for\r\n  // function bodies).\r\n\r\n  parseBlock(\r\n    allowDirectives?: boolean = false,\r\n    createNewLexicalScope?: boolean = true,\r\n  ): N.BlockStatement {\r\n    const node = this.startNode();\r\n    this.expect(tt.braceL);\r\n    if (createNewLexicalScope) {\r\n      this.scope.enter(SCOPE_OTHER);\r\n    }\r\n    this.parseBlockBody(node, allowDirectives, false, tt.braceR);\r\n    if (createNewLexicalScope) {\r\n      this.scope.exit();\r\n    }\r\n    return this.finishNode(node, \"BlockStatement\");\r\n  }\r\n\r\n  isValidDirective(stmt: N.Statement): boolean {\r\n    return (\r\n      stmt.type === \"ExpressionStatement\" &&\r\n      stmt.expression.type === \"StringLiteral\" &&\r\n      !stmt.expression.extra.parenthesized\r\n    );\r\n  }\r\n\r\n  parseBlockBody(\r\n    node: N.BlockStatementLike,\r\n    allowDirectives: ?boolean,\r\n    topLevel: boolean,\r\n    end: TokenType,\r\n  ): void {\r\n    const body = (node.body = []);\r\n    const directives = (node.directives = []);\r\n    this.parseBlockOrModuleBlockBody(\r\n      body,\r\n      allowDirectives ? directives : undefined,\r\n      topLevel,\r\n      end,\r\n    );\r\n  }\r\n\r\n  // Undefined directives means that directives are not allowed.\r\n  parseBlockOrModuleBlockBody(\r\n    body: N.Statement[],\r\n    directives: ?(N.Directive[]),\r\n    topLevel: boolean,\r\n    end: TokenType,\r\n  ): void {\r\n    let parsedNonDirective = false;\r\n    let oldStrict;\r\n    let octalPosition;\r\n\r\n    while (!this.eat(end)) {\r\n      if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {\r\n        octalPosition = this.state.octalPosition;\r\n      }\r\n\r\n      const stmt = this.parseStatement(null, topLevel);\r\n\r\n      if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {\r\n        const directive = this.stmtToDirective(stmt);\r\n        directives.push(directive);\r\n\r\n        if (oldStrict === undefined && directive.value.value === \"use strict\") {\r\n          oldStrict = this.state.strict;\r\n          this.setStrict(true);\r\n\r\n          if (octalPosition) {\r\n            this.raise(octalPosition, \"Octal literal in strict mode\");\r\n          }\r\n        }\r\n\r\n        continue;\r\n      }\r\n\r\n      parsedNonDirective = true;\r\n      body.push(stmt);\r\n    }\r\n\r\n    if (oldStrict === false) {\r\n      this.setStrict(false);\r\n    }\r\n  }\r\n\r\n  // Parse a regular `for` loop. The disambiguation code in\r\n  // `parseStatement` will already have parsed the init statement or\r\n  // expression.\r\n\r\n  parseFor(\r\n    node: N.ForStatement,\r\n    init: ?(N.VariableDeclaration | N.Expression),\r\n  ): N.ForStatement {\r\n    node.init = init;\r\n    this.expect(tt.semi);\r\n    node.test = this.match(tt.semi) ? null : this.parseExpression();\r\n    this.expect(tt.semi);\r\n    node.update = this.match(tt.parenR) ? null : this.parseExpression();\r\n    this.expect(tt.parenR);\r\n\r\n    node.body =\r\n      // For the smartPipelines plugin: Disable topic references from outer\r\n      // contexts within the loop body. They are permitted in test expressions,\r\n      // outside of the loop body.\r\n      this.withTopicForbiddingContext(() =>\r\n        // Parse the loop body.\r\n        this.parseStatement(\"for\"),\r\n      );\r\n\r\n    this.scope.exit();\r\n    this.state.labels.pop();\r\n\r\n    return this.finishNode(node, \"ForStatement\");\r\n  }\r\n\r\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\r\n  // same from parser's perspective.\r\n\r\n  parseForIn(\r\n    node: N.ForInOf,\r\n    init: N.VariableDeclaration | N.AssignmentPattern,\r\n    awaitAt: number,\r\n  ): N.ForInOf {\r\n    const isForIn = this.match(tt._in);\r\n    this.next();\r\n\r\n    if (isForIn) {\r\n      if (awaitAt > -1) this.unexpected(awaitAt);\r\n    } else {\r\n      node.await = awaitAt > -1;\r\n    }\r\n\r\n    if (\r\n      init.type === \"VariableDeclaration\" &&\r\n      init.declarations[0].init != null &&\r\n      (!isForIn ||\r\n        this.state.strict ||\r\n        init.kind !== \"var\" ||\r\n        init.declarations[0].id.type !== \"Identifier\")\r\n    ) {\r\n      this.raise(\r\n        init.start,\r\n        `${\r\n          isForIn ? \"for-in\" : \"for-of\"\r\n        } loop variable declaration may not have an initializer`,\r\n      );\r\n    } else if (init.type === \"AssignmentPattern\") {\r\n      this.raise(init.start, \"Invalid left-hand side in for-loop\");\r\n    }\r\n\r\n    node.left = init;\r\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\r\n    this.expect(tt.parenR);\r\n\r\n    node.body =\r\n      // For the smartPipelines plugin:\r\n      // Disable topic references from outer contexts within the loop body.\r\n      // They are permitted in test expressions, outside of the loop body.\r\n      this.withTopicForbiddingContext(() =>\r\n        // Parse loop body.\r\n        this.parseStatement(\"for\"),\r\n      );\r\n\r\n    this.scope.exit();\r\n    this.state.labels.pop();\r\n\r\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\r\n  }\r\n\r\n  // Parse a list of variable declarations.\r\n\r\n  parseVar(\r\n    node: N.VariableDeclaration,\r\n    isFor: boolean,\r\n    kind: \"var\" | \"let\" | \"const\",\r\n  ): N.VariableDeclaration {\r\n    const declarations = (node.declarations = []);\r\n    const isTypescript = this.hasPlugin(\"typescript\");\r\n    node.kind = kind;\r\n    for (;;) {\r\n      const decl = this.startNode();\r\n      this.parseVarId(decl, kind);\r\n      if (this.eat(tt.eq)) {\r\n        decl.init = this.parseMaybeAssign(isFor);\r\n      } else {\r\n        if (\r\n          kind === \"const\" &&\r\n          !(this.match(tt._in) || this.isContextual(\"of\"))\r\n        ) {\r\n          // `const` with no initializer is allowed in TypeScript.\r\n          // It could be a declaration like `const x: number;`.\r\n          if (!isTypescript) {\r\n            this.unexpected();\r\n          }\r\n        } else if (\r\n          decl.id.type !== \"Identifier\" &&\r\n          !(isFor && (this.match(tt._in) || this.isContextual(\"of\")))\r\n        ) {\r\n          this.raise(\r\n            this.state.lastTokEnd,\r\n            \"Complex binding patterns require an initialization value\",\r\n          );\r\n        }\r\n        decl.init = null;\r\n      }\r\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\r\n      if (!this.eat(tt.comma)) break;\r\n    }\r\n    return node;\r\n  }\r\n\r\n  parseVarId(decl: N.VariableDeclarator, kind: \"var\" | \"let\" | \"const\"): void {\r\n    if ((kind === \"const\" || kind === \"let\") && this.isContextual(\"let\")) {\r\n      this.unexpected(null, \"let is disallowed as a lexically bound name\");\r\n    }\r\n    decl.id = this.parseBindingAtom();\r\n    this.checkLVal(\r\n      decl.id,\r\n      kind === \"var\" ? BIND_VAR : BIND_LEXICAL,\r\n      undefined,\r\n      \"variable declaration\",\r\n    );\r\n  }\r\n\r\n  // Parse a function declaration or literal (depending on the\r\n  // `isStatement` parameter).\r\n\r\n  parseFunction<T: N.NormalFunction>(\r\n    node: T,\r\n    statement?: number = FUNC_NO_FLAGS,\r\n    isAsync?: boolean = false,\r\n  ): T {\r\n    const isStatement = statement & FUNC_STATEMENT;\r\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\r\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\r\n\r\n    this.initFunction(node, isAsync);\r\n\r\n    if (this.match(tt.star) && isHangingStatement) {\r\n      this.unexpected(\r\n        this.state.start,\r\n        \"Generators can only be declared at the top level or inside a block\",\r\n      );\r\n    }\r\n    node.generator = this.eat(tt.star);\r\n\r\n    if (isStatement) {\r\n      node.id = this.parseFunctionId(requireId);\r\n    }\r\n\r\n    const oldInClassProperty = this.state.inClassProperty;\r\n    const oldYieldPos = this.state.yieldPos;\r\n    const oldAwaitPos = this.state.awaitPos;\r\n    this.state.inClassProperty = false;\r\n    this.state.yieldPos = 0;\r\n    this.state.awaitPos = 0;\r\n    this.scope.enter(functionFlags(node.async, node.generator));\r\n\r\n    if (!isStatement) {\r\n      node.id = this.parseFunctionId();\r\n    }\r\n\r\n    this.parseFunctionParams(node);\r\n\r\n    // For the smartPipelines plugin: Disable topic references from outer\r\n    // contexts within the function body. They are permitted in test\r\n    // expressions, outside of the function body.\r\n    this.withTopicForbiddingContext(() => {\r\n      // Parse the function body.\r\n      this.parseFunctionBodyAndFinish(\r\n        node,\r\n        isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\",\r\n      );\r\n    });\r\n\r\n    this.scope.exit();\r\n\r\n    if (isStatement && !isHangingStatement) {\r\n      // We need to validate this _after_ parsing the function body\r\n      // because of TypeScript body-less function declarations,\r\n      // which shouldn't be added to the scope.\r\n      this.checkFunctionStatementId(node);\r\n    }\r\n\r\n    this.state.inClassProperty = oldInClassProperty;\r\n    this.state.yieldPos = oldYieldPos;\r\n    this.state.awaitPos = oldAwaitPos;\r\n\r\n    return node;\r\n  }\r\n\r\n  parseFunctionId(requireId?: boolean): ?N.Identifier {\r\n    return requireId || this.match(tt.name) ? this.parseIdentifier() : null;\r\n  }\r\n\r\n  parseFunctionParams(node: N.Function, allowModifiers?: boolean): void {\r\n    const oldInParameters = this.state.inParameters;\r\n    this.state.inParameters = true;\r\n\r\n    this.expect(tt.parenL);\r\n    node.params = this.parseBindingList(\r\n      tt.parenR,\r\n      /* allowEmpty */ false,\r\n      allowModifiers,\r\n    );\r\n\r\n    this.state.inParameters = oldInParameters;\r\n    this.checkYieldAwaitInDefaultParams();\r\n  }\r\n\r\n  checkFunctionStatementId(node: N.Function): void {\r\n    if (!node.id) return;\r\n\r\n    // If it is a regular function declaration in sloppy mode, then it is\r\n    // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\r\n    // mode depends on properties of the current scope (see\r\n    // treatFunctionsAsVar).\r\n    this.checkLVal(\r\n      node.id,\r\n      this.state.strict || node.generator || node.async\r\n        ? this.scope.treatFunctionsAsVar\r\n          ? BIND_VAR\r\n          : BIND_LEXICAL\r\n        : BIND_FUNCTION,\r\n      null,\r\n      \"function name\",\r\n    );\r\n  }\r\n\r\n  // Parse a class declaration or literal (depending on the\r\n  // `isStatement` parameter).\r\n\r\n  parseClass<T: N.Class>(\r\n    node: T,\r\n    isStatement: /* T === ClassDeclaration */ boolean,\r\n    optionalId?: boolean,\r\n  ): T {\r\n    this.next();\r\n    this.takeDecorators(node);\r\n\r\n    // A class definition is always strict mode code.\r\n    const oldStrict = this.state.strict;\r\n    this.state.strict = true;\r\n\r\n    this.parseClassId(node, isStatement, optionalId);\r\n    this.parseClassSuper(node);\r\n    node.body = this.parseClassBody(!!node.superClass);\r\n\r\n    this.state.strict = oldStrict;\r\n\r\n    return this.finishNode(\r\n      node,\r\n      isStatement ? \"ClassDeclaration\" : \"ClassExpression\",\r\n    );\r\n  }\r\n\r\n  isClassProperty(): boolean {\r\n    return this.match(tt.eq) || this.match(tt.semi) || this.match(tt.braceR);\r\n  }\r\n\r\n  isClassMethod(): boolean {\r\n    return this.match(tt.parenL);\r\n  }\r\n\r\n  isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\r\n    return (\r\n      !method.computed &&\r\n      !method.static &&\r\n      (method.key.name === \"constructor\" || // Identifier\r\n        method.key.value === \"constructor\") // String literal\r\n    );\r\n  }\r\n\r\n  parseClassBody(constructorAllowsSuper: boolean): N.ClassBody {\r\n    this.state.classLevel++;\r\n\r\n    const state = { hadConstructor: false };\r\n    let decorators: N.Decorator[] = [];\r\n    const classBody: N.ClassBody = this.startNode();\r\n    classBody.body = [];\r\n\r\n    this.expect(tt.braceL);\r\n\r\n    // For the smartPipelines plugin: Disable topic references from outer\r\n    // contexts within the class body. They are permitted in test expressions,\r\n    // outside of the class body.\r\n    this.withTopicForbiddingContext(() => {\r\n      while (!this.eat(tt.braceR)) {\r\n        if (this.eat(tt.semi)) {\r\n          if (decorators.length > 0) {\r\n            this.raise(\r\n              this.state.lastTokEnd,\r\n              \"Decorators must not be followed by a semicolon\",\r\n            );\r\n          }\r\n          continue;\r\n        }\r\n\r\n        if (this.match(tt.at)) {\r\n          decorators.push(this.parseDecorator());\r\n          continue;\r\n        }\r\n\r\n        const member = this.startNode();\r\n\r\n        // steal the decorators if there are any\r\n        if (decorators.length) {\r\n          member.decorators = decorators;\r\n          this.resetStartLocationFromNode(member, decorators[0]);\r\n          decorators = [];\r\n        }\r\n\r\n        this.parseClassMember(classBody, member, state, constructorAllowsSuper);\r\n\r\n        if (\r\n          member.kind === \"constructor\" &&\r\n          member.decorators &&\r\n          member.decorators.length > 0\r\n        ) {\r\n          this.raise(\r\n            member.start,\r\n            \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\r\n          );\r\n        }\r\n      }\r\n    });\r\n\r\n    if (decorators.length) {\r\n      this.raise(\r\n        this.state.start,\r\n        \"You have trailing decorators with no method\",\r\n      );\r\n    }\r\n\r\n    this.state.classLevel--;\r\n\r\n    return this.finishNode(classBody, \"ClassBody\");\r\n  }\r\n\r\n  parseClassMember(\r\n    classBody: N.ClassBody,\r\n    member: N.ClassMember,\r\n    state: { hadConstructor: boolean },\r\n    constructorAllowsSuper: boolean,\r\n  ): void {\r\n    let isStatic = false;\r\n    const containsEsc = this.state.containsEsc;\r\n\r\n    if (this.match(tt.name) && this.state.value === \"static\") {\r\n      const key = this.parseIdentifier(true); // eats 'static'\r\n\r\n      if (this.isClassMethod()) {\r\n        const method: N.ClassMethod = (member: any);\r\n\r\n        // a method named 'static'\r\n        method.kind = \"method\";\r\n        method.computed = false;\r\n        method.key = key;\r\n        method.static = false;\r\n        this.pushClassMethod(\r\n          classBody,\r\n          method,\r\n          false,\r\n          false,\r\n          /* isConstructor */ false,\r\n          false,\r\n        );\r\n        return;\r\n      } else if (this.isClassProperty()) {\r\n        const prop: N.ClassProperty = (member: any);\r\n\r\n        // a property named 'static'\r\n        prop.computed = false;\r\n        prop.key = key;\r\n        prop.static = false;\r\n        classBody.body.push(this.parseClassProperty(prop));\r\n        return;\r\n      } else if (containsEsc) {\r\n        throw this.unexpected();\r\n      }\r\n\r\n      // otherwise something static\r\n      isStatic = true;\r\n    }\r\n\r\n    this.parseClassMemberWithIsStatic(\r\n      classBody,\r\n      member,\r\n      state,\r\n      isStatic,\r\n      constructorAllowsSuper,\r\n    );\r\n  }\r\n\r\n  parseClassMemberWithIsStatic(\r\n    classBody: N.ClassBody,\r\n    member: N.ClassMember,\r\n    state: { hadConstructor: boolean },\r\n    isStatic: boolean,\r\n    constructorAllowsSuper: boolean,\r\n  ) {\r\n    const publicMethod: $FlowSubtype<N.ClassMethod> = member;\r\n    const privateMethod: $FlowSubtype<N.ClassPrivateMethod> = member;\r\n    const publicProp: $FlowSubtype<N.ClassMethod> = member;\r\n    const privateProp: $FlowSubtype<N.ClassPrivateMethod> = member;\r\n\r\n    const method: typeof publicMethod | typeof privateMethod = publicMethod;\r\n    const publicMember: typeof publicMethod | typeof publicProp = publicMethod;\r\n\r\n    member.static = isStatic;\r\n\r\n    if (this.eat(tt.star)) {\r\n      // a generator\r\n      method.kind = \"method\";\r\n      this.parseClassPropertyName(method);\r\n\r\n      if (method.key.type === \"PrivateName\") {\r\n        // Private generator method\r\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\r\n        return;\r\n      }\r\n\r\n      if (this.isNonstaticConstructor(publicMethod)) {\r\n        this.raise(publicMethod.key.start, \"Constructor can't be a generator\");\r\n      }\r\n\r\n      this.pushClassMethod(\r\n        classBody,\r\n        publicMethod,\r\n        true,\r\n        false,\r\n        /* isConstructor */ false,\r\n        false,\r\n      );\r\n\r\n      return;\r\n    }\r\n\r\n    const containsEsc = this.state.containsEsc;\r\n    const key = this.parseClassPropertyName(member);\r\n    const isPrivate = key.type === \"PrivateName\";\r\n    // Check the key is not a computed expression or string literal.\r\n    const isSimple = key.type === \"Identifier\";\r\n\r\n    this.parsePostMemberNameModifiers(publicMember);\r\n\r\n    if (this.isClassMethod()) {\r\n      method.kind = \"method\";\r\n\r\n      if (isPrivate) {\r\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\r\n        return;\r\n      }\r\n\r\n      // a normal method\r\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\r\n      let allowsDirectSuper = false;\r\n      if (isConstructor) {\r\n        publicMethod.kind = \"constructor\";\r\n\r\n        if (publicMethod.decorators) {\r\n          this.raise(\r\n            publicMethod.start,\r\n            \"You can't attach decorators to a class constructor\",\r\n          );\r\n        }\r\n\r\n        // TypeScript allows multiple overloaded constructor declarations.\r\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\r\n          this.raise(key.start, \"Duplicate constructor in the same class\");\r\n        }\r\n        state.hadConstructor = true;\r\n        allowsDirectSuper = constructorAllowsSuper;\r\n      }\r\n\r\n      this.pushClassMethod(\r\n        classBody,\r\n        publicMethod,\r\n        false,\r\n        false,\r\n        isConstructor,\r\n        allowsDirectSuper,\r\n      );\r\n    } else if (this.isClassProperty()) {\r\n      if (isPrivate) {\r\n        this.pushClassPrivateProperty(classBody, privateProp);\r\n      } else {\r\n        this.pushClassProperty(classBody, publicProp);\r\n      }\r\n    } else if (\r\n      isSimple &&\r\n      key.name === \"غير_متزامن\" &&\r\n      !containsEsc &&\r\n      !this.isLineTerminator()\r\n    ) {\r\n      // an async method\r\n      const isGenerator = this.eat(tt.star);\r\n\r\n      method.kind = \"method\";\r\n      // The so-called parsed name would have been \"غير_متزامن\": get the real name.\r\n      this.parseClassPropertyName(method);\r\n\r\n      if (method.key.type === \"PrivateName\") {\r\n        // private async method\r\n        this.pushClassPrivateMethod(\r\n          classBody,\r\n          privateMethod,\r\n          isGenerator,\r\n          true,\r\n        );\r\n      } else {\r\n        if (this.isNonstaticConstructor(publicMethod)) {\r\n          this.raise(\r\n            publicMethod.key.start,\r\n            \"Constructor can't be an async function\",\r\n          );\r\n        }\r\n\r\n        this.pushClassMethod(\r\n          classBody,\r\n          publicMethod,\r\n          isGenerator,\r\n          true,\r\n          /* isConstructor */ false,\r\n          false,\r\n        );\r\n      }\r\n    } else if (\r\n      isSimple &&\r\n      (key.name === \"get\" || key.name === \"set\") &&\r\n      !containsEsc &&\r\n      !(this.match(tt.star) && this.isLineTerminator())\r\n    ) {\r\n      // `get\\n*` is an uninitialized property named 'get' followed by a generator.\r\n      // a getter or setter\r\n      method.kind = key.name;\r\n      // The so-called parsed name would have been \"get/set\": get the real name.\r\n      this.parseClassPropertyName(publicMethod);\r\n\r\n      if (method.key.type === \"PrivateName\") {\r\n        // private getter/setter\r\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\r\n      } else {\r\n        if (this.isNonstaticConstructor(publicMethod)) {\r\n          this.raise(\r\n            publicMethod.key.start,\r\n            \"Constructor can't have get/set modifier\",\r\n          );\r\n        }\r\n        this.pushClassMethod(\r\n          classBody,\r\n          publicMethod,\r\n          false,\r\n          false,\r\n          /* isConstructor */ false,\r\n          false,\r\n        );\r\n      }\r\n\r\n      this.checkGetterSetterParams(publicMethod);\r\n    } else if (this.isLineTerminator()) {\r\n      // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\r\n      if (isPrivate) {\r\n        this.pushClassPrivateProperty(classBody, privateProp);\r\n      } else {\r\n        this.pushClassProperty(classBody, publicProp);\r\n      }\r\n    } else {\r\n      this.unexpected();\r\n    }\r\n  }\r\n\r\n  parseClassPropertyName(member: N.ClassMember): N.Expression | N.Identifier {\r\n    const key = this.parsePropertyName(member);\r\n\r\n    if (\r\n      !member.computed &&\r\n      member.static &&\r\n      ((key: $FlowSubtype<N.Identifier>).name === \"prototype\" ||\r\n        (key: $FlowSubtype<N.StringLiteral>).value === \"prototype\")\r\n    ) {\r\n      this.raise(\r\n        key.start,\r\n        \"Classes may not have static property named prototype\",\r\n      );\r\n    }\r\n\r\n    if (key.type === \"PrivateName\" && key.id.name === \"constructor\") {\r\n      this.raise(\r\n        key.start,\r\n        \"Classes may not have a private field named '#constructor'\",\r\n      );\r\n    }\r\n\r\n    return key;\r\n  }\r\n\r\n  pushClassProperty(classBody: N.ClassBody, prop: N.ClassProperty) {\r\n    // This only affects properties, not methods.\r\n    if (this.isNonstaticConstructor(prop)) {\r\n      this.raise(\r\n        prop.key.start,\r\n        \"Classes may not have a non-static field named 'constructor'\",\r\n      );\r\n    }\r\n    classBody.body.push(this.parseClassProperty(prop));\r\n  }\r\n\r\n  pushClassPrivateProperty(\r\n    classBody: N.ClassBody,\r\n    prop: N.ClassPrivateProperty,\r\n  ) {\r\n    this.expectPlugin(\"classPrivateProperties\", prop.key.start);\r\n    classBody.body.push(this.parseClassPrivateProperty(prop));\r\n  }\r\n\r\n  pushClassMethod(\r\n    classBody: N.ClassBody,\r\n    method: N.ClassMethod,\r\n    isGenerator: boolean,\r\n    isAsync: boolean,\r\n    isConstructor: boolean,\r\n    allowsDirectSuper: boolean,\r\n  ): void {\r\n    classBody.body.push(\r\n      this.parseMethod(\r\n        method,\r\n        isGenerator,\r\n        isAsync,\r\n        isConstructor,\r\n        allowsDirectSuper,\r\n        \"ClassMethod\",\r\n        true,\r\n      ),\r\n    );\r\n  }\r\n\r\n  pushClassPrivateMethod(\r\n    classBody: N.ClassBody,\r\n    method: N.ClassPrivateMethod,\r\n    isGenerator: boolean,\r\n    isAsync: boolean,\r\n  ): void {\r\n    this.expectPlugin(\"classPrivateMethods\", method.key.start);\r\n    classBody.body.push(\r\n      this.parseMethod(\r\n        method,\r\n        isGenerator,\r\n        isAsync,\r\n        /* isConstructor */ false,\r\n        false,\r\n        \"ClassPrivateMethod\",\r\n        true,\r\n      ),\r\n    );\r\n  }\r\n\r\n  // Overridden in typescript.js\r\n  parsePostMemberNameModifiers(\r\n    // eslint-disable-next-line no-unused-vars\r\n    methodOrProp: N.ClassMethod | N.ClassProperty,\r\n  ): void {}\r\n\r\n  // Overridden in typescript.js\r\n  parseAccessModifier(): ?N.Accessibility {\r\n    return undefined;\r\n  }\r\n\r\n  parseClassPrivateProperty(\r\n    node: N.ClassPrivateProperty,\r\n  ): N.ClassPrivateProperty {\r\n    this.state.inClassProperty = true;\r\n\r\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\r\n\r\n    node.value = this.eat(tt.eq) ? this.parseMaybeAssign() : null;\r\n    this.semicolon();\r\n    this.state.inClassProperty = false;\r\n\r\n    this.scope.exit();\r\n\r\n    return this.finishNode(node, \"ClassPrivateProperty\");\r\n  }\r\n\r\n  parseClassProperty(node: N.ClassProperty): N.ClassProperty {\r\n    if (!node.typeAnnotation) {\r\n      this.expectPlugin(\"classProperties\");\r\n    }\r\n\r\n    this.state.inClassProperty = true;\r\n\r\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\r\n\r\n    if (this.match(tt.eq)) {\r\n      this.expectPlugin(\"classProperties\");\r\n      this.next();\r\n      node.value = this.parseMaybeAssign();\r\n    } else {\r\n      node.value = null;\r\n    }\r\n    this.semicolon();\r\n    this.state.inClassProperty = false;\r\n\r\n    this.scope.exit();\r\n\r\n    return this.finishNode(node, \"ClassProperty\");\r\n  }\r\n\r\n  parseClassId(\r\n    node: N.Class,\r\n    isStatement: boolean,\r\n    optionalId: ?boolean,\r\n  ): void {\r\n    if (this.match(tt.name)) {\r\n      node.id = this.parseIdentifier();\r\n      if (isStatement) {\r\n        this.checkLVal(node.id, BIND_CLASS, undefined, \"class name\");\r\n      }\r\n    } else {\r\n      if (optionalId || !isStatement) {\r\n        node.id = null;\r\n      } else {\r\n        this.unexpected(null, \"A class name is required\");\r\n      }\r\n    }\r\n  }\r\n\r\n  parseClassSuper(node: N.Class): void {\r\n    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;\r\n  }\r\n\r\n  // Parses module export declaration.\r\n\r\n  parseExport(node: N.Node): N.AnyExport {\r\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node);\r\n    const parseAfterDefault = !hasDefault || this.eat(tt.comma);\r\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\r\n    const hasNamespace =\r\n      hasStar && this.maybeParseExportNamespaceSpecifier(node);\r\n    const parseAfterNamespace =\r\n      parseAfterDefault && (!hasNamespace || this.eat(tt.comma));\r\n    const isFromRequired = hasDefault || hasStar;\r\n\r\n    if (hasStar && !hasNamespace) {\r\n      if (hasDefault) this.unexpected();\r\n      this.parseExportFrom(node, true);\r\n\r\n      return this.finishNode(node, \"ExportAllDeclaration\");\r\n    }\r\n\r\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\r\n\r\n    if (\r\n      (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) ||\r\n      (hasNamespace && parseAfterNamespace && !hasSpecifiers)\r\n    ) {\r\n      throw this.unexpected(null, tt.braceL);\r\n    }\r\n\r\n    let hasDeclaration;\r\n    if (isFromRequired || hasSpecifiers) {\r\n      hasDeclaration = false;\r\n      this.parseExportFrom(node, isFromRequired);\r\n    } else {\r\n      hasDeclaration = this.maybeParseExportDeclaration(node);\r\n    }\r\n\r\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\r\n      this.checkExport(node, true, false, !!node.source);\r\n      return this.finishNode(node, \"ExportNamedDeclaration\");\r\n    }\r\n\r\n    if (this.eat(tt._default)) {\r\n      // export default ...\r\n      node.declaration = this.parseExportDefaultExpression();\r\n      this.checkExport(node, true, true);\r\n\r\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\r\n    }\r\n\r\n    throw this.unexpected(null, tt.braceL);\r\n  }\r\n\r\n  // eslint-disable-next-line no-unused-vars\r\n  eatExportStar(node: N.Node): boolean {\r\n    return this.eat(tt.star);\r\n  }\r\n\r\n  maybeParseExportDefaultSpecifier(node: N.Node): boolean {\r\n    if (this.isExportDefaultSpecifier()) {\r\n      // export defaultObj ...\r\n      this.expectPlugin(\"exportDefaultFrom\");\r\n      const specifier = this.startNode();\r\n      specifier.exported = this.parseIdentifier(true);\r\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  maybeParseExportNamespaceSpecifier(node: N.Node): boolean {\r\n    if (this.isContextual(\"as\")) {\r\n      if (!node.specifiers) node.specifiers = [];\r\n      this.expectPlugin(\"exportNamespaceFrom\");\r\n\r\n      const specifier = this.startNodeAt(\r\n        this.state.lastTokStart,\r\n        this.state.lastTokStartLoc,\r\n      );\r\n\r\n      this.next();\r\n\r\n      specifier.exported = this.parseIdentifier(true);\r\n      node.specifiers.push(\r\n        this.finishNode(specifier, \"ExportNamespaceSpecifier\"),\r\n      );\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  maybeParseExportNamedSpecifiers(node: N.Node): boolean {\r\n    if (this.match(tt.braceL)) {\r\n      if (!node.specifiers) node.specifiers = [];\r\n      node.specifiers.push(...this.parseExportSpecifiers());\r\n\r\n      node.source = null;\r\n      node.declaration = null;\r\n\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  maybeParseExportDeclaration(node: N.Node): boolean {\r\n    if (this.shouldParseExportDeclaration()) {\r\n      if (this.isContextual(\"غير_متزامن\")) {\r\n        const next = this.lookahead();\r\n\r\n        // export async;\r\n        if (next.type !== tt._function) {\r\n          this.unexpected(next.start, `Unexpected token, expected \"مهمة\"`);\r\n        }\r\n      }\r\n\r\n      node.specifiers = [];\r\n      node.source = null;\r\n      node.declaration = this.parseExportDeclaration(node);\r\n\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  isAsyncFunction(): boolean {\r\n    if (!this.isContextual(\"غير_متزامن\")) {return false};\r\n\r\n    const { pos } = this.state;\r\n\r\n    skipWhiteSpace.lastIndex = pos;\r\n    const skip = skipWhiteSpace.exec(this.input);\r\n\r\n    if (!skip || !skip.length) return false;\r\n\r\n    const next = pos + skip[0].length;\r\n\r\n    return (\r\n      !lineBreak.test(this.input.slice(pos, next)) &&\r\n      this.input.slice(next, next + 4) === \"مهمة\" &&\r\n      (next + 4 === this.length ||\r\n        !isIdentifierChar(this.input.charCodeAt(next + 4)))\r\n    );\r\n  }\r\n\r\n  parseExportDefaultExpression(): N.Expression | N.Declaration {\r\n    const expr = this.startNode();\r\n\r\n    const isAsync = this.isAsyncFunction();\r\n\r\n    if (this.match(tt._function) || isAsync) {\r\n      this.next();\r\n      if (isAsync) {\r\n        this.next();\r\n      }\r\n\r\n      return this.parseFunction(\r\n        expr,\r\n        FUNC_STATEMENT | FUNC_NULLABLE_ID,\r\n        isAsync,\r\n      );\r\n    } else if (this.match(tt._class)) {\r\n      return this.parseClass(expr, true, true);\r\n    } else if (this.match(tt.at)) {\r\n      if (\r\n        this.hasPlugin(\"decorators\") &&\r\n        this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")\r\n      ) {\r\n        this.unexpected(\r\n          this.state.start,\r\n          \"Decorators must be placed *before* the 'export' keyword.\" +\r\n            \" You can set the 'decoratorsBeforeExport' option to false to use\" +\r\n            \" the 'export @decorator class {}' syntax\",\r\n        );\r\n      }\r\n      this.parseDecorators(false);\r\n      return this.parseClass(expr, true, true);\r\n    } else if (this.match(tt._const) || this.match(tt._var) || this.isLet()) {\r\n      return this.raise(\r\n        this.state.start,\r\n        \"Only expressions, functions or classes are allowed as the `default` export.\",\r\n      );\r\n    } else {\r\n      const res = this.parseMaybeAssign();\r\n      this.semicolon();\r\n      return res;\r\n    }\r\n  }\r\n\r\n  // eslint-disable-next-line no-unused-vars\r\n  parseExportDeclaration(node: N.ExportNamedDeclaration): ?N.Declaration {\r\n    return this.parseStatement(null);\r\n  }\r\n\r\n  isExportDefaultSpecifier(): boolean {\r\n    if (this.match(tt.name)) {\r\n      return this.state.value !== \"غير_متزامن\" && this.state.value !== \"let\";\r\n    }\r\n\r\n    if (!this.match(tt._default)) {\r\n      return false;\r\n    }\r\n\r\n    const lookahead = this.lookahead();\r\n    return (\r\n      lookahead.type === tt.comma ||\r\n      (lookahead.type === tt.name && lookahead.value === \"from\")\r\n    );\r\n  }\r\n\r\n  parseExportFrom(node: N.ExportNamedDeclaration, expect?: boolean): void {\r\n    if (this.eatContextual(\"from\")) {\r\n      node.source = this.parseImportSource();\r\n      this.checkExport(node);\r\n    } else {\r\n      if (expect) {\r\n        this.unexpected();\r\n      } else {\r\n        node.source = null;\r\n      }\r\n    }\r\n\r\n    this.semicolon();\r\n  }\r\n\r\n  shouldParseExportDeclaration(): boolean {\r\n    if (this.match(tt.at)) {\r\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\r\n      if (this.hasPlugin(\"decorators\")) {\r\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\r\n          this.unexpected(\r\n            this.state.start,\r\n            \"Decorators must be placed *before* the 'export' keyword.\" +\r\n              \" You can set the 'decoratorsBeforeExport' option to false to use\" +\r\n              \" the 'export @decorator class {}' syntax\",\r\n          );\r\n        } else {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return (\r\n      this.state.type.keyword === \"var\" ||\r\n      this.state.type.keyword === \"const\" ||\r\n      this.state.type.keyword === \"مهمة\" ||\r\n      this.state.type.keyword === \"class\" ||\r\n      this.isLet() ||\r\n      this.isAsyncFunction()\r\n    );\r\n  }\r\n\r\n  checkExport(\r\n    node: N.ExportNamedDeclaration,\r\n    checkNames?: boolean,\r\n    isDefault?: boolean,\r\n    isFrom?: boolean,\r\n  ): void {\r\n    if (checkNames) {\r\n      // Check for duplicate exports\r\n      if (isDefault) {\r\n        // Default exports\r\n        this.checkDuplicateExports(node, \"default\");\r\n      } else if (node.specifiers && node.specifiers.length) {\r\n        // Named exports\r\n        for (const specifier of node.specifiers) {\r\n          this.checkDuplicateExports(specifier, specifier.exported.name);\r\n          // $FlowIgnore\r\n          if (!isFrom && specifier.local) {\r\n            // check for keywords used as local names\r\n            this.checkReservedWord(\r\n              specifier.local.name,\r\n              specifier.local.start,\r\n              true,\r\n              false,\r\n            );\r\n            // check if export is defined\r\n            // $FlowIgnore\r\n            this.scope.checkLocalExport(specifier.local);\r\n          }\r\n        }\r\n      } else if (node.declaration) {\r\n        // Exported declarations\r\n        if (\r\n          node.declaration.type === \"FunctionDeclaration\" ||\r\n          node.declaration.type === \"ClassDeclaration\"\r\n        ) {\r\n          const id = node.declaration.id;\r\n          if (!id) throw new Error(\"Assertion failure\");\r\n\r\n          this.checkDuplicateExports(node, id.name);\r\n        } else if (node.declaration.type === \"VariableDeclaration\") {\r\n          for (const declaration of node.declaration.declarations) {\r\n            this.checkDeclaration(declaration.id);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const currentContextDecorators = this.state.decoratorStack[\r\n      this.state.decoratorStack.length - 1\r\n    ];\r\n    if (currentContextDecorators.length) {\r\n      const isClass =\r\n        node.declaration &&\r\n        (node.declaration.type === \"ClassDeclaration\" ||\r\n          node.declaration.type === \"ClassExpression\");\r\n      if (!node.declaration || !isClass) {\r\n        throw this.raise(\r\n          node.start,\r\n          \"You can only use decorators on an export when exporting a class\",\r\n        );\r\n      }\r\n      this.takeDecorators(node.declaration);\r\n    }\r\n  }\r\n\r\n  checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\r\n    if (node.type === \"Identifier\") {\r\n      this.checkDuplicateExports(node, node.name);\r\n    } else if (node.type === \"ObjectPattern\") {\r\n      for (const prop of node.properties) {\r\n        this.checkDeclaration(prop);\r\n      }\r\n    } else if (node.type === \"ArrayPattern\") {\r\n      for (const elem of node.elements) {\r\n        if (elem) {\r\n          this.checkDeclaration(elem);\r\n        }\r\n      }\r\n    } else if (node.type === \"ObjectProperty\") {\r\n      this.checkDeclaration(node.value);\r\n    } else if (node.type === \"RestElement\") {\r\n      this.checkDeclaration(node.argument);\r\n    } else if (node.type === \"AssignmentPattern\") {\r\n      this.checkDeclaration(node.left);\r\n    }\r\n  }\r\n\r\n  checkDuplicateExports(\r\n    node:\r\n      | N.Identifier\r\n      | N.ExportNamedDeclaration\r\n      | N.ExportSpecifier\r\n      | N.ExportDefaultSpecifier,\r\n    name: string,\r\n  ): void {\r\n    if (this.state.exportedIdentifiers.indexOf(name) > -1) {\r\n      throw this.raise(\r\n        node.start,\r\n        name === \"default\"\r\n          ? \"Only one default export allowed per module.\"\r\n          : `\\`${name}\\` has already been exported. Exported identifiers must be unique.`,\r\n      );\r\n    }\r\n    this.state.exportedIdentifiers.push(name);\r\n  }\r\n\r\n  // Parses a comma-separated list of module exports.\r\n\r\n  parseExportSpecifiers(): Array<N.ExportSpecifier> {\r\n    const nodes = [];\r\n    let first = true;\r\n\r\n    // export { x, y as z } [from '...']\r\n    this.expect(tt.braceL);\r\n\r\n    while (!this.eat(tt.braceR)) {\r\n      if (first) {\r\n        first = false;\r\n      } else {\r\n        this.expect(tt.comma);\r\n        if (this.eat(tt.braceR)) break;\r\n      }\r\n\r\n      const node = this.startNode();\r\n      node.local = this.parseIdentifier(true);\r\n      node.exported = this.eatContextual(\"as\")\r\n        ? this.parseIdentifier(true)\r\n        : node.local.__clone();\r\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\r\n    }\r\n\r\n    return nodes;\r\n  }\r\n\r\n  // Parses import declaration.\r\n\r\n  parseImport(node: N.Node): N.AnyImport {\r\n    // import '...'\r\n    node.specifiers = [];\r\n    if (!this.match(tt.string)) {\r\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\r\n      const parseNext = !hasDefault || this.eat(tt.comma);\r\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\r\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\r\n      this.expectContextual(\"from\");\r\n    }\r\n    node.source = this.parseImportSource();\r\n    this.semicolon();\r\n    return this.finishNode(node, \"ImportDeclaration\");\r\n  }\r\n\r\n  parseImportSource(): N.StringLiteral {\r\n    if (!this.match(tt.string)) this.unexpected();\r\n    return this.parseExprAtom();\r\n  }\r\n\r\n  // eslint-disable-next-line no-unused-vars\r\n  shouldParseDefaultImport(node: N.ImportDeclaration): boolean {\r\n    return this.match(tt.name);\r\n  }\r\n\r\n  parseImportSpecifierLocal(\r\n    node: N.ImportDeclaration,\r\n    specifier: N.Node,\r\n    type: string,\r\n    contextDescription: string,\r\n  ): void {\r\n    specifier.local = this.parseIdentifier();\r\n    this.checkLVal(\r\n      specifier.local,\r\n      BIND_LEXICAL,\r\n      undefined,\r\n      contextDescription,\r\n    );\r\n    node.specifiers.push(this.finishNode(specifier, type));\r\n  }\r\n\r\n  maybeParseDefaultImportSpecifier(node: N.ImportDeclaration): boolean {\r\n    if (this.shouldParseDefaultImport(node)) {\r\n      // import defaultObj, { x, y as z } from '...'\r\n      this.parseImportSpecifierLocal(\r\n        node,\r\n        this.startNode(),\r\n        \"ImportDefaultSpecifier\",\r\n        \"default import specifier\",\r\n      );\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  maybeParseStarImportSpecifier(node: N.ImportDeclaration): boolean {\r\n    if (this.match(tt.star)) {\r\n      const specifier = this.startNode();\r\n      this.next();\r\n      this.expectContextual(\"as\");\r\n\r\n      this.parseImportSpecifierLocal(\r\n        node,\r\n        specifier,\r\n        \"ImportNamespaceSpecifier\",\r\n        \"import namespace specifier\",\r\n      );\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  parseNamedImportSpecifiers(node: N.ImportDeclaration) {\r\n    let first = true;\r\n    this.expect(tt.braceL);\r\n    while (!this.eat(tt.braceR)) {\r\n      if (first) {\r\n        first = false;\r\n      } else {\r\n        // Detect an attempt to deep destructure\r\n        if (this.eat(tt.colon)) {\r\n          this.unexpected(\r\n            null,\r\n            \"ES2015 named imports do not destructure. \" +\r\n              \"Use another statement for destructuring after the import.\",\r\n          );\r\n        }\r\n\r\n        this.expect(tt.comma);\r\n        if (this.eat(tt.braceR)) break;\r\n      }\r\n\r\n      this.parseImportSpecifier(node);\r\n    }\r\n  }\r\n\r\n  parseImportSpecifier(node: N.ImportDeclaration): void {\r\n    const specifier = this.startNode();\r\n    specifier.imported = this.parseIdentifier(true);\r\n    if (this.eatContextual(\"as\")) {\r\n      specifier.local = this.parseIdentifier();\r\n    } else {\r\n      this.checkReservedWord(\r\n        specifier.imported.name,\r\n        specifier.start,\r\n        true,\r\n        true,\r\n      );\r\n      specifier.local = specifier.imported.__clone();\r\n    }\r\n    this.checkLVal(\r\n      specifier.local,\r\n      BIND_LEXICAL,\r\n      undefined,\r\n      \"import specifier\",\r\n    );\r\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport type { Options } from \"../options\";\r\nimport type { File, JSXOpeningElement } from \"../types\";\r\nimport type { PluginList } from \"../plugin-utils\";\r\nimport { getOptions } from \"../options\";\r\nimport StatementParser from \"./statement\";\r\nimport { SCOPE_PROGRAM } from \"../util/scopeflags\";\r\nimport ScopeHandler from \"../util/scope\";\r\n\r\nexport type PluginsMap = Map<string, { [string]: any }>;\r\n\r\nexport default class Parser extends StatementParser {\r\n  // Forward-declaration so typescript plugin can override jsx plugin\r\n  +jsxParseOpeningElementAfterName: (\r\n    node: JSXOpeningElement,\r\n  ) => JSXOpeningElement;\r\n\r\n  constructor(options: ?Options, input: string) {\r\n    options = getOptions(options);\r\n    super(options, input);\r\n\r\n    const ScopeHandler = this.getScopeHandler();\r\n\r\n    this.options = options;\r\n    this.inModule = this.options.sourceType === \"module\";\r\n    this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);\r\n    this.plugins = pluginsMap(this.options.plugins);\r\n    this.filename = options.sourceFilename;\r\n  }\r\n\r\n  // This can be overwritten, for example, by the TypeScript plugin.\r\n  getScopeHandler(): Class<ScopeHandler<*>> {\r\n    return ScopeHandler;\r\n  }\r\n\r\n  parse(): File {\r\n    this.scope.enter(SCOPE_PROGRAM);\r\n    const file = this.startNode();\r\n    const program = this.startNode();\r\n    this.nextToken();\r\n    return this.parseTopLevel(file, program);\r\n  }\r\n}\r\n\r\nfunction pluginsMap(plugins: PluginList): PluginsMap {\r\n  const pluginMap: PluginsMap = new Map();\r\n  for (const plugin of plugins) {\r\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\r\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\r\n  }\r\n  return pluginMap;\r\n}\r\n","// @flow\r\n\r\nimport { type Options } from \"./options\";\r\nimport {\r\n  hasPlugin,\r\n  validatePlugins,\r\n  mixinPluginNames,\r\n  mixinPlugins,\r\n  type PluginList,\r\n} from \"./plugin-utils\";\r\nimport Parser from \"./parser\";\r\n\r\nimport { types as tokTypes } from \"./tokenizer/types\";\r\nimport \"./tokenizer/context\";\r\n\r\nimport type { Expression, File } from \"./types\";\r\n\r\nexport function parse(input: string, options?: Options): File {\r\n  if (options && options.sourceType === \"unambiguous\") {\r\n    options = {\r\n      ...options,\r\n    };\r\n    try {\r\n      options.sourceType = \"module\";\r\n      const parser = getParser(options, input);\r\n      const ast = parser.parse();\r\n\r\n      // Rather than try to parse as a script first, we opt to parse as a module and convert back\r\n      // to a script where possible to avoid having to do a full re-parse of the input content.\r\n      if (!parser.sawUnambiguousESM) ast.program.sourceType = \"script\";\r\n      return ast;\r\n    } catch (moduleError) {\r\n      try {\r\n        options.sourceType = \"script\";\r\n        return getParser(options, input).parse();\r\n      } catch (scriptError) {}\r\n\r\n      throw moduleError;\r\n    }\r\n  } else {\r\n    return getParser(options, input).parse();\r\n  }\r\n}\r\n\r\nexport function parseExpression(input: string, options?: Options): Expression {\r\n  const parser = getParser(options, input);\r\n  if (parser.options.strictMode) {\r\n    parser.state.strict = true;\r\n  }\r\n  return parser.getExpression();\r\n}\r\n\r\nexport { tokTypes };\r\n\r\nfunction getParser(options: ?Options, input: string): Parser {\r\n  let cls = Parser;\r\n  if (options && options.plugins) {\r\n    validatePlugins(options.plugins);\r\n    cls = getParserClass(options.plugins);\r\n  }\r\n\r\n  return new cls(options, input);\r\n}\r\n\r\nconst parserClassCache: { [key: string]: Class<Parser> } = {};\r\n\r\n/** Get a Parser class with plugins applied. */\r\nfunction getParserClass(pluginsFromOptions: PluginList): Class<Parser> {\r\n  const pluginList = mixinPluginNames.filter(name =>\r\n    hasPlugin(pluginsFromOptions, name),\r\n  );\r\n\r\n  const key = pluginList.join(\"/\");\r\n  let cls = parserClassCache[key];\r\n  if (!cls) {\r\n    cls = Parser;\r\n    for (const plugin of pluginList) {\r\n      cls = mixinPlugins[plugin](cls); \r\n    }\r\n    parserClassCache[key] = cls;\r\n  }\r\n  return cls;\r\n}\r\n"],"names":["beforeExpr","startsExpr","isLoop","isAssign","prefix","postfix","TokenType","constructor","label","conf","keyword","rightAssociative","binop","updateContext","keywords","Map","createKeyword","name","options","token","set","createBinop","types","num","bigint","regexp","string","eof","bracketL","bracketR","braceL","braceBarL","braceR","braceBarR","parenL","parenR","comma","semi","colon","doubleColon","dot","question","questionDot","arrow","template","ellipsis","backQuote","dollarBraceL","at","hash","interpreterDirective","eq","assign","incDec","bang","tilde","pipeline","nullishCoalescing","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","exponent","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","SCOPE_OTHER","SCOPE_PROGRAM","SCOPE_FUNCTION","SCOPE_ASYNC","SCOPE_GENERATOR","SCOPE_ARROW","SCOPE_SIMPLE_CATCH","SCOPE_SUPER","SCOPE_DIRECT_SUPER","SCOPE_CLASS","SCOPE_VAR","functionFlags","isAsync","isGenerator","BIND_KIND_VALUE","BIND_KIND_TYPE","BIND_SCOPE_VAR","BIND_SCOPE_LEXICAL","BIND_SCOPE_FUNCTION","BIND_SCOPE_OUTSIDE","BIND_FLAGS_NONE","BIND_FLAGS_CLASS","BIND_FLAGS_TS_ENUM","BIND_FLAGS_TS_CONST_ENUM","BIND_FLAGS_TS_EXPORT_ONLY","BIND_CLASS","BIND_LEXICAL","BIND_VAR","BIND_FUNCTION","BIND_TS_INTERFACE","BIND_TS_TYPE","BIND_TS_ENUM","BIND_TS_FN_TYPE","BIND_NONE","BIND_OUTSIDE","BIND_TS_CONST_ENUM","BIND_TS_NAMESPACE","isSimpleProperty","node","type","kind","method","superClass","estreeParseRegExpLiteral","pattern","flags","regex","RegExp","e","estreeParseLiteral","value","parseLiteral","directiveToStmt","directive","directiveLiteral","stmt","startNodeAt","start","loc","expression","raw","extra","finishNodeAt","end","slice","initFunction","checkDeclaration","checkGetterSetterParams","prop","paramCount","params","length","raise","checkLVal","expr","bindingType","checkClashes","contextDescription","properties","forEach","checkPropClash","propHash","computed","shorthand","key","String","proto","isStrictBody","isBlockStatement","body","isValidDirective","parenthesized","stmtToDirective","parseBlockBody","allowDirectives","topLevel","directiveStatements","directives","map","d","concat","pushClassMethod","classBody","isConstructor","allowsDirectSuper","parseMethod","typeParameters","push","parseExprAtom","refShorthandDefaultPos","state","tt","startPos","startLoc","parseFunctionBody","allowExpression","isMethod","allowDirectSuper","inClassScope","funcNode","startNode","finishNode","parseObjectMethod","isPattern","containsEsc","parseObjectProperty","toAssignable","isBinding","toAssignableObjectExpressionProp","isLast","tab","lineFeed","carriageReturn","space","exclamationMark","quotationMark","numberSign","dollarSign","percentSign","ampersand","apostrophe","leftParenthesis","rightParenthesis","asterisk","plusSign","dash","digit0","digit1","digit2","digit3","digit4","digit5","digit6","digit7","digit8","digit9","semicolon","lessThan","equalsTo","greaterThan","atSign","uppercaseA","uppercaseB","uppercaseC","uppercaseD","uppercaseE","uppercaseF","uppercaseO","uppercaseX","uppercaseZ","leftSquareBracket","backslash","rightSquareBracket","caret","underscore","graveAccent","lowercaseA","lowercaseB","lowercaseC","lowercaseD","lowercaseE","lowercaseF","lowercaseN","lowercaseO","lowercaseR","lowercaseT","lowercaseU","lowercaseV","lowercaseX","lowercaseZ","leftCurlyBrace","verticalBar","rightCurlyBrace","nonBreakingSpace","oghamSpaceMark","lineSeparator","paragraphSeparator","isDigit","code","lineBreak","lineBreakG","source","isNewLine","charCodes","skipWhiteSpace","isWhitespace","TokContext","isExpr","preserveSpace","override","braceStatement","braceExpression","templateQuasi","parenStatement","parenExpression","p","readTmplToken","functionExpression","functionStatement","context","exprAllowed","out","pop","curContext","prevType","allowed","scope","inGenerator","isIterator","braceIsBlock","statementParens","test","input","lastTokEnd","b_stat","reservedWords","strict","strictBind","reservedWordsStrictSet","Set","reservedWordsStrictBindSet","isReservedWord","word","inModule","isStrictReservedWord","has","isStrictBindReservedWord","isKeyword","keywordRelationalOperator","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","pos","i","isIdentifierStart","fromCharCode","isIteratorStart","current","next","isIdentifierChar","reservedTypes","isEsModuleType","bodyElement","declaration","hasTypeImportKind","importKind","isMaybeDefaultImport","exportSuggestions","const","let","interface","partition","list","list1","list2","FLOW_PRAGMA_REGEX","flowPragma","undefined","shouldParseTypes","getPluginOption","finishToken","val","addComment","comment","matches","exec","Error","flowParseTypeInitialiser","tok","oldInType","inType","expect","flowParseType","flowParsePredicate","moduloLoc","moduloPos","checksLoc","expectContextual","line","column","eat","parseExpression","flowParseTypeAndPredicateInitialiser","predicate","match","flowParseDeclareClass","flowParseInterfaceish","flowParseDeclareFunction","id","parseIdentifier","typeNode","typeContainer","isRelational","flowParseTypeParameterDeclaration","tmp","flowParseFunctionTypeParams","rest","returnType","typeAnnotation","resetEndLocation","flowParseDeclare","insideModule","flowParseDeclareVariable","eatContextual","flowParseDeclareModuleExports","unexpected","lastTokStart","flowParseDeclareModule","isContextual","flowParseDeclareTypeAlias","flowParseDeclareOpaqueType","flowParseDeclareInterface","flowParseDeclareExportDeclaration","flowParseTypeAnnotatableIdentifier","enter","bodyNode","parseImport","exit","hasModuleExport","errorMessage","default","isLet","suggestion","parseExport","exportKind","flowParseTypeAnnotation","flowParseTypeAlias","flowParseOpaqueType","isClass","flowParseRestrictedIdentifier","extends","implements","mixins","flowParseInterfaceExtends","flowParseObjectType","allowStatic","allowExact","allowSpread","allowProto","allowInexact","flowParseQualifiedTypeIdentifier","flowParseTypeParameterInstantiation","flowParseInterface","checkNotUnderscore","checkReservedType","indexOf","liberal","declareName","right","declare","supertype","impltype","flowParseTypeParameter","allowDefault","requireDefault","nodeStart","variance","flowParseVariance","ident","bound","jsxTagStart","defaultRequired","typeParameter","expectRelational","oldNoAnonFunctionType","noAnonFunctionType","flowParseTypeParameterInstantiationCallOrNew","flowParseTypeOrImplicitInstantiation","flowParseInterfaceType","flowParseObjectPropertyKey","flowParseObjectTypeIndexer","isStatic","static","lookahead","flowParseObjectTypeInternalSlot","optional","flowParseObjectTypeMethodish","flowParseFunctionTypeParam","flowParseObjectTypeCallProperty","valueNode","callProperties","indexers","internalSlots","endDelim","exact","inexact","protoStart","propOrInexact","flowParseObjectTypeProperty","flowObjectTypeSemicolon","isInexactToken","argument","flowCheckGetterSetterParams","property","node2","qualification","flowParseGenericType","flowParseTypeofType","flowParsePrimaryType","flowParseTupleType","lh","reinterpretTypeAsFunctionTypeParam","flowIdentToTypeAnnotation","isGroupedType","createIdentifier","flowParsePostfixType","canInsertSemicolon","elementType","flowParsePrefixType","flowParseAnonFunctionWithoutParens","param","flowParseIntersectionType","flowParseUnionType","allowPrimitiveOverride","typeCastToParameter","allowExpressionBody","forwardNoArrowParamsConversionAt","parseFunctionBodyAndFinish","parseStatement","parseExpressionStatement","shouldParseExportDeclaration","isExportDefaultSpecifier","parseConditional","noIn","refNeedsArrowPos","clone","err","SyntaxError","originalNoArrowAt","noArrowAt","consequent","failed","tryParseConditionalConsequent","valid","invalid","getArrowLikeExpressions","alternate","parseMaybeAssign","noArrowParamsConversionAt","disallowInvalid","stack","arrows","toAssignableList","checkParams","parse","result","parseParenItem","typeCastNode","assertModuleNodeAllowed","decl","parseExportDeclaration","declarationNode","specifiers","parseExportSpecifiers","parseExportFrom","eatExportStar","arguments","maybeParseExportNamespaceSpecifier","hasNamespace","parseClassId","isStatement","optionalId","getTokenFromCode","charCodeAt","finishOp","readWord","exprList","toReferencedList","isParenthesizedExpr","parseClassProperty","parseClassPrivateProperty","isClassMethod","isClassProperty","isNonstaticConstructor","pushClassPrivateMethod","parseClassSuper","superTypeParameters","implemented","parsePropertyName","parseObjPropValue","parseAssignableListItemTypes","parseMaybeDefault","left","shouldParseDefaultImport","parseImportSpecifierLocal","specifier","local","maybeParseDefaultImportSpecifier","parseImportSpecifier","firstIdentLoc","firstIdent","specifierTypeKind","isLookaheadContextual","as_ident","imported","__clone","nodeIsTypeImport","specifierIsTypeImport","checkReservedWord","parseFunctionParams","allowModifiers","parseVarId","parseAsyncArrowFromCallExpression","call","shouldParseAsyncArrow","afterLeftParse","jsxError","hasPlugin","cLength","tc","j_oTag","arrowExpression","resetStartLocationFromNode","parseArrow","shouldParseArrow","setArrowFunctionParameters","allowDuplicates","isArrowFunction","parseParenAndDistinguishExpression","canBeArrow","parseSubscripts","base","noCalls","callee","parseCallExpressionArguments","error","parseAsyncArrowWithTypeParameters","parseSubscript","subscriptState","maybeAsyncArrow","isLookaheadRelational","expectPlugin","optionalChainMember","stop","typeArguments","parseNewArguments","targs","parseArrowExpression","readToken_mult_modulo","hasFlowComment","nextToken","readToken_pipe_amp","parseTopLevel","file","program","fileNode","skipBlockComment","skipFlowComment","hasFlowCommentCompletion","shiftToFirstNonWhiteSpace","includes","ch2","ch3","entities","quot","amp","apos","lt","gt","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","copy","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","HEX_NUMBER","DECIMAL_NUMBER","j_cTag","j_expr","jsxName","jsxText","jsxTagEnd","isFragment","object","getQualifiedJSXName","namespace","jsxReadToken","chunkStart","ch","jsxReadEntity","jsxReadNewLine","normalizeCRLF","curLine","lineStart","jsxReadString","quote","str","count","entity","substr","fromCodePoint","parseInt","XHTMLEntities","jsxReadWord","jsxParseIdentifier","jsxParseNamespacedName","jsxParseElementName","newNode","jsxParseAttributeValue","jsxParseExpressionContainer","jsxParseEmptyExpression","lastTokEndLoc","jsxParseSpreadChild","jsxParseAttribute","jsxParseOpeningElementAt","jsxParseOpeningElementAfterName","attributes","selfClosing","jsxParseClosingElementAt","jsxParseElementAt","children","openingElement","closingElement","contents","openingFragment","closingFragment","jsxParseElement","refShortHandDefaultPos","inPropertyName","Scope","var","lexical","functions","ScopeHandler","scopeStack","undefinedExports","inFunction","currentVarScope","inAsync","allowSuper","currentThisScope","inNonArrowFunction","treatFunctionsAsVar","treatFunctionsAsVarInScope","currentScope","createScope","checkRedeclarationInScope","maybeExportDefined","delete","isRedeclaredInScope","checkLocalExport","TypeScriptScope","enums","constEnums","classes","exportOnlyBindings","TypeScriptScopeHandler","isConst","wasConst","nonNull","x","assert","keywordTypeFromName","getScopeHandler","tsIsIdentifier","tsNextTokenCanFollowModifier","hasPrecedingLineBreak","tsParseModifier","allowedModifiers","modifier","tsTryParse","bind","tsIsListTerminator","tsParseList","parseElement","tsParseDelimitedList","tsParseDelimitedListWorker","expectSuccess","element","tsParseBracketedList","bracket","skipFirstToken","tsParseImportType","qualifier","tsParseEntityName","tsParseTypeArguments","allowReservedWords","startNodeAtNode","tsParseTypeReference","typeName","tsParseThisTypePredicate","lhs","parameterName","tsParseTypeAnnotation","tsParseThisTypeNode","tsParseTypeQuery","exprName","tsParseTypeParameter","parseIdentifierName","constraint","tsEatThenParseType","tsTryParseTypeParameters","tsParseTypeParameters","tsTryNextParseConstantContext","tsFillSignature","returnToken","signature","returnTokenRequired","parameters","tsParseBindingListForSignature","tsParseTypeOrTypePredicateAnnotation","parseBindingList","tsParseTypeMemberSemicolon","tsParseSignatureMember","tsIsUnambiguouslyIndexSignature","tsTryParseIndexSignature","tsLookAhead","tsTryParseTypeAnnotation","tsParsePropertyOrMethodSignature","readonly","nodeAny","tsParseTypeMember","idx","tsParseTypeLiteral","members","tsParseObjectTypeMembers","tsIsStartOfMappedType","tsParseMappedTypeParameter","tsExpectThenParseType","tsParseMappedType","tsTryParseType","tsParseTupleType","elementTypes","tsParseTupleElementType","seenOptionalElement","elementNode","restNode","tsParseType","checkCommaAfterRest","optionalTypeNode","tsParseParenthesizedType","tsParseFunctionOrConstructorType","tsParseLiteralTypeNode","literal","tsParseTemplateLiteralType","templateNode","parseTemplate","expressions","tsParseNonArrayType","parseMaybeUnary","thisKeyword","tsParseArrayTypeOrHigher","objectType","indexType","tsParseTypeOperator","operator","tsParseTypeOperatorOrHigher","tsCheckTypeAnnotationForReadOnly","tsParseInferType","find","kw","tsParseUnionOrIntersectionType","parseConstituentType","tsParseIntersectionTypeOrHigher","tsParseUnionTypeOrHigher","tsIsStartOfFunctionType","tsIsUnambiguouslyStartOfFunctionType","tsSkipParameterStart","braceStackCounter","tsInType","t","typePredicateVariable","tsParseTypePredicatePrefix","tsTryParseTypeOrTypePredicateAnnotation","eatColon","tsParseNonConditionalType","checkType","extendsType","trueType","falseType","tsParseTypeAssertion","tsNextThenParseType","tsParseHeritageClause","descriptor","originalStart","delimitedList","tsParseExpressionWithTypeArguments","tsParseInterfaceDeclaration","tsParseTypeAliasDeclaration","tsInNoContext","cb","oldContext","tsDoThenParseType","tsParseEnumMember","initializer","tsParseEnumDeclaration","tsParseModuleBlock","parseBlockOrModuleBlockBody","tsParseModuleOrNamespaceDeclaration","nested","inner","tsParseAmbientExternalModuleDeclaration","global","tsParseImportEqualsDeclaration","isExport","moduleReference","tsParseModuleReference","tsIsExternalModuleReference","tsParseExternalModuleReference","f","res","tsTryParseAndCatch","tsTryParseDeclare","nany","isLineTerminator","starttype","parseFunctionStatement","parseClass","parseVarStatement","tsParseDeclaration","tsTryParseExportDeclaration","tsParseExpressionStatement","mod","tsCheckLineTerminatorAndMatch","cls","abstract","tokenType","tsTryParseGenericAsyncArrowFunction","tsIsDeclarationStart","parseAssignableListItem","decorators","accessibility","parseAccessModifier","elt","pp","parameter","bodilessType","checkFunctionStatementId","nonNullExpression","atPossibleAsync","asyncArrowFn","finishCallExpression","parseTaggedTemplateExpression","args","parseExprOp","leftStartPos","leftStartLoc","minPrec","checkKeywords","checkDuplicateExports","isAbstractClass","parseExportDefaultExpression","parseStatementContent","ahead","parseClassMember","member","constructorAllowsSuper","parseClassMemberWithIsStatic","methodOrProp","propOrIdx","parseClassPropertyName","parsePostMemberNameModifiers","pushClassProperty","isDeclare","resetStartLocation","definite","ct","parseBindingAtom","parseMaybeDecoratorArguments","isInParens","_exprListItem","canHaveLeadingDecorator","getGetterSetterExpectedParamCount","baseCount","firstParam","hasContextParam","placeholder","parsePlaceholder","expectedNode","assertNoSpace","finishPlaceholder","isFinished","verifyBreakContinue","parseBlock","parseFunctionId","takeDecorators","parseClassBody","exported","maybeParseExportDefaultSpecifier","checkExport","filter","hasStarImport","maybeParseStarImportSpecifier","parseNamedImportSpecifiers","parseImportSource","plugins","some","plugin","Array","isArray","option","PIPELINE_PROPOSALS","validatePlugins","decoratorsBeforeExport","join","mixinPlugins","estree","jsx","flow","typescript","placeholders","mixinPluginNames","Object","keys","defaultOptions","sourceType","sourceFilename","startLine","allowAwaitOutsideFunction","allowReturnOutsideFunction","allowImportExportEverywhere","allowSuperOutsideMethod","strictMode","ranges","tokens","createParenthesizedExpressions","getOptions","opts","questionMark","breakKeyword","Position","col","SourceLocation","getLineInfo","offset","lastIndex","index","BaseParser","sawUnambiguousESM","get","last","CommentsParser","filename","trailingComments","leadingComments","processComment","commentStack","firstChild","lastChild","j","lastInStack","lastComment","commentPreviousNode","splice","lastArg","innerComments","LocationParser","getLocationForPosition","lastTokStartLoc","endLoc","message","missingPluginNames","missingPlugin","State","potentialArrowAt","commaAfterSpreadAt","inParameters","maybeInArrowParameters","inPipeline","inClassProperty","topicContext","maxNumOfResolvableTopics","maxTopicIndex","classLevel","labels","decoratorStack","yieldPos","awaitPos","comments","containsOctal","octalPosition","exportedIdentifiers","invalidTemplateEscapePosition","init","curPosition","skipArrays","VALID_REGEX_FLAGS","forbiddenNumericSeparatorSiblings","decBinOct","hex","allowedNumericSeparatorSiblings","bin","oct","dec","Token","Tokenizer","isLookahead","old","curr","setStrict","lastIndexOf","skipSpace","codePointAt","pushComment","block","text","skipLineComment","startSkip","loop","readToken_numberSign","readToken_interpreter","nextPos","readToken_dot","readNumber","next2","readToken_slash","readRegexp","width","readToken_caret","readToken_plus_min","readToken_lt_gt","size","readToken_eq_excl","readToken_question","arabic","readRadixNumber","readString","escaped","inClass","charAt","content","mods","char","charCode","readInt","radix","len","forbiddenSiblings","allowedSiblings","total","Infinity","prev","Number","isNaN","isBigInt","replace","startsWithDot","isFloat","octal","parseFloat","readCodePoint","throwOnInvalid","codePos","readHexChar","readEscapedChar","containsInvalid","inTemplate","octalStr","n","readWord1","escStart","identifierCheck","esc","keywordTypes","parent","update","UtilParser","addExtra","op","l","eatRelational","messageOrType","expectOnePlugin","names","checkYieldAwaitInDefaultParams","strictDirective","Node","parser","range","NodeUtils","locationNode","LValParser","checkToRestConversion","arg","elements","raiseRestNotLast","toReferencedListDeep","parseSpread","parseRestBinding","parseObj","close","allowEmpty","elts","first","parseDecorator","elem","checkCommaAfterRestFromSpread","unwrapParenthesizedExpression","ExpressionParser","getExpression","parseYield","oldCommaAfterSpreadAt","failOnShorthandAssign","parseMaybeConditional","maybePattern","patternErrorMsg","parseExprOps","prec","checkPipelineAtInfixOperator","parseExprOpRightExpr","withTopicPermittingContext","parseSmartPipelineBody","parseExprOpBaseRightExpr","parseAwait","parseExprSubscripts","parseNoCallExpr","parseMaybePrivateName","oldMaybeInArrowParameters","oldYieldPos","oldAwaitPos","finishOptionalCallExpression","tag","quasi","importArg","possibleAsyncArrow","dynamicImport","allowPlaceholder","innerParenStart","parseExprListItem","parseImportMetaProperty","parseFunction","oldLabels","parseBooleanLiteral","parseExprList","parseFunctionExpression","parseDecorators","parseNew","primaryTopicReferenceIsAllowedInCurrentTopicContext","registerTopicReference","isPrivate","meta","parseMetaProperty","propertyName","innerStartPos","innerStartLoc","spreadStart","optionalCommaStart","spreadNodeStartPos","spreadNodeStartLoc","innerEndPos","innerEndLoc","arrowNode","parenStart","metaProp","parseTemplateElement","isTagged","cooked","tail","curElt","quasis","create","parseObjectMember","isAsyncProp","isGetterOrSetterMethod","oldInPropertyName","generator","async","isExpression","oldStrict","useStrict","oldInParameters","nonSimple","isSimpleParamList","errorPos","nameHash","identifierName","reservedTest","delegate","childExpression","pipelineStyle","checkSmartPipelineBodyStyle","checkSmartPipelineBodyEarlyErrors","parseSmartPipelineBodyInStyle","topicReferenceWasUsedInCurrentTopicContext","isSimpleReference","callback","outerContextTopicState","withTopicForbiddingContext","loopLabel","switchLabel","FUNC_NO_FLAGS","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","FUNC_NULLABLE_ID","StatementParser","interpreter","parseInterpreterDirective","from","skip","nextCh","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseWhileStatement","parseWithStatement","parseEmptyStatement","isAsyncFunction","maybeName","parseLabeledStatement","allowExport","currentContextDecorators","decorator","isBreak","lab","parseHeaderExpression","awaitAt","parseFor","parseVar","declarations","parseForIn","description","declarationPosition","discriminant","cases","cur","sawDefault","isCase","handler","clause","simple","finalizer","statementStart","createNewLexicalScope","parsedNonDirective","isForIn","await","isFor","isTypescript","statement","isHangingStatement","requireId","oldInClassProperty","hadConstructor","publicMethod","privateMethod","publicProp","privateProp","publicMember","isSimple","pushClassPrivateProperty","hasDefault","parseAfterDefault","hasStar","parseAfterNamespace","isFromRequired","hasSpecifiers","maybeParseExportNamedSpecifiers","hasDeclaration","maybeParseExportDeclaration","checkNames","isDefault","isFrom","nodes","parseNext","Parser","pluginsMap","pluginMap","getParser","ast","moduleError","scriptError","getParserClass","parserClassCache","pluginsFromOptions","pluginList"],"mappings":"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"}